üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.4 VPN et chiffrement
*Module 5 : R√©seau et s√©curit√© - Formation Debian Desktop et Server*

## Introduction aux VPN et au chiffrement

Un **VPN** (Virtual Private Network) est un tunnel s√©curis√© qui permet de cr√©er une connexion priv√©e et chiffr√©e √† travers un r√©seau public comme Internet. Le chiffrement garantit que les donn√©es √©chang√©es restent confidentielles et int√®gres, m√™me si elles transitent par des r√©seaux non s√©curis√©s.

### Pourquoi utiliser un VPN ?

**S√©curit√© :**
- **Chiffrement** : Protection des donn√©es contre l'espionnage
- **Int√©grit√©** : V√©rification que les donn√©es n'ont pas √©t√© alt√©r√©es
- **Authentification** : V√©rification de l'identit√© des parties communicantes

**Fonctionnalit√©s :**
- **Acc√®s distant** : Connexion s√©curis√©e aux ressources de l'entreprise
- **Contournement g√©ographique** : Acc√®s √† des ressources g√©o-restreintes
- **Anonymisation** : Masquage de l'adresse IP r√©elle
- **Interconnexion de sites** : Liaison s√©curis√©e entre bureaux distants

### Types de VPN

**VPN d'acc√®s distant (Remote Access VPN) :**
- Un client se connecte √† un serveur VPN
- Id√©al pour le t√©l√©travail et l'acc√®s mobile
- Exemples : employ√© qui acc√®de au r√©seau d'entreprise

**VPN site-√†-site (Site-to-Site VPN) :**
- Connexion permanente entre deux r√©seaux
- Transparent pour les utilisateurs
- Exemples : liaison entre deux bureaux d'une entreprise

**VPN peer-to-peer :**
- Connexion directe entre deux machines
- Pas de serveur centralis√©
- Id√©al pour des connexions ponctuelles

### Protocoles VPN principaux

**OpenVPN :**
- Open source et tr√®s flexible
- Utilise SSL/TLS pour le chiffrement
- Support multiplateforme excellent
- Configuration complexe mais tr√®s personnalisable

**WireGuard :**
- Moderne et minimaliste
- Performance excellente
- Configuration simple
- Cryptographie moderne int√©gr√©e

**IPSec :**
- Standard industriel
- Int√©gr√© aux syst√®mes d'exploitation
- Complexe √† configurer
- Tr√®s s√©curis√©

---

## 5.4.1 OpenVPN et WireGuard

### OpenVPN - Le VPN traditionnel flexible

**OpenVPN** est la solution VPN open source la plus populaire, reconnue pour sa flexibilit√© et sa s√©curit√©. Il utilise SSL/TLS pour √©tablir des connexions s√©curis√©es.

#### Avantages d'OpenVPN

- **Maturit√©** : Projet ancien et √©prouv√©
- **Flexibilit√©** : Configuration tr√®s personnalisable
- **Compatibilit√©** : Fonctionne sur tous les syst√®mes
- **Robustesse** : G√®re bien les connexions instables
- **Communaut√©** : Large support et documentation

#### Inconv√©nients d'OpenVPN

- **Complexit√©** : Configuration initiale difficile
- **Performance** : Plus lourd que les solutions modernes
- **Consommation** : Utilise plus de ressources CPU

### WireGuard - Le VPN moderne

**WireGuard** est un protocole VPN moderne con√ßu pour √™tre simple, rapide et s√©curis√©. Il est maintenant int√©gr√© au noyau Linux.

#### Avantages de WireGuard

- **Simplicit√©** : Configuration tr√®s simple
- **Performance** : Tr√®s rapide et l√©ger
- **S√©curit√©** : Cryptographie moderne uniquement
- **Efficacit√©** : Faible consommation de ressources
- **Mobilit√©** : Gestion intelligente des changements de r√©seau

#### Inconv√©nients de WireGuard

- **Jeunesse** : Plus r√©cent, moins de retour d'exp√©rience
- **Simplicit√©** : Moins de fonctionnalit√©s avanc√©es
- **Gestion des IPs** : Attribution d'IP statique obligatoire

### Comparaison OpenVPN vs WireGuard

| Crit√®re | OpenVPN | WireGuard |
|---------|----------|-----------|
| **Facilit√© d'installation** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Facilit√© de configuration** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Performance** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Flexibilit√©** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Maturit√©** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **S√©curit√©** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Support multiplateforme** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |

### Installation d'OpenVPN

#### Installation du serveur et client OpenVPN

```bash
# Mise √† jour des paquets
sudo apt update

# Installation d'OpenVPN et Easy-RSA pour la gestion des certificats
sudo apt install openvpn easy-rsa

# V√©rification de l'installation
openvpn --version
```

#### Structure des r√©pertoires OpenVPN

```bash
# R√©pertoires principaux
/etc/openvpn/          # Configurations principales
/etc/openvpn/server/   # Configurations serveur
/etc/openvpn/client/   # Configurations client
/var/log/openvpn/      # Logs OpenVPN
/usr/share/easy-rsa/   # Scripts Easy-RSA
```

### Installation de WireGuard

#### Installation sur Debian

```bash
# Mise √† jour des paquets
sudo apt update

# Installation de WireGuard
sudo apt install wireguard wireguard-tools

# V√©rification de l'installation
wg --version
```

#### V√©rification du support kernel

```bash
# V√©rifier que le module WireGuard est disponible
sudo modprobe wireguard

# V√©rifier le chargement du module
lsmod | grep wireguard

# Information sur la version du kernel
uname -r
```

### Concepts fondamentaux des cl√©s WireGuard

WireGuard utilise la cryptographie √† courbes elliptiques avec des paires de cl√©s publiques/priv√©es.

#### G√©n√©ration de cl√©s WireGuard

```bash
# G√©n√©rer une cl√© priv√©e
wg genkey

# G√©n√©rer une cl√© priv√©e et la sauvegarder
wg genkey | sudo tee /etc/wireguard/server_private.key

# G√©n√©rer la cl√© publique correspondante √† partir de la cl√© priv√©e
sudo cat /etc/wireguard/server_private.key | wg pubkey | sudo tee /etc/wireguard/server_public.key

# G√©n√©rer une cl√© pr√©-partag√©e (optionnel, s√©curit√© suppl√©mentaire)
wg genpsk | sudo tee /etc/wireguard/preshared.key
```

#### S√©curisation des fichiers de cl√©s

```bash
# Prot√©ger les cl√©s priv√©es
sudo chmod 600 /etc/wireguard/server_private.key
sudo chmod 600 /etc/wireguard/preshared.key

# Les cl√©s publiques peuvent √™tre lisibles
sudo chmod 644 /etc/wireguard/server_public.key

# Propri√©taire root uniquement
sudo chown root:root /etc/wireguard/*.key
```

### Concepts de routage et adressage

#### Plans d'adressage VPN

**R√©seaux priv√©s recommand√©s pour VPN :**
```bash
# RFC 1918 - Adresses priv√©es
10.0.0.0/8     # 10.0.0.0 √† 10.255.255.255
172.16.0.0/12  # 172.16.0.0 √† 172.31.255.255
192.168.0.0/16 # 192.168.0.0 √† 192.168.255.255

# Exemples d'attribution VPN
10.8.0.0/24    # R√©seau VPN courant (OpenVPN par d√©faut)
10.13.13.0/24  # R√©seau WireGuard exemple
```

#### Concepts de routage VPN

**Route par d√©faut (Full Tunnel) :**
- Tout le trafic passe par le VPN
- Configuration : `0.0.0.0/0` ou `::/0`
- Usage : S√©curit√© maximale, anonymisation

**Routage s√©lectif (Split Tunnel) :**
- Seules certaines destinations passent par le VPN
- Configuration : routes sp√©cifiques
- Usage : Acc√®s aux ressources d'entreprise uniquement

```bash
# Exemple de routage s√©lectif
# Uniquement le r√©seau d'entreprise via VPN
10.0.0.0/8
192.168.100.0/24

# Internet en direct
# (pas de route par d√©faut)
```

---

## 5.4.2 Configuration client/serveur

### Configuration OpenVPN - Serveur

#### Pr√©paration de l'infrastructure de certificats

```bash
# Cr√©er le r√©pertoire pour Easy-RSA
sudo mkdir -p /etc/openvpn/easy-rsa
cd /etc/openvpn/easy-rsa

# Copier les scripts Easy-RSA
sudo cp -r /usr/share/easy-rsa/* .

# Initialiser l'infrastructure PKI
sudo ./easyrsa init-pki

# Cr√©er l'autorit√© de certification (CA)
sudo ./easyrsa build-ca nopass

# G√©n√©rer la cl√© et le certificat du serveur
sudo ./easyrsa gen-req server nopass
sudo ./easyrsa sign-req server server

# G√©n√©rer les param√®tres Diffie-Hellman
sudo ./easyrsa gen-dh

# G√©n√©rer une cl√© tls-auth pour la s√©curit√© suppl√©mentaire
sudo openvpn --genkey --secret pki/ta.key
```

#### Configuration du serveur OpenVPN

```bash
# Cr√©er le fichier de configuration serveur
sudo nano /etc/openvpn/server/server.conf
```

```bash
# Configuration OpenVPN Server
port 1194
proto udp
dev tun

# Certificats et cl√©s
ca /etc/openvpn/easy-rsa/pki/ca.crt
cert /etc/openvpn/easy-rsa/pki/issued/server.crt
key /etc/openvpn/easy-rsa/pki/private/server.key
dh /etc/openvpn/easy-rsa/pki/dh.pem

# R√©seau VPN
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist /var/log/openvpn/ipp.txt

# Routes pouss√©es vers les clients
push "redirect-gateway def1 bypass-dhcp"
push "dhcp-option DNS 8.8.8.8"
push "dhcp-option DNS 8.8.4.4"

# Param√®tres de s√©curit√©
tls-auth /etc/openvpn/easy-rsa/pki/ta.key 0
cipher AES-256-GCM
auth SHA256
tls-version-min 1.2
tls-cipher TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384

# Param√®tres de connexion
keepalive 10 120
comp-lzo no
persist-key
persist-tun

# Utilisateur et groupe (s√©curit√©)
user nobody
group nogroup

# Logging
status /var/log/openvpn/openvpn-status.log
log-append /var/log/openvpn/openvpn.log
verb 3
mute 20

# Options pour clients multiples
client-to-client
duplicate-cn
```

#### Activation du forwarding IP

```bash
# Activer le forwarding IP temporairement
sudo sysctl -w net.ipv4.ip_forward=1

# Rendre permanent le forwarding
echo 'net.ipv4.ip_forward=1' | sudo tee -a /etc/sysctl.conf

# Appliquer les changements
sudo sysctl -p
```

#### Configuration du pare-feu pour OpenVPN

```bash
# Autoriser le port OpenVPN
sudo ufw allow 1194/udp

# Autoriser le forwarding depuis l'interface VPN
sudo ufw route allow in on tun0

# Configuration de NAT pour que les clients VPN acc√®dent √† Internet
sudo iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE

# Rendre les r√®gles iptables permanentes
sudo iptables-save | sudo tee /etc/iptables/rules.v4
```

#### D√©marrage du serveur OpenVPN

```bash
# D√©marrer le service OpenVPN
sudo systemctl start openvpn-server@server

# Activer le d√©marrage automatique
sudo systemctl enable openvpn-server@server

# V√©rifier le statut
sudo systemctl status openvpn-server@server

# Voir les logs
sudo journalctl -u openvpn-server@server -f
```

### Configuration OpenVPN - Client

#### G√©n√©ration des certificats client

```bash
# Se placer dans le r√©pertoire Easy-RSA
cd /etc/openvpn/easy-rsa

# G√©n√©rer la requ√™te de certificat pour un client
sudo ./easyrsa gen-req client1 nopass

# Signer le certificat client
sudo ./easyrsa sign-req client client1
```

#### Configuration du client OpenVPN

```bash
# Cr√©er le fichier de configuration client
sudo nano /etc/openvpn/client/client1.conf
```

```bash
# Configuration OpenVPN Client
client
dev tun
proto udp

# Adresse du serveur VPN
remote votre-serveur.example.com 1194

# R√©solution DNS
resolv-retry infinite
nobind

# Persistance
persist-key
persist-tun

# Certificats (chemins locaux sur le client)
ca ca.crt
cert client1.crt
key client1.key

# S√©curit√©
tls-auth ta.key 1
cipher AES-256-GCM
auth SHA256
key-direction 1

# Compression
comp-lzo no

# Logging
verb 3
```

#### Cr√©ation d'un fichier .ovpn unifi√©

```bash
#!/bin/bash
# Script pour cr√©er un fichier .ovpn avec certificats int√©gr√©s

CLIENT_NAME="client1"
OUTPUT_FILE="${CLIENT_NAME}.ovpn"

# Base de la configuration
cat > $OUTPUT_FILE << 'EOF'
client
dev tun
proto udp
remote votre-serveur.example.com 1194
resolv-retry infinite
nobind
persist-key
persist-tun
cipher AES-256-GCM
auth SHA256
key-direction 1
comp-lzo no
verb 3

EOF

# Ajouter les certificats int√©gr√©s
echo '<ca>' >> $OUTPUT_FILE
cat /etc/openvpn/easy-rsa/pki/ca.crt >> $OUTPUT_FILE
echo '</ca>' >> $OUTPUT_FILE

echo '<cert>' >> $OUTPUT_FILE
cat /etc/openvpn/easy-rsa/pki/issued/${CLIENT_NAME}.crt >> $OUTPUT_FILE
echo '</cert>' >> $OUTPUT_FILE

echo '<key>' >> $OUTPUT_FILE
cat /etc/openvpn/easy-rsa/pki/private/${CLIENT_NAME}.key >> $OUTPUT_FILE
echo '</key>' >> $OUTPUT_FILE

echo '<tls-auth>' >> $OUTPUT_FILE
cat /etc/openvpn/easy-rsa/pki/ta.key >> $OUTPUT_FILE
echo '</tls-auth>' >> $OUTPUT_FILE

echo "Fichier $OUTPUT_FILE cr√©√© avec succ√®s"
```

### Configuration WireGuard - Serveur

#### Configuration du serveur WireGuard

```bash
# Cr√©er le fichier de configuration serveur
sudo nano /etc/wireguard/wg0.conf
```

```bash
# Configuration WireGuard Server (wg0)
[Interface]
# Cl√© priv√©e du serveur
PrivateKey = [CL√â_PRIV√âE_SERVEUR_G√âN√âR√âE]

# Adresse IP du serveur dans le VPN
Address = 10.13.13.1/24

# Port d'√©coute
ListenPort = 51820

# Commandes post-up et post-down pour le routage
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# Configuration des clients (√† ajouter pour chaque client)
[Peer]
# Cl√© publique du client
PublicKey = [CL√â_PUBLIQUE_CLIENT]

# Cl√© pr√©-partag√©e (optionnel)
PresharedKey = [CL√â_PR√â-PARTAG√âE]

# Adresses IP autoris√©es pour ce client
AllowedIPs = 10.13.13.2/32

# Maintien de la connexion (pour les clients derri√®re NAT)
PersistentKeepalive = 25
```

#### Exemple complet avec vraies cl√©s

```bash
# G√©n√©rer les cl√©s pour le serveur
cd /etc/wireguard
sudo wg genkey | sudo tee server_private.key | wg pubkey | sudo tee server_public.key

# G√©n√©rer les cl√©s pour un client
sudo wg genkey | sudo tee client1_private.key | wg pubkey | sudo tee client1_public.key

# G√©n√©rer une cl√© pr√©-partag√©e
sudo wg genpsk | sudo tee client1_preshared.key

# Configuration compl√®te avec les vraies cl√©s
sudo nano /etc/wireguard/wg0.conf
```

```bash
[Interface]
PrivateKey = [contenu de server_private.key]
Address = 10.13.13.1/24
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

[Peer]
PublicKey = [contenu de client1_public.key]
PresharedKey = [contenu de client1_preshared.key]
AllowedIPs = 10.13.13.2/32
PersistentKeepalive = 25
```

#### Activation du serveur WireGuard

```bash
# Corriger les permissions
sudo chmod 600 /etc/wireguard/wg0.conf

# D√©marrer l'interface WireGuard
sudo wg-quick up wg0

# V√©rifier l'√©tat
sudo wg show

# Activer au d√©marrage
sudo systemctl enable wg-quick@wg0

# Gestion du service
sudo systemctl start wg-quick@wg0
sudo systemctl status wg-quick@wg0
```

#### Configuration du pare-feu pour WireGuard

```bash
# Autoriser le port WireGuard
sudo ufw allow 51820/udp

# Activer le forwarding IP
echo 'net.ipv4.ip_forward=1' | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
```

### Configuration WireGuard - Client

#### Configuration du client WireGuard

```bash
# Sur la machine cliente, cr√©er la configuration
sudo nano /etc/wireguard/wg0.conf
```

```bash
# Configuration WireGuard Client
[Interface]
# Cl√© priv√©e du client
PrivateKey = [CL√â_PRIV√âE_CLIENT]

# Adresse IP du client dans le VPN
Address = 10.13.13.2/24

# DNS (optionnel)
DNS = 8.8.8.8, 8.8.4.4

[Peer]
# Cl√© publique du serveur
PublicKey = [CL√â_PUBLIQUE_SERVEUR]

# Cl√© pr√©-partag√©e (si utilis√©e)
PresharedKey = [CL√â_PR√â-PARTAG√âE]

# Adresse du serveur WireGuard
Endpoint = votre-serveur.example.com:51820

# Routes via le VPN (tout le trafic)
AllowedIPs = 0.0.0.0/0

# Maintien de la connexion
PersistentKeepalive = 25
```

#### Configuration client pour acc√®s s√©lectif

```bash
# Configuration pour n'utiliser le VPN que pour certains r√©seaux
[Interface]
PrivateKey = [CL√â_PRIV√âE_CLIENT]
Address = 10.13.13.2/24

[Peer]
PublicKey = [CL√â_PUBLIQUE_SERVEUR]
PresharedKey = [CL√â_PR√â-PARTAG√âE]
Endpoint = votre-serveur.example.com:51820

# Seulement le r√©seau de l'entreprise via VPN
AllowedIPs = 10.0.0.0/8, 192.168.100.0/24

PersistentKeepalive = 25
```

#### Connexion du client WireGuard

```bash
# D√©marrer la connexion VPN
sudo wg-quick up wg0

# V√©rifier la connexion
sudo wg show
ip addr show wg0

# Tester la connectivit√©
ping 10.13.13.1  # IP du serveur VPN

# Arr√™ter la connexion
sudo wg-quick down wg0
```

### Scripts de gestion automatis√©e

#### Script de cr√©ation de client WireGuard

```bash
#!/bin/bash
# /usr/local/bin/wg-add-client.sh

set -e

# Variables
CLIENT_NAME="$1"
SERVER_CONFIG="/etc/wireguard/wg0.conf"
CLIENT_DIR="/etc/wireguard/clients"
NEXT_IP=""

if [ -z "$CLIENT_NAME" ]; then
    echo "Usage: $0 <nom_client>"
    exit 1
fi

# Cr√©er le r√©pertoire clients
mkdir -p $CLIENT_DIR

# Trouver la prochaine IP disponible
LAST_IP=$(grep -E "AllowedIPs.*\..*/" $SERVER_CONFIG | cut -d'=' -f2 | cut -d'/' -f1 | cut -d'.' -f4 | sort -n | tail -1)
NEXT_IP_NUM=$((LAST_IP + 1))
NEXT_IP="10.13.13.$NEXT_IP_NUM"

echo "Attribution de l'IP $NEXT_IP √† $CLIENT_NAME"

# G√©n√©rer les cl√©s pour le client
CLIENT_PRIVATE_KEY=$(wg genkey)
CLIENT_PUBLIC_KEY=$(echo $CLIENT_PRIVATE_KEY | wg pubkey)
PRESHARED_KEY=$(wg genpsk)

# R√©cup√©rer la cl√© publique du serveur
SERVER_PUBLIC_KEY=$(grep PrivateKey $SERVER_CONFIG | cut -d'=' -f2 | tr -d ' ' | wg pubkey)

# Cr√©er la configuration client
cat > $CLIENT_DIR/$CLIENT_NAME.conf << EOF
[Interface]
PrivateKey = $CLIENT_PRIVATE_KEY
Address = $NEXT_IP/24
DNS = 8.8.8.8

[Peer]
PublicKey = $SERVER_PUBLIC_KEY
PresharedKey = $PRESHARED_KEY
Endpoint = $(curl -s ipinfo.io/ip):51820
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25
EOF

# Ajouter le peer au serveur
cat >> $SERVER_CONFIG << EOF

[Peer]
# $CLIENT_NAME
PublicKey = $CLIENT_PUBLIC_KEY
PresharedKey = $PRESHARED_KEY
AllowedIPs = $NEXT_IP/32
EOF

# Red√©marrer WireGuard
systemctl restart wg-quick@wg0

echo "Client $CLIENT_NAME cr√©√© avec succ√®s"
echo "Configuration disponible dans: $CLIENT_DIR/$CLIENT_NAME.conf"
echo "Adresse IP attribu√©e: $NEXT_IP"
```

#### Script de cr√©ation de client OpenVPN

```bash
#!/bin/bash
# /usr/local/bin/openvpn-add-client.sh

CLIENT_NAME="$1"
EASY_RSA_DIR="/etc/openvpn/easy-rsa"
CLIENT_DIR="/etc/openvpn/clients"

if [ -z "$CLIENT_NAME" ]; then
    echo "Usage: $0 <nom_client>"
    exit 1
fi

# Cr√©er le r√©pertoire clients
mkdir -p $CLIENT_DIR

# Aller dans le r√©pertoire Easy-RSA
cd $EASY_RSA_DIR

# G√©n√©rer le certificat client
./easyrsa gen-req $CLIENT_NAME nopass
./easyrsa sign-req client $CLIENT_NAME

# Cr√©er le fichier .ovpn
cat > $CLIENT_DIR/$CLIENT_NAME.ovpn << 'EOF'
client
dev tun
proto udp
remote YOUR_SERVER_IP 1194
resolv-retry infinite
nobind
persist-key
persist-tun
cipher AES-256-GCM
auth SHA256
key-direction 1
comp-lzo no
verb 3

EOF

# Ajouter les certificats
echo '<ca>' >> $CLIENT_DIR/$CLIENT_NAME.ovpn
cat pki/ca.crt >> $CLIENT_DIR/$CLIENT_NAME.ovpn
echo '</ca>' >> $CLIENT_DIR/$CLIENT_NAME.ovpn

echo '<cert>' >> $CLIENT_DIR/$CLIENT_NAME.ovpn
cat pki/issued/$CLIENT_NAME.crt >> $CLIENT_DIR/$CLIENT_NAME.ovpn
echo '</cert>' >> $CLIENT_DIR/$CLIENT_NAME.ovpn

echo '<key>' >> $CLIENT_DIR/$CLIENT_NAME.ovpn
cat pki/private/$CLIENT_NAME.key >> $CLIENT_DIR/$CLIENT_NAME.ovpn
echo '</key>' >> $CLIENT_DIR/$CLIENT_NAME.ovpn

echo '<tls-auth>' >> $CLIENT_DIR/$CLIENT_NAME.ovpn
cat pki/ta.key >> $CLIENT_DIR/$CLIENT_NAME.ovpn
echo '</tls-auth>' >> $CLIENT_DIR/$CLIENT_NAME.ovpn

echo "Client OpenVPN $CLIENT_NAME cr√©√©: $CLIENT_DIR/$CLIENT_NAME.ovpn"
```

---

## 5.4.3 Certificats et PKI

### Introduction √† la PKI (Public Key Infrastructure)

Une **PKI** (Infrastructure de Cl√©s Publiques) est un ensemble de r√¥les, politiques, et proc√©dures n√©cessaires pour cr√©er, g√©rer, distribuer, utiliser, stocker et r√©voquer des certificats num√©riques et g√©rer les cl√©s publiques.

#### Composants d'une PKI

**Autorit√© de Certification (CA) :**
- Entit√© qui √©met et r√©voque les certificats
- Racine de confiance de l'infrastructure
- Signe les certificats avec sa cl√© priv√©e

**Autorit√© d'Enregistrement (RA) :**
- V√©rifie l'identit√© avant √©mission de certificat
- Interface entre utilisateurs et CA
- Peut d√©l√©guer certaines t√¢ches de la CA

**Certificats num√©riques :**
- Fichiers contenant cl√© publique + identit√© + signature CA
- Standard X.509 le plus couramment utilis√©
- Permettent l'authentification et le chiffrement

#### Hi√©rarchie des certificats

```
CA Racine (Root CA)
    ‚îú‚îÄ‚îÄ CA Interm√©diaire 1
    ‚îÇ   ‚îú‚îÄ‚îÄ Certificat Serveur 1
    ‚îÇ   ‚îú‚îÄ‚îÄ Certificat Serveur 2
    ‚îÇ   ‚îî‚îÄ‚îÄ Certificat Client 1
    ‚îî‚îÄ‚îÄ CA Interm√©diaire 2
        ‚îú‚îÄ‚îÄ Certificat Client 2
        ‚îî‚îÄ‚îÄ Certificat Client 3
```

### Easy-RSA pour OpenVPN

**Easy-RSA** est un ensemble de scripts qui simplifient la gestion d'une PKI pour OpenVPN.

#### Installation et initialisation d'Easy-RSA

```bash
# Installation
sudo apt install easy-rsa

# Cr√©er un r√©pertoire d√©di√©
sudo mkdir -p /etc/openvpn/easy-rsa
cd /etc/openvpn/easy-rsa

# Copier les scripts
sudo cp -r /usr/share/easy-rsa/* .

# Cr√©er le fichier de variables
sudo nano vars
```

#### Configuration des variables Easy-RSA

```bash
# /etc/openvpn/easy-rsa/vars
set_var EASYRSA_REQ_COUNTRY    "FR"
set_var EASYRSA_REQ_PROVINCE   "Ile-de-France"
set_var EASYRSA_REQ_CITY       "Paris"
set_var EASYRSA_REQ_ORG        "Mon Entreprise"
set_var EASYRSA_REQ_EMAIL      "admin@exemple.com"
set_var EASYRSA_REQ_OU         "IT Department"
set_var EASYRSA_KEY_SIZE       4096
set_var EASYRSA_ALGO           rsa
set_var EASYRSA_CA_EXPIRE      7300  # 20 ans
set_var EASYRSA_CERT_EXPIRE    3650  # 10 ans
set_var EASYRSA_CRL_DAYS       3650  # 10 ans
```

#### Cr√©ation de l'infrastructure PKI

```bash
# Charger les variables
source ./vars

# Initialiser la PKI
./easyrsa init-pki

# Cr√©er l'autorit√© de certification
./easyrsa build-ca

# Cr√©er une demande de certificat pour le serveur
./easyrsa gen-req server nopass

# Signer le certificat serveur
./easyrsa sign-req server server

# G√©n√©rer les param√®tres Diffie-Hellman
./easyrsa gen-dh

# G√©n√©rer une cl√© TLS-Auth
openvpn --genkey --secret pki/ta.key
```

#### Gestion des certificats clients

```bash
# Cr√©er un certificat client
./easyrsa gen-req client1 nopass
./easyrsa sign-req client client1

# Cr√©er un certificat client avec mot de passe
./easyrsa gen-req client2
./easyrsa sign-req client client2

# Cr√©er un certificat avec dur√©e de vie personnalis√©e
./easyrsa --days=365 sign-req client client3

# Voir les certificats √©mis
ls pki/issued/

# Voir les cl√©s priv√©es
ls pki/private/
```

#### R√©vocation de certificats

La r√©vocation permet d'invalider un certificat avant son expiration.

```bash
# R√©voquer un certificat client
./easyrsa revoke client1

# G√©n√©rer la liste de r√©vocation (CRL)
./easyrsa gen-crl

# Copier la CRL dans le r√©pertoire OpenVPN
sudo cp pki/crl.pem /etc/openvpn/

# Ajouter la v√©rification CRL dans la configuration serveur
echo "crl-verify /etc/openvpn/crl.pem" | sudo tee -a /etc/openvpn/server/server.conf
```

#### Renouvellement de certificats

```bash
# V√©rifier l'expiration des certificats
./easyrsa show-cert server
./easyrsa show-cert client1

# Renouveler un certificat serveur
./easyrsa renew server nopass

# Renouveler un certificat client
./easyrsa renew client1 nopass

# Script de v√©rification d'expiration
#!/bin/bash
# /usr/local/bin/check-cert-expiry.sh

CERT_DIR="/etc/openvpn/easy-rsa/pki/issued"
WARNING_DAYS=30

for cert in $CERT_DIR/*.crt; do
    if [ -f "$cert" ]; then
        cert_name=$(basename "$cert" .crt)
        expiry_date=$(openssl x509 -in "$cert" -noout -enddate | cut -d= -f2)
        expiry_epoch=$(date -d "$expiry_date" +%s)
        current_epoch=$(date +%s)
        days_left=$(( (expiry_epoch - current_epoch) / 86400 ))

        if [ $days_left -lt $WARNING_DAYS ]; then
            echo "ATTENTION: Le certificat $cert_name expire dans $days_left jours"
            echo "Date d'expiration: $expiry_date"
        fi
    fi
done
```

### PKI avanc√©e avec OpenSSL

Pour des besoins plus complexes, OpenSSL offre un contr√¥le total sur la PKI.

#### Configuration OpenSSL pour PKI

```bash
# Cr√©er la structure de r√©pertoires
sudo mkdir -p /etc/ssl/CA/{private,certs,newcerts,crl}
sudo touch /etc/ssl/CA/index.txt
sudo echo 1000 | sudo tee /etc/ssl/CA/serial

# Configuration OpenSSL personnalis√©e
sudo nano /etc/ssl/CA/openssl.cnf
```

```ini
# Configuration OpenSSL pour PKI
[ ca ]
default_ca = CA_default

[ CA_default ]
dir               = /etc/ssl/CA
certs             = $dir/certs
crl_dir           = $dir/crl
new_certs_dir     = $dir/newcerts
database          = $dir/index.txt
serial            = $dir/serial
RANDFILE          = $dir/private/.rand

private_key       = $dir/private/ca.key.pem
certificate       = $dir/certs/ca.cert.pem

crlnumber         = $dir/crlnumber
crl               = $dir/crl/ca.crl.pem
crl_extensions    = crl_ext
default_crl_days  = 30

default_md        = sha256
name_opt          = ca_default
cert_opt          = ca_default
default_days      = 375
preserve          = no
policy            = policy_strict

[ policy_strict ]
countryName             = match
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
default_bits        = 4096
distinguished_name  = req_distinguished_name
string_mask         = utf8only
default_md          = sha256
x509_extensions     = v3_ca

[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
stateOrProvinceName             = State or Province Name
localityName                    = Locality Name
0.organizationName              = Organization Name
organizationalUnitName          = Organizational Unit Name
commonName                      = Common Name
emailAddress                    = Email Address

[ v3_ca ]
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, cRLSign, keyCertSign

[ server_cert ]
basicConstraints = CA:FALSE
nsCertType = server
nsComment = "OpenSSL Generated Server Certificate"
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth

[ client_cert ]
basicConstraints = CA:FALSE
nsCertType = client, email
nsComment = "OpenSSL Generated Client Certificate"
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, emailProtection
```

#### Cr√©ation de la CA racine avec OpenSSL

```bash
# G√©n√©rer la cl√© priv√©e de la CA
sudo openssl genrsa -aes256 -out /etc/ssl/CA/private/ca.key.pem 4096
sudo chmod 400 /etc/ssl/CA/private/ca.key.pem

# Cr√©er le certificat racine
sudo openssl req -config /etc/ssl/CA/openssl.cnf \
    -key /etc/ssl/CA/private/ca.key.pem \
    -new -x509 -days 7300 -sha256 -extensions v3_ca \
    -out /etc/ssl/CA/certs/ca.cert.pem

sudo chmod 444 /etc/ssl/CA/certs/ca.cert.pem

# V√©rifier le certificat
sudo openssl x509 -noout -text -in /etc/ssl/CA/certs/ca.cert.pem
```

#### √âmission de certificats serveur avec OpenSSL

```bash
# G√©n√©rer la cl√© priv√©e du serveur
sudo openssl genrsa -out /etc/ssl/CA/private/server.key.pem 4096
sudo chmod 400 /etc/ssl/CA/private/server.key.pem

# Cr√©er la demande de certificat
sudo openssl req -config /etc/ssl/CA/openssl.cnf \
    -key /etc/ssl/CA/private/server.key.pem \
    -new -sha256 -out /etc/ssl/CA/server.csr.pem

# Signer le certificat serveur
sudo openssl ca -config /etc/ssl/CA/openssl.cnf \
    -extensions server_cert -days 375 -notext -md sha256 \
    -in /etc/ssl/CA/server.csr.pem \
    -out /etc/ssl/CA/certs/server.cert.pem

sudo chmod 444 /etc/ssl/CA/certs/server.cert.pem

# V√©rifier le certificat serveur
sudo openssl x509 -noout -text -in /etc/ssl/CA/certs/server.cert.pem
```

### Certificats auto-sign√©s pour WireGuard

WireGuard n'utilise pas de certificats X.509 mais des cl√©s de cryptographie √† courbes elliptiques.

#### G√©n√©ration et gestion des cl√©s WireGuard

```bash
#!/bin/bash
# /usr/local/bin/wg-key-manager.sh

KEY_DIR="/etc/wireguard/keys"
sudo mkdir -p $KEY_DIR

generate_keypair() {
    local name=$1
    local private_key="$KEY_DIR/${name}_private.key"
    local public_key="$KEY_DIR/${name}_public.key"

    if [ -f "$private_key" ]; then
        echo "Cl√©s pour $name existent d√©j√†"
        return 1
    fi

    # G√©n√©rer la paire de cl√©s
    wg genkey | sudo tee "$private_key" | wg pubkey | sudo tee "$public_key"

    # S√©curiser la cl√© priv√©e
    sudo chmod 600 "$private_key"
    sudo chmod 644 "$public_key"

    echo "Cl√©s g√©n√©r√©es pour $name:"
    echo "  Priv√©e: $private_key"
    echo "  Publique: $public_key"
}

list_keys() {
    echo "=== Cl√©s WireGuard disponibles ==="
    for key in $KEY_DIR/*_public.key; do
        if [ -f "$key" ]; then
            name=$(basename "$key" _public.key)
            echo "  $name: $(cat $key)"
        fi
    done
}

case "$1" in
    generate)
        if [ -z "$2" ]; then
            echo "Usage: $0 generate <nom>"
            exit 1
        fi
        generate_keypair "$2"
        ;;
    list)
        list_keys
        ;;
    *)
        echo "Usage: $0 {generate|list} [nom]"
        ;;
esac
```

#### Rotation des cl√©s WireGuard

```bash
#!/bin/bash
# /usr/local/bin/wg-rotate-keys.sh

CONFIG_FILE="/etc/wireguard/wg0.conf"
BACKUP_DIR="/etc/wireguard/backup"

rotate_server_key() {
    echo "=== Rotation de la cl√© serveur WireGuard ==="

    # Cr√©er une sauvegarde
    sudo mkdir -p $BACKUP_DIR
    sudo cp $CONFIG_FILE "$BACKUP_DIR/wg0.conf.$(date +%Y%m%d-%H%M%S)"

    # G√©n√©rer nouvelle cl√© priv√©e
    NEW_PRIVATE=$(wg genkey)
    NEW_PUBLIC=$(echo $NEW_PRIVATE | wg pubkey)

    echo "Nouvelle cl√© publique serveur: $NEW_PUBLIC"

    # Mettre √† jour la configuration serveur
    sudo sed -i "s/^PrivateKey = .*/PrivateKey = $NEW_PRIVATE/" $CONFIG_FILE

    echo "Configuration serveur mise √† jour"
    echo "IMPORTANT: Mettez √† jour tous les clients avec la nouvelle cl√© publique serveur:"
    echo "  $NEW_PUBLIC"

    # Red√©marrer WireGuard
    sudo wg-quick down wg0 2>/dev/null || true
    sudo wg-quick up wg0

    echo "Serveur WireGuard red√©marr√© avec les nouvelles cl√©s"
}

rotate_server_key
```

### Gestion des certificats avec Certbot (Let's Encrypt)

Pour les certificats SSL/TLS publics, Let's Encrypt offre des certificats gratuits.

#### Installation de Certbot

```bash
# Installation de Certbot
sudo apt update
sudo apt install certbot python3-certbot-apache python3-certbot-nginx

# Ou installation via snap (plus r√©cent)
sudo snap install core; sudo snap refresh core
sudo snap install --classic certbot
sudo ln -s /snap/bin/certbot /usr/bin/certbot
```

#### Obtention de certificats Let's Encrypt

```bash
# Pour Apache
sudo certbot --apache -d exemple.com -d www.exemple.com

# Pour Nginx
sudo certbot --nginx -d exemple.com -d www.exemple.com

# Mode standalone (sans serveur web)
sudo certbot certonly --standalone -d exemple.com

# Mode webroot (avec serveur web existant)
sudo certbot certonly --webroot -w /var/www/html -d exemple.com

# Mode DNS (n√©cessite plugin sp√©cifique)
sudo certbot certonly --dns-cloudflare -d exemple.com
```

#### Renouvellement automatique

```bash
# Tester le renouvellement
sudo certbot renew --dry-run

# Configuration du renouvellement automatique
sudo nano /etc/cron.d/certbot
```

```bash
# Renouvellement automatique Let's Encrypt
0 12 * * * root test -x /usr/bin/certbot -a \! -d /run/systemd/system && perl -e 'sleep int(rand(43200))' && certbot -q renew --renew-hook "systemctl reload nginx"
```

---

## 5.4.4 Chiffrement des donn√©es

### Introduction au chiffrement des donn√©es

Le chiffrement des donn√©es est essentiel pour prot√©ger les informations sensibles, que ce soit en transit (pendant la transmission) ou au repos (stockage).

#### Types de chiffrement

**Chiffrement sym√©trique :**
- Une seule cl√© pour chiffrer et d√©chiffrer
- Rapide et efficace pour de gros volumes
- Probl√®me de distribution de la cl√©

**Chiffrement asym√©trique :**
- Paire de cl√©s : publique et priv√©e
- Plus lent que le sym√©trique
- R√©sout le probl√®me de distribution de cl√©s

**Chiffrement hybride :**
- Combine les deux approches
- Cl√© sym√©trique pour les donn√©es
- Cl√© asym√©trique pour √©changer la cl√© sym√©trique

### Chiffrement de fichiers avec GPG

**GPG** (GNU Privacy Guard) est l'impl√©mentation libre d'OpenPGP pour le chiffrement de fichiers et emails.

#### Installation et configuration de GPG

```bash
# Installation
sudo apt update
sudo apt install gnupg

# V√©rification
gpg --version

# G√©n√©rer une paire de cl√©s
gpg --full-generate-key
```

#### G√©n√©ration de cl√©s GPG

```bash
# G√©n√©ration interactive compl√®te
gpg --full-generate-key

# Options recommand√©es :
# Type de cl√© : (1) RSA et RSA (par d√©faut)
# Taille : 4096 bits
# Dur√©e de validit√© : 2y (2 ans)
# Nom r√©el : Votre nom complet
# Email : votre@email.com
# Commentaire : optionnel

# G√©n√©ration non-interactive (pour scripts)
gpg --batch --generate-key << EOF
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: Admin Serveur
Name-Email: admin@exemple.com
Expire-Date: 2y
Passphrase: motdepasse_securise
EOF
```

#### Utilisation de GPG pour le chiffrement

```bash
# Lister les cl√©s
gpg --list-keys
gpg --list-secret-keys

# Chiffrer un fichier (cl√© publique du destinataire)
gpg --encrypt --recipient admin@exemple.com fichier.txt

# Chiffrer pour soi-m√™me
gpg --encrypt --recipient votre@email.com document.pdf

# Chiffrement sym√©trique (avec mot de passe)
gpg --symmetric fichier.txt

# D√©chiffrer
gpg --decrypt fichier.txt.gpg > fichier.txt

# Signer un fichier
gpg --sign fichier.txt

# Chiffrer ET signer
gpg --encrypt --sign --recipient destinataire@exemple.com fichier.txt
```

#### Scripts d'automatisation GPG

```bash
#!/bin/bash
# /usr/local/bin/backup-encrypt.sh

SOURCE="/home/data"
BACKUP_DIR="/backup/encrypted"
RECIPIENT="backup@exemple.com"
DATE=$(date +%Y%m%d)

# Cr√©er l'archive
tar -czf /tmp/backup_$DATE.tar.gz $SOURCE

# Chiffrer l'archive
gpg --trust-model always --encrypt --recipient $RECIPIENT \
    --output $BACKUP_DIR/backup_$DATE.tar.gz.gpg \
    /tmp/backup_$DATE.tar.gz

# Nettoyer le fichier temporaire
rm /tmp/backup_$DATE.tar.gz

# V√©rifier l'int√©grit√©
if gpg --quiet --decrypt $BACKUP_DIR/backup_$DATE.tar.gz.gpg > /dev/null 2>&1; then
    echo "Sauvegarde chiffr√©e cr√©√©e avec succ√®s: backup_$DATE.tar.gz.gpg"
else
    echo "ERREUR: Impossible de v√©rifier la sauvegarde chiffr√©e"
    exit 1
fi
```

### Chiffrement de partitions avec LUKS

**LUKS** (Linux Unified Key Setup) permet de chiffrer des partitions compl√®tes de mani√®re transparente.

#### Chiffrement d'une partition existante

```bash
# ATTENTION: Cette op√©ration D√âTRUIT toutes les donn√©es

# Installer cryptsetup
sudo apt install cryptsetup

# Chiffrer une partition (exemple: /dev/sdb1)
sudo cryptsetup luksFormat /dev/sdb1

# Ouvrir la partition chiffr√©e
sudo cryptsetup luksOpen /dev/sdb1 encrypted_data

# Cr√©er un syst√®me de fichiers
sudo mkfs.ext4 /dev/mapper/encrypted_data

# Monter la partition
sudo mkdir /mnt/encrypted
sudo mount /dev/mapper/encrypted_data /mnt/encrypted
```

#### Configuration du montage automatique

```bash
# Ajouter au /etc/fstab
echo "/dev/mapper/encrypted_data /mnt/encrypted ext4 defaults 0 2" | sudo tee -a /etc/fstab

# Configuration dans /etc/crypttab
echo "encrypted_data /dev/sdb1 none luks" | sudo tee -a /etc/crypttab

# Mettre √† jour initramfs
sudo update-initramfs -u
```

#### Gestion des cl√©s LUKS

```bash
# Ajouter une cl√© (jusqu'√† 8 slots)
sudo cryptsetup luksAddKey /dev/sdb1

# Lister les slots utilis√©s
sudo cryptsetup luksDump /dev/sdb1

# Supprimer une cl√©
sudo cryptsetup luksRemoveKey /dev/sdb1

# Changer une cl√©
sudo cryptsetup luksChangeKey /dev/sdb1

# Sauvegarder l'en-t√™te LUKS (CRITIQUE !)
sudo cryptsetup luksHeaderBackup /dev/sdb1 --header-backup-file luks-header-sdb1.backup
```

### Chiffrement de fichiers individuels avec EncFS

**EncFS** cr√©√©e un syst√®me de fichiers chiffr√© au niveau fichier.

#### Installation et utilisation d'EncFS

```bash
# Installation
sudo apt install encfs

# Cr√©er un r√©pertoire chiffr√©
encfs ~/.encrypted ~/decrypted

# Le premier lancement configure le chiffrement
# Choisir le mode paranoia ou expert pour plus d'options

# Monter un r√©pertoire chiffr√© existant
encfs ~/.encrypted ~/decrypted

# D√©monter
fusermount -u ~/decrypted
```

#### Configuration avanc√©e EncFS

```bash
# Configuration personnalis√©e
encfs --standard ~/.encrypted ~/decrypted

# Options disponibles :
# - Algorithme de chiffrement (AES, Blowfish)
# - Taille de cl√© (128, 192, 256 bits)
# - Chiffrement des noms de fichiers
# - Taille de bloc

# Script de montage automatique
#!/bin/bash
# /usr/local/bin/mount-encrypted.sh

ENCRYPTED_DIR="$HOME/.encrypted"
MOUNT_POINT="$HOME/decrypted"

if mountpoint -q "$MOUNT_POINT"; then
    echo "R√©pertoire d√©j√† mont√©"
else
    encfs "$ENCRYPTED_DIR" "$MOUNT_POINT"
    echo "R√©pertoire chiffr√© mont√© dans $MOUNT_POINT"
fi
```

### Chiffrement r√©seau avec stunnel

**stunnel** permet d'ajouter une couche SSL/TLS √† des protocoles non chiffr√©s.

#### Installation et configuration de stunnel

```bash
# Installation
sudo apt install stunnel4

# Activer stunnel
sudo nano /etc/default/stunnel4
# ENABLED=1

# Configuration pour chiffrer POP3
sudo nano /etc/stunnel/pop3s.conf
```

```ini
[pop3s]
accept = 995
connect = 110
cert = /etc/ssl/certs/mail.pem
key = /etc/ssl/private/mail.key

[imaps]
accept = 993
connect = 143
cert = /etc/ssl/certs/mail.pem
key = /etc/ssl/private/mail.key
```

```bash
# D√©marrer stunnel
sudo systemctl start stunnel4
sudo systemctl enable stunnel4
```

### Chiffrement en transit avec SSL/TLS

#### G√©n√©ration de certificats SSL auto-sign√©s

```bash
# Certificat auto-sign√© pour tests
sudo openssl req -x509 -nodes -days 365 -newkey rsa:4096 \
    -keyout /etc/ssl/private/apache-selfsigned.key \
    -out /etc/ssl/certs/apache-selfsigned.crt

# Certificat avec Subject Alternative Names
sudo openssl req -x509 -nodes -days 365 -newkey rsa:4096 \
    -keyout /etc/ssl/private/multi-domain.key \
    -out /etc/ssl/certs/multi-domain.crt \
    -config <(
cat << EOF
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = FR
ST = Ile-de-France
L = Paris
O = Mon Entreprise
CN = exemple.com

[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = exemple.com
DNS.2 = www.exemple.com
DNS.3 = mail.exemple.com
IP.1 = 192.168.1.100
EOF
)
```

#### Configuration SSL/TLS s√©curis√©e

```bash
# Configuration Apache SSL s√©curis√©e
sudo nano /etc/apache2/sites-available/ssl.conf
```

```apache
<VirtualHost *:443>
    ServerName exemple.com
    DocumentRoot /var/www/html

    SSLEngine on
    SSLCertificateFile /etc/ssl/certs/apache-selfsigned.crt
    SSLCertificateKeyFile /etc/ssl/private/apache-selfsigned.key

    # Protocoles s√©curis√©s uniquement
    SSLProtocol -all +TLSv1.2 +TLSv1.3

    # Suites de chiffrement s√©curis√©es
    SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
    SSLHonorCipherOrder off

    # S√©curit√© suppl√©mentaire
    SSLCompression off
    SSLUseStapling on
    SSLStaplingCache "shmcb:logs/stapling-cache(150000)"

    # Headers de s√©curit√©
    Header always set Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"
    Header always set X-Frame-Options DENY
    Header always set X-Content-Type-Options nosniff
</VirtualHost>
```

### Audit et monitoring du chiffrement

#### Script d'audit SSL/TLS

```bash
#!/bin/bash
# /usr/local/bin/ssl-audit.sh

HOST=$1
PORT=${2:-443}

if [ -z "$HOST" ]; then
    echo "Usage: $0 <host> [port]"
    exit 1
fi

echo "=== Audit SSL/TLS pour $HOST:$PORT ==="
echo

# Test de connectivit√© SSL
echo "=== Connectivit√© SSL ==="
if openssl s_client -connect $HOST:$PORT -servername $HOST < /dev/null 2>/dev/null; then
    echo "‚úì Connexion SSL/TLS r√©ussie"
else
    echo "‚úó Impossible de se connecter en SSL/TLS"
    exit 1
fi

echo

# Information sur le certificat
echo "=== Informations certificat ==="
CERT_INFO=$(openssl s_client -connect $HOST:$PORT -servername $HOST 2>/dev/null | openssl x509 -noout -text 2>/dev/null)

if [ $? -eq 0 ]; then
    echo "√âmetteur: $(echo "$CERT_INFO" | grep "Issuer:" | cut -d: -f2-)"
    echo "Sujet: $(echo "$CERT_INFO" | grep "Subject:" | cut -d: -f2-)"
    echo "Validit√©: $(echo "$CERT_INFO" | grep -A 2 "Validity")"

    # V√©rifier l'expiration
    EXPIRY=$(openssl s_client -connect $HOST:$PORT -servername $HOST 2>/dev/null | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
    EXPIRY_EPOCH=$(date -d "$EXPIRY" +%s)
    CURRENT_EPOCH=$(date +%s)
    DAYS_LEFT=$(( (EXPIRY_EPOCH - CURRENT_EPOCH) / 86400 ))

    if [ $DAYS_LEFT -lt 30 ]; then
        echo "‚ö†Ô∏è  ATTENTION: Certificat expire dans $DAYS_LEFT jours"
    else
        echo "‚úì Certificat valide pour $DAYS_LEFT jours"
    fi
else
    echo "‚úó Impossible de r√©cup√©rer les informations du certificat"
fi

echo

# Test des protocoles
echo "=== Support des protocoles ==="
for protocol in ssl3 tls1 tls1_1 tls1_2 tls1_3; do
    if openssl s_client -connect $HOST:$PORT -$protocol < /dev/null 2>/dev/null | grep -q "Verify return code: 0"; then
        echo "‚úì $protocol support√©"
    else
        echo "‚úó $protocol non support√©"
    fi
done

echo
echo "=== Recommandations ==="
echo "- TLS 1.2 et 1.3 uniquement recommand√©s"
echo "- D√©sactiver SSL 3.0, TLS 1.0, et TLS 1.1"
echo "- Utiliser des suites de chiffrement s√©curis√©es"
```

#### Monitoring des certificats

```bash
#!/bin/bash
# /usr/local/bin/cert-monitor.sh

CONFIG_FILE="/etc/cert-monitor.conf"
ALERT_EMAIL="admin@exemple.com"
WARNING_DAYS=30

# Configuration des sites √† surveiller
if [ ! -f "$CONFIG_FILE" ]; then
    cat > "$CONFIG_FILE" << EOF
# Format: host:port:description
exemple.com:443:Site principal
mail.exemple.com:993:Serveur mail IMAPS
vpn.exemple.com:443:Serveur VPN
EOF
    echo "Configuration cr√©√©e dans $CONFIG_FILE"
    exit 0
fi

# Fonction de v√©rification
check_certificate() {
    local host=$1
    local port=$2
    local desc=$3

    local expiry=$(openssl s_client -connect $host:$port -servername $host 2>/dev/null | \
                   openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)

    if [ -n "$expiry" ]; then
        local expiry_epoch=$(date -d "$expiry" +%s)
        local current_epoch=$(date +%s)
        local days_left=$(( (expiry_epoch - current_epoch) / 86400 ))

        if [ $days_left -lt $WARNING_DAYS ]; then
            echo "ALERTE: $desc ($host:$port) expire dans $days_left jours"
            return 1
        else
            echo "OK: $desc ($host:$port) valide pour $days_left jours"
            return 0
        fi
    else
        echo "ERREUR: Impossible de v√©rifier $desc ($host:$port)"
        return 1
    fi
}

# V√©rification de tous les certificats
ALERTS=""
while IFS=':' read -r host port desc; do
    if [[ ! $host =~ ^#.*$ ]] && [ -n "$host" ]; then
        if ! check_certificate "$host" "$port" "$desc"; then
            ALERTS="$ALERTS\n$(check_certificate "$host" "$port" "$desc")"
        fi
    fi
done < "$CONFIG_FILE"

# Envoyer les alertes par email
if [ -n "$ALERTS" ]; then
    echo -e "Alertes de certificats:\n$ALERTS" | mail -s "Alerte certificats SSL/TLS" "$ALERT_EMAIL"
fi
```

# 5.4.4 Bonnes pratiques de chiffrement

### Bonnes pratiques de chiffrement

#### Recommandations g√©n√©rales

**Algorithmes recommand√©s :**
- **Chiffrement sym√©trique** : AES-256-GCM, ChaCha20-Poly1305
- **Chiffrement asym√©trique** : RSA-4096, ECDSA P-384, Ed25519
- **Hachage** : SHA-256, SHA-3, BLAKE2
- **Protocoles** : TLS 1.3, WireGuard, SSH-2

**√Ä √©viter :**
- MD5, SHA-1 (compromis)
- DES, 3DES (faibles)
- RC4 (vuln√©rable)
- SSL 3.0, TLS 1.0, TLS 1.1 (obsol√®tes)

#### Checklist de s√©curit√©

```bash
# Checklist de s√©curit√© cryptographique
1. ‚úì Utiliser des algorithmes modernes et s√©curis√©s
2. ‚úì Cl√©s de taille suffisante (RSA ‚â• 4096, AES ‚â• 256)
3. ‚úì Renouveler r√©guli√®rement les certificats
4. ‚úì Prot√©ger les cl√©s priv√©es (chmod 600, chiffrement)
5. ‚úì Utiliser des mots de passe forts pour les cl√©s
6. ‚úì Impl√©menter Perfect Forward Secrecy (PFS)
7. ‚úì Auditer r√©guli√®rement les configurations
8. ‚úì Maintenir une documentation des certificats
9. ‚úì Avoir un plan de r√©vocation d'urgence
10. ‚úì Sauvegarder les cl√©s et certificats de mani√®re s√©curis√©e
```

#### Script d'audit cryptographique complet

```bash
#!/bin/bash
# /usr/local/bin/crypto-audit.sh

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

REPORT_FILE="/tmp/crypto-audit-$(date +%Y%m%d-%H%M%S).txt"

echo "=== AUDIT CRYPTOGRAPHIQUE SYST√àME ===" | tee $REPORT_FILE
echo "Date: $(date)" | tee -a $REPORT_FILE
echo "Syst√®me: $(uname -a)" | tee -a $REPORT_FILE
echo | tee -a $REPORT_FILE

# Fonction d'√©valuation
evaluate() {
    local test_name="$1"
    local result="$2"
    local recommendation="$3"

    if [ "$result" = "PASS" ]; then
        echo -e "${GREEN}‚úì${NC} $test_name" | tee -a $REPORT_FILE
    elif [ "$result" = "WARN" ]; then
        echo -e "${YELLOW}‚ö†${NC} $test_name" | tee -a $REPORT_FILE
        echo "  Recommandation: $recommendation" | tee -a $REPORT_FILE
    else
        echo -e "${RED}‚úó${NC} $test_name" | tee -a $REPORT_FILE
        echo "  Recommandation: $recommendation" | tee -a $REPORT_FILE
    fi
}

# Audit SSH
echo "=== AUDIT SSH ===" | tee -a $REPORT_FILE
SSH_CONFIG="/etc/ssh/sshd_config"

if [ -f "$SSH_CONFIG" ]; then
    # V√©rifier la version du protocole
    if grep -q "^Protocol 2" $SSH_CONFIG; then
        evaluate "SSH Protocol 2" "PASS"
    else
        evaluate "SSH Protocol 2" "FAIL" "Ajouter 'Protocol 2' dans $SSH_CONFIG"
    fi

    # V√©rifier les algorithmes de chiffrement
    if grep -q "Ciphers.*aes.*gcm\|chacha20" $SSH_CONFIG; then
        evaluate "Algorithmes de chiffrement SSH s√©curis√©s" "PASS"
    else
        evaluate "Algorithmes de chiffrement SSH" "WARN" "Configurer des algorithmes modernes (AES-GCM, ChaCha20)"
    fi

    # V√©rifier les algorithmes MAC
    if grep -q "MACs.*sha2" $SSH_CONFIG; then
        evaluate "Algorithmes MAC SSH s√©curis√©s" "PASS"
    else
        evaluate "Algorithmes MAC SSH" "WARN" "Configurer SHA-2 pour les MACs"
    fi

    # V√©rifier les algorithmes d'√©change de cl√©s
    if grep -q "KexAlgorithms.*curve25519\|ecdh-sha2" $SSH_CONFIG; then
        evaluate "√âchange de cl√©s SSH s√©curis√©" "PASS"
    else
        evaluate "√âchange de cl√©s SSH" "WARN" "Utiliser Curve25519 ou ECDH-SHA2"
    fi
else
    evaluate "Configuration SSH" "FAIL" "SSH non configur√©"
fi

echo | tee -a $REPORT_FILE

# Audit des certificats SSL/TLS
echo "=== AUDIT CERTIFICATS SSL/TLS ===" | tee -a $REPORT_FILE

# V√©rifier Apache
if [ -d "/etc/apache2/sites-enabled" ]; then
    for site in /etc/apache2/sites-enabled/*; do
        if grep -q "SSLEngine on" "$site" 2>/dev/null; then
            site_name=$(basename "$site")
            echo "Site Apache: $site_name" | tee -a $REPORT_FILE

            # V√©rifier les protocoles SSL
            if grep -q "SSLProtocol.*TLSv1\.[23]" "$site"; then
                evaluate "  Protocoles TLS s√©curis√©s" "PASS"
            else
                evaluate "  Protocoles TLS" "FAIL" "Utiliser uniquement TLS 1.2 et 1.3"
            fi

            # V√©rifier les suites de chiffrement
            if grep -q "SSLCipherSuite.*ECDHE.*GCM" "$site"; then
                evaluate "  Suites de chiffrement s√©curis√©es" "PASS"
            else
                evaluate "  Suites de chiffrement" "WARN" "Utiliser des suites ECDHE avec GCM"
            fi
        fi
    done
fi

# V√©rifier Nginx
if [ -d "/etc/nginx/sites-enabled" ]; then
    for site in /etc/nginx/sites-enabled/*; do
        if grep -q "ssl_certificate" "$site" 2>/dev/null; then
            site_name=$(basename "$site")
            echo "Site Nginx: $site_name" | tee -a $REPORT_FILE

            # V√©rifier les protocoles SSL
            if grep -q "ssl_protocols.*TLSv1\.[23]" "$site"; then
                evaluate "  Protocoles TLS s√©curis√©s" "PASS"
            else
                evaluate "  Protocoles TLS" "FAIL" "Configurer ssl_protocols TLSv1.2 TLSv1.3"
            fi
        fi
    done
fi

echo | tee -a $REPORT_FILE

# Audit OpenVPN
echo "=== AUDIT OPENVPN ===" | tee -a $REPORT_FILE

if [ -d "/etc/openvpn" ]; then
    for config in /etc/openvpn/server/*.conf /etc/openvpn/*.conf; do
        if [ -f "$config" ]; then
            config_name=$(basename "$config")
            echo "Configuration OpenVPN: $config_name" | tee -a $REPORT_FILE

            # V√©rifier le chiffrement
            if grep -q "cipher AES-256-GCM\|cipher AES-256-CBC" "$config"; then
                evaluate "  Chiffrement OpenVPN" "PASS"
            else
                evaluate "  Chiffrement OpenVPN" "WARN" "Utiliser AES-256-GCM ou AES-256-CBC"
            fi

            # V√©rifier l'authentification
            if grep -q "auth SHA256\|auth SHA512" "$config"; then
                evaluate "  Authentification OpenVPN" "PASS"
            else
                evaluate "  Authentification OpenVPN" "WARN" "Utiliser SHA-256 ou SHA-512"
            fi

            # V√©rifier TLS-auth
            if grep -q "tls-auth\|tls-crypt" "$config"; then
                evaluate "  Protection TLS OpenVPN" "PASS"
            else
                evaluate "  Protection TLS OpenVPN" "WARN" "Activer tls-auth ou tls-crypt"
            fi
        fi
    done
else
    echo "OpenVPN non install√©" | tee -a $REPORT_FILE
fi

echo | tee -a $REPORT_FILE

# Audit WireGuard
echo "=== AUDIT WIREGUARD ===" | tee -a $REPORT_FILE

if [ -d "/etc/wireguard" ]; then
    for config in /etc/wireguard/*.conf; do
        if [ -f "$config" ]; then
            config_name=$(basename "$config")
            echo "Configuration WireGuard: $config_name" | tee -a $REPORT_FILE

            # V√©rifier les permissions
            if [ "$(stat -c %a "$config")" = "600" ]; then
                evaluate "  Permissions configuration" "PASS"
            else
                evaluate "  Permissions configuration" "FAIL" "chmod 600 $config"
            fi

            # WireGuard utilise toujours des algorithmes s√©curis√©s
            evaluate "  Cryptographie WireGuard" "PASS"
        fi
    done
else
    echo "WireGuard non install√©" | tee -a $REPORT_FILE
fi

echo | tee -a $REPORT_FILE

# Audit du syst√®me de fichiers chiffr√©
echo "=== AUDIT CHIFFREMENT DISQUES ===" | tee -a $REPORT_FILE

# V√©rifier LUKS
if command -v cryptsetup >/dev/null 2>&1; then
    luks_devices=$(lsblk -f | grep crypto_LUKS | wc -l)
    if [ $luks_devices -gt 0 ]; then
        evaluate "Partitions LUKS d√©tect√©es ($luks_devices)" "PASS"

        # D√©tails des devices LUKS
        lsblk -f | grep crypto_LUKS | while read line; do
            device=$(echo $line | awk '{print $1}')
            echo "  Device LUKS: /dev/$device" | tee -a $REPORT_FILE
        done
    else
        evaluate "Chiffrement de disque" "WARN" "Consid√©rer le chiffrement des partitions sensibles avec LUKS"
    fi
else
    evaluate "Outils de chiffrement de disque" "WARN" "Installer cryptsetup pour LUKS"
fi

echo | tee -a $REPORT_FILE

# Audit des outils cryptographiques
echo "=== AUDIT OUTILS CRYPTOGRAPHIQUES ===" | tee -a $REPORT_FILE

# V√©rifier OpenSSL
if command -v openssl >/dev/null 2>&1; then
    openssl_version=$(openssl version | awk '{print $2}')
    evaluate "OpenSSL install√© (version $openssl_version)" "PASS"

    # V√©rifier si c'est une version r√©cente
    if openssl version | grep -q "1\.[1-9]\.\|[2-9]\.\|3\."; then
        evaluate "Version OpenSSL r√©cente" "PASS"
    else
        evaluate "Version OpenSSL" "WARN" "Mettre √† jour OpenSSL vers une version r√©cente"
    fi
else
    evaluate "OpenSSL" "FAIL" "Installer OpenSSL"
fi

# V√©rifier GPG
if command -v gpg >/dev/null 2>&1; then
    gpg_version=$(gpg --version | head -1 | awk '{print $3}')
    evaluate "GnuPG install√© (version $gpg_version)" "PASS"
else
    evaluate "GnuPG" "WARN" "Installer GnuPG pour le chiffrement de fichiers"
fi

echo | tee -a $REPORT_FILE

# Audit des permissions de fichiers sensibles
echo "=== AUDIT PERMISSIONS FICHIERS ===" | tee -a $REPORT_FILE

# V√©rifier les cl√©s SSH
if [ -d "/etc/ssh" ]; then
    for key_file in /etc/ssh/ssh_host_*_key; do
        if [ -f "$key_file" ]; then
            perms=$(stat -c %a "$key_file")
            if [ "$perms" = "600" ]; then
                evaluate "Permissions $(basename $key_file)" "PASS"
            else
                evaluate "Permissions $(basename $key_file)" "FAIL" "chmod 600 $key_file"
            fi
        fi
    done
fi

# V√©rifier les cl√©s utilisateur
for user_home in /home/*; do
    if [ -d "$user_home/.ssh" ]; then
        username=$(basename "$user_home")
        for key_file in "$user_home/.ssh/id_"*; do
            if [ -f "$key_file" ] && [[ ! "$key_file" == *.pub ]]; then
                perms=$(stat -c %a "$key_file")
                if [ "$perms" = "600" ]; then
                    evaluate "Permissions cl√© priv√©e $username" "PASS"
                else
                    evaluate "Permissions cl√© priv√©e $username" "FAIL" "chmod 600 $key_file"
                fi
            fi
        done
    fi
done

echo | tee -a $REPORT_FILE

# R√©sum√© des recommandations
echo "=== R√âSUM√â DES RECOMMANDATIONS ===" | tee -a $REPORT_FILE

cat >> $REPORT_FILE << 'EOF'

PRIORIT√â HAUTE:
1. Mettre √† jour tous les protocoles obsol√®tes (SSL 3.0, TLS 1.0/1.1)
2. Corriger les permissions des cl√©s priv√©es (chmod 600)
3. Impl√©menter le chiffrement des disques pour les donn√©es sensibles

PRIORIT√â MOYENNE:
1. Configurer des algorithmes de chiffrement modernes
2. Mettre en place une rotation r√©guli√®re des certificats
3. Auditer r√©guli√®rement les configurations cryptographiques

PRIORIT√â BASSE:
1. Documentation des certificats et cl√©s
2. Mise en place de monitoring automatis√©
3. Formation des utilisateurs aux bonnes pratiques

EOF

echo "Rapport d'audit sauvegard√© dans: $REPORT_FILE" | tee -a $REPORT_FILE
```

### Gestion des secrets et mots de passe

#### Utilisation de gestionnaires de mots de passe

**Installation de pass (Password Store) :**
```bash
# Installation
sudo apt install pass

# Initialiser avec une cl√© GPG
pass init "votre@email.com"

# Ajouter un mot de passe
pass insert Email/gmail
pass insert Servers/production-db

# G√©n√©rer un mot de passe al√©atoirement
pass generate Social/twitter 20

# R√©cup√©rer un mot de passe
pass Email/gmail

# Lister tous les mots de passe
pass

# Synchronisation Git (optionnel)
pass git init
pass git remote add origin git@github.com:user/password-store.git
```

#### Int√©gration avec HashiCorp Vault

```bash
# Installation de Vault (mode d√©veloppement)
wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update && sudo apt install vault

# D√©marrer Vault en mode dev (uniquement pour tests)
vault server -dev

# Dans un autre terminal, configurer l'environnement
export VAULT_ADDR='http://127.0.0.1:8200'
export VAULT_TOKEN='[token affich√© au d√©marrage]'

# Stocker un secret
vault kv put secret/db username=admin password=motdepasse_complexe

# R√©cup√©rer un secret
vault kv get secret/db

# R√©cup√©rer seulement le mot de passe
vault kv get -field=password secret/db
```

#### Script de gestion s√©curis√©e des mots de passe

```bash
#!/bin/bash
# /usr/local/bin/secure-password-manager.sh

PASS_LENGTH=32
PASS_STORE="$HOME/.local/share/passwords"
GPG_RECIPIENT="admin@exemple.com"

# Cr√©er le r√©pertoire s'il n'existe pas
mkdir -p "$PASS_STORE"

generate_password() {
    local name="$1"
    local length="${2:-$PASS_LENGTH}"

    if [ -z "$name" ]; then
        echo "Usage: generate_password <name> [length]"
        return 1
    fi

    # G√©n√©rer le mot de passe
    local password=$(openssl rand -base64 $((length * 3 / 4)) | tr -d "=+/" | cut -c1-$length)

    # Chiffrer et stocker
    echo "$password" | gpg --trust-model always -r "$GPG_RECIPIENT" --encrypt --armor > "$PASS_STORE/$name.gpg"

    echo "Mot de passe g√©n√©r√© et stock√© pour: $name"
    echo "Mot de passe: $password"
}

retrieve_password() {
    local name="$1"

    if [ -z "$name" ]; then
        echo "Usage: retrieve_password <name>"
        return 1
    fi

    if [ -f "$PASS_STORE/$name.gpg" ]; then
        gpg --quiet --decrypt "$PASS_STORE/$name.gpg"
    else
        echo "Mot de passe non trouv√©: $name"
        return 1
    fi
}

list_passwords() {
    echo "Mots de passe stock√©s:"
    for file in "$PASS_STORE"/*.gpg; do
        if [ -f "$file" ]; then
            basename "$file" .gpg
        fi
    done
}

case "$1" in
    generate)
        generate_password "$2" "$3"
        ;;
    get)
        retrieve_password "$2"
        ;;
    list)
        list_passwords
        ;;
    *)
        echo "Usage: $0 {generate|get|list} [name] [length]"
        echo "Exemples:"
        echo "  $0 generate db-prod 16"
        echo "  $0 get db-prod"
        echo "  $0 list"
        ;;
esac
```

### Automatisation et orchestration de la s√©curit√©

#### Script de d√©ploiement s√©curis√© complet

```bash
#!/bin/bash
# /usr/local/bin/deploy-secure-infrastructure.sh

set -euo pipefail

# Variables de configuration
DOMAIN="${1:-exemple.com}"
ADMIN_EMAIL="${2:-admin@$DOMAIN}"
VPN_TYPE="${3:-wireguard}"  # wireguard ou openvpn

echo "=== D√âPLOIEMENT INFRASTRUCTURE S√âCURIS√âE ==="
echo "Domaine: $DOMAIN"
echo "Email admin: $ADMIN_EMAIL"
echo "Type VPN: $VPN_TYPE"
echo

# Fonction de log
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Mise √† jour du syst√®me
log "Mise √† jour du syst√®me..."
apt update && apt upgrade -y

# Installation des outils de base
log "Installation des outils cryptographiques..."
apt install -y \
    openssl \
    gnupg \
    cryptsetup \
    fail2ban \
    ufw \
    certbot \
    wireguard \
    openvpn \
    easy-rsa \
    stunnel4

# Configuration du pare-feu de base
log "Configuration du pare-feu..."
ufw default deny incoming
ufw default allow outgoing
ufw allow ssh
ufw allow http
ufw allow https
ufw --force enable

# Configuration SSH s√©curis√©e
log "S√©curisation SSH..."
cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup

cat > /etc/ssh/sshd_config << EOF
Port 2222
Protocol 2
HostKey /etc/ssh/ssh_host_ed25519_key
HostKey /etc/ssh/ssh_host_rsa_key

KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group16-sha512
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes256-ctr
MACs hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com

PermitRootLogin no
MaxAuthTries 2
MaxSessions 4
LoginGraceTime 60
PubkeyAuthentication yes
PasswordAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no

UseDNS no
X11Forwarding no
AllowTcpForwarding no
GatewayPorts no
PermitTunnel no

ClientAliveInterval 300
ClientAliveCountMax 2

LogLevel VERBOSE
SyslogFacility AUTH
EOF

# Mettre √† jour le pare-feu pour SSH
ufw delete allow ssh
ufw allow 2222/tcp

# Red√©marrer SSH
systemctl restart ssh

# Configuration fail2ban
log "Configuration fail2ban..."
cat > /etc/fail2ban/jail.local << EOF
[DEFAULT]
bantime = 86400
findtime = 600
maxretry = 3
ignoreip = 127.0.0.1/8 ::1

[sshd]
enabled = true
port = 2222
filter = sshd
logpath = /var/log/auth.log
maxretry = 2
bantime = 86400
EOF

systemctl restart fail2ban

# Configuration du VPN
if [ "$VPN_TYPE" = "wireguard" ]; then
    log "Configuration WireGuard..."

    # G√©n√©rer les cl√©s
    wg genkey | tee /etc/wireguard/server_private.key | wg pubkey > /etc/wireguard/server_public.key
    chmod 600 /etc/wireguard/server_private.key

    # Configuration serveur
    cat > /etc/wireguard/wg0.conf << EOF
[Interface]
PrivateKey = $(cat /etc/wireguard/server_private.key)
Address = 10.13.13.1/24
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
EOF

    chmod 600 /etc/wireguard/wg0.conf

    # Activer le forwarding IP
    echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
    sysctl -p

    # Autoriser le port WireGuard
    ufw allow 51820/udp

    # D√©marrer WireGuard
    systemctl enable wg-quick@wg0
    systemctl start wg-quick@wg0

    log "WireGuard configur√©. Cl√© publique serveur:"
    cat /etc/wireguard/server_public.key

elif [ "$VPN_TYPE" = "openvpn" ]; then
    log "Configuration OpenVPN..."

    # Configuration Easy-RSA
    mkdir -p /etc/openvpn/easy-rsa
    cp -r /usr/share/easy-rsa/* /etc/openvpn/easy-rsa/
    cd /etc/openvpn/easy-rsa

    # Variables Easy-RSA
    cat > vars << EOF
set_var EASYRSA_REQ_COUNTRY "FR"
set_var EASYRSA_REQ_PROVINCE "France"
set_var EASYRSA_REQ_CITY "Paris"
set_var EASYRSA_REQ_ORG "$DOMAIN"
set_var EASYRSA_REQ_EMAIL "$ADMIN_EMAIL"
set_var EASYRSA_REQ_OU "IT"
set_var EASYRSA_KEY_SIZE 4096
set_var EASYRSA_CA_EXPIRE 7300
set_var EASYRSA_CERT_EXPIRE 3650
EOF

    # Initialiser la PKI
    ./easyrsa init-pki
    ./easyrsa build-ca nopass
    ./easyrsa gen-req server nopass
    ./easyrsa sign-req server server
    ./easyrsa gen-dh
    openvpn --genkey --secret pki/ta.key

    # Configuration serveur OpenVPN
    cat > /etc/openvpn/server/server.conf << EOF
port 1194
proto udp
dev tun

ca /etc/openvpn/easy-rsa/pki/ca.crt
cert /etc/openvpn/easy-rsa/pki/issued/server.crt
key /etc/openvpn/easy-rsa/pki/private/server.key
dh /etc/openvpn/easy-rsa/pki/dh.pem

server 10.8.0.0 255.255.255.0
ifconfig-pool-persist /var/log/openvpn/ipp.txt

push "redirect-gateway def1 bypass-dhcp"
push "dhcp-option DNS 8.8.8.8"
push "dhcp-option DNS 8.8.4.4"

tls-auth /etc/openvpn/easy-rsa/pki/ta.key 0
cipher AES-256-GCM
auth SHA256
tls-version-min 1.2

keepalive 10 120
user nobody
group nogroup
persist-key
persist-tun

status /var/log/openvpn/openvpn-status.log
log-append /var/log/openvpn/openvpn.log
verb 3
EOF

    # Autoriser le port OpenVPN
    ufw allow 1194/udp

    # D√©marrer OpenVPN
    systemctl enable openvpn-server@server
    systemctl start openvpn-server@server
fi

# Obtenir un certificat SSL avec Let's Encrypt
log "Configuration SSL avec Let's Encrypt..."
if command -v nginx >/dev/null 2>&1; then
    certbot --nginx -d "$DOMAIN" --email "$ADMIN_EMAIL" --agree-tos --non-interactive
elif command -v apache2 >/dev/null 2>&1; then
    certbot --apache -d "$DOMAIN" --email "$ADMIN_EMAIL" --agree-tos --non-interactive
else
    certbot certonly --standalone -d "$DOMAIN" --email "$ADMIN_EMAIL" --agree-tos --non-interactive
fi

# Configuration du renouvellement automatique
cat > /etc/cron.d/certbot << EOF
0 12 * * * root test -x /usr/bin/certbot -a \! -d /run/systemd/system && perl -e 'sleep int(rand(43200))' && certbot -q renew --renew-hook "systemctl reload nginx"
EOF

# G√©n√©ration d'un rapport de s√©curit√©
log "G√©n√©ration du rapport de s√©curit√©..."
cat > /root/security-report.txt << EOF
=== RAPPORT DE S√âCURIT√â ===
Date de d√©ploiement: $(date)
Domaine: $DOMAIN
Email admin: $ADMIN_EMAIL

SERVICES CONFIGUR√âS:
- SSH s√©curis√© (port 2222)
- Pare-feu UFW activ√©
- Fail2ban configur√©
- VPN $VPN_TYPE configur√©
- Certificat SSL Let's Encrypt

PROCHAINES √âTAPES:
1. Configurer les cl√©s SSH pour l'authentification
2. Cr√©er des clients VPN
3. Configurer la surveillance (monitoring)
4. Programmer les sauvegardes chiffr√©es
5. Tester la configuration de s√©curit√©

COMMANDES UTILES:
- √âtat des services: systemctl status ssh fail2ban ufw
- Logs SSH: journalctl -u ssh -f
- √âtat VPN: $([ "$VPN_TYPE" = "wireguard" ] && echo "wg show" || echo "systemctl status openvpn-server@server")
- Test SSL: openssl s_client -connect $DOMAIN:443
EOF

log "D√©ploiement termin√©!"
echo
echo "=== INFORMATIONS IMPORTANTES ==="
echo "1. SSH est maintenant sur le port 2222"
echo "2. Configurez vos cl√©s SSH avant de fermer cette session"
echo "3. Rapport de s√©curit√© disponible dans /root/security-report.txt"
echo "4. Testez toutes les connexions avant de fermer cette session"
echo
echo "Commande de test SSH: ssh -p 2222 user@$DOMAIN"
```

### Conformit√© et audit r√©glementaire

#### Pr√©paration √† la conformit√© RGPD

```bash
#!/bin/bash
# /usr/local/bin/gdpr-crypto-compliance.sh

COMPLIANCE_DIR="/var/log/compliance"
mkdir -p $COMPLIANCE_DIR

echo "=== AUDIT CONFORMIT√â RGPD - CHIFFREMENT ===" | tee $COMPLIANCE_DIR/gdpr-crypto-audit.log
echo "Date: $(date)" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
echo

# Article 32 RGPD - S√©curit√© des traitements
check_encryption_at_rest() {
    echo "=== CHIFFREMENT AU REPOS ===" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

    # V√©rifier LUKS
    luks_count=$(lsblk -f | grep crypto_LUKS | wc -l)
    if [ $luks_count -gt 0 ]; then
        echo "‚úì Partitions chiffr√©es d√©tect√©es: $luks_count" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        echo "  Conformit√© Article 32(1)(a) - Pseudonymisation et chiffrement" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    else
        echo "‚ö† Aucune partition chiffr√©e d√©tect√©e" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        echo "  Recommandation: Impl√©menter le chiffrement des donn√©es personnelles" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi

    # V√©rifier EncFS ou autres syst√®mes de fichiers chiffr√©s
    if command -v encfs >/dev/null; then
        echo "‚úì EncFS disponible pour chiffrement de fichiers" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi

    # V√©rifier les sauvegardes chiffr√©es
    if [ -d "/backup" ]; then
        encrypted_backups=$(find /backup -name "*.gpg" -o -name "*.enc" 2>/dev/null | wc -l)
        if [ $encrypted_backups -gt 0 ]; then
            echo "‚úì Sauvegardes chiffr√©es d√©tect√©es: $encrypted_backups" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        else
            echo "‚ö† Aucune sauvegarde chiffr√©e d√©tect√©e" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        fi
    fi
}

check_encryption_in_transit() {
    echo "=== CHIFFREMENT EN TRANSIT ===" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

    # V√©rifier SSL/TLS sur les services web
    if netstat -tlnp | grep -q ":443"; then
        echo "‚úì HTTPS activ√© (port 443)" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        echo "  Conformit√© Article 32(1)(a) - Protection en transit" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    else
        echo "‚ö† HTTPS non d√©tect√©" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi

    # V√©rifier SSH
    if systemctl is-active ssh | grep -q active; then
        echo "‚úì SSH s√©curis√© activ√©" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi

    # V√©rifier VPN
    if systemctl is-active wg-quick@wg0 | grep -q active; then
        echo "‚úì VPN WireGuard actif" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    elif systemctl is-active openvpn-server@server | grep -q active; then
        echo "‚úì VPN OpenVPN actif" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi
}

check_access_controls() {
    echo "=== CONTR√îLES D'ACC√àS ===" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

    # Article 32(1)(b) - Garantir la confidentialit√©, int√©grit√©, disponibilit√©

    # V√©rifier fail2ban
    if systemctl is-active fail2ban | grep -q active; then
        echo "‚úì Protection contre les intrusions active (fail2ban)" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        echo "  Conformit√© Article 32(1)(b) - Confidentialit√© des traitements" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

        # Statistiques fail2ban
        banned_ips=$(fail2ban-client status | grep "Banned IP" | wc -l)
        echo "  IPs actuellement bannies: $banned_ips" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    else
        echo "‚ö† Fail2ban non actif" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi

    # V√©rifier le pare-feu
    if ufw status | grep -q "Status: active"; then
        echo "‚úì Pare-feu activ√© (UFW)" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        echo "  Conformit√© Article 32(1)(b) - Protection p√©rim√©trique" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    else
        echo "‚ö† Pare-feu non actif" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi
}

check_data_integrity() {
    echo "=== INT√âGRIT√â DES DONN√âES ===" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

    # Article 32(1)(b) - Int√©grit√© des donn√©es

    # V√©rifier les checksums/hachages
    if command -v sha256sum >/dev/null; then
        echo "‚úì Outils de v√©rification d'int√©grit√© disponibles" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        echo "  Conformit√© Article 32(1)(b) - Int√©grit√© des donn√©es" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi

    # V√©rifier la signature GPG
    if command -v gpg >/dev/null; then
        echo "‚úì Signature num√©rique disponible (GPG)" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        echo "  Conformit√© Article 32(1)(b) - Authentification et int√©grit√©" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi
}

check_incident_response() {
    echo "=== CAPACIT√â DE D√âTECTION D'INCIDENTS ===" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

    # Article 32(1)(c) - Capacit√© de r√©tablir la disponibilit√©

    # V√©rifier la journalisation de s√©curit√©
    if [ -f "/var/log/auth.log" ]; then
        recent_events=$(grep "$(date '+%b %d')" /var/log/auth.log | wc -l)
        echo "‚úì Journalisation de s√©curit√© active ($recent_events √©v√©nements aujourd'hui)" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
        echo "  Conformit√© Article 33 - D√©tection de violations" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi

    # V√©rifier les logs fail2ban
    if [ -f "/var/log/fail2ban.log" ]; then
        recent_bans=$(grep "$(date '+%Y-%m-%d')" /var/log/fail2ban.log | grep "Ban " | wc -l)
        echo "‚úì D√©tection d'intrusions ($recent_bans blocages aujourd'hui)" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log
    fi
}

generate_compliance_report() {
    echo "=== RAPPORT DE CONFORMIT√â RGPD ===" | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

    cat >> $COMPLIANCE_DIR/gdpr-crypto-audit.log << 'EOF'

R√âSUM√â DE CONFORMIT√â:

Article 32(1)(a) - Pseudonymisation et chiffrement des donn√©es personnelles:
- Chiffrement au repos: V√©rification des partitions LUKS
- Chiffrement en transit: V√©rification HTTPS, SSH, VPN
- Pseudonymisation: √Ä impl√©menter selon les besoins m√©tier

Article 32(1)(b) - Confidentialit√©, int√©grit√©, disponibilit√© et r√©silience permanentes:
- Contr√¥les d'acc√®s: Pare-feu, fail2ban, authentification forte
- Int√©grit√©: Outils de hachage, signatures num√©riques
- Disponibilit√©: Sauvegardes, redondance (√† v√©rifier)

Article 32(1)(c) - Capacit√© de r√©tablir la disponibilit√© et l'acc√®s aux donn√©es:
- Sauvegardes chiffr√©es: √Ä v√©rifier et impl√©menter
- Plans de reprise: √Ä documenter
- Tests de restauration: √Ä programmer

Article 32(1)(d) - Proc√©dure de v√©rification, d'√©valuation et d'appr√©ciation:
- Audit r√©gulier: Ce script √† ex√©cuter mensuellement
- Tests de p√©n√©tration: √Ä programmer annuellement
- Revue des configurations: √Ä programmer trimestriellement

ACTIONS RECOMMAND√âES:
1. Impl√©menter le chiffrement des partitions contenant des donn√©es personnelles
2. Mettre en place des sauvegardes chiffr√©es automatis√©es
3. Documenter les proc√©dures de gestion des incidents
4. Former les √©quipes aux bonnes pratiques RGPD
5. Programmer des audits r√©guliers

EOF
}

# Ex√©cution des v√©rifications
check_encryption_at_rest
echo | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

check_encryption_in_transit
echo | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

check_access_controls
echo | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

check_data_integrity
echo | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

check_incident_response
echo | tee -a $COMPLIANCE_DIR/gdpr-crypto-audit.log

generate_compliance_report

echo "Rapport de conformit√© RGPD g√©n√©r√© dans: $COMPLIANCE_DIR/gdpr-crypto-audit.log"
```

#### Standards de s√©curit√© industriels

**Conformit√© ISO 27001 :**
```bash
#!/bin/bash
# /usr/local/bin/iso27001-crypto-audit.sh

echo "=== AUDIT ISO 27001 - CONTR√îLES CRYPTOGRAPHIQUES ==="
echo "Date: $(date)"
echo

# A.10.1.1 - Politique d'utilisation des contr√¥les cryptographiques
check_crypto_policy() {
    echo "=== A.10.1.1 - POLITIQUE CRYPTOGRAPHIQUE ==="

    if [ -f "/etc/security/crypto-policy.txt" ]; then
        echo "‚úì Politique cryptographique document√©e"
    else
        echo "‚ö† Cr√©er une politique cryptographique document√©e"

        # Cr√©er un mod√®le de politique
        cat > /etc/security/crypto-policy.txt << 'EOF'
POLITIQUE DE S√âCURIT√â CRYPTOGRAPHIQUE

1. ALGORITHMES APPROUV√âS:
   - Chiffrement sym√©trique: AES-256-GCM, ChaCha20-Poly1305
   - Chiffrement asym√©trique: RSA-4096, ECDSA P-384, Ed25519
   - Hachage: SHA-256, SHA-3, BLAKE2
   - Signatures: RSA-PSS, ECDSA, Ed25519

2. ALGORITHMES INTERDITS:
   - MD5, SHA-1 (compromis)
   - DES, 3DES (faibles)
   - RC4 (vuln√©rable)

3. GESTION DES CL√âS:
   - Taille minimale: RSA 4096 bits, AES 256 bits
   - Rotation: Certificats max 2 ans, cl√©s sym√©triques max 1 an
   - Stockage: Cl√©s priv√©es chiffr√©es, permissions 600

4. PROTOCOLES:
   - TLS 1.3 recommand√©, TLS 1.2 minimum
   - SSH-2 uniquement
   - IPSec ou WireGuard pour VPN

5. R√âVISION:
   - R√©vision annuelle de la politique
   - Audit trimestriel des impl√©mentations
EOF
        echo "‚úì Mod√®le de politique cr√©√© dans /etc/security/crypto-policy.txt"
    fi
}

# A.10.1.2 - Gestion des cl√©s
check_key_management() {
    echo "=== A.10.1.2 - GESTION DES CL√âS ==="

    # V√©rifier la protection des cl√©s SSH
    weak_keys=0
    for key in /etc/ssh/ssh_host_*_key /home/*/.ssh/id_*; do
        if [ -f "$key" ] && [[ ! "$key" == *.pub ]]; then
            perms=$(stat -c %a "$key" 2>/dev/null)
            if [ "$perms" != "600" ]; then
                echo "‚ö† Permissions incorrectes: $key ($perms)"
                weak_keys=$((weak_keys + 1))
            fi
        fi
    done

    if [ $weak_keys -eq 0 ]; then
        echo "‚úì Permissions des cl√©s priv√©es correctes"
    else
        echo "‚ö† $weak_keys cl√©s avec permissions incorrectes"
    fi

    # V√©rifier la rotation des certificats
    expired_soon=0
    for cert in /etc/ssl/certs/*.crt /etc/openvpn/easy-rsa/pki/issued/*.crt; do
        if [ -f "$cert" ]; then
            if openssl x509 -checkend 2592000 -noout -in "$cert" 2>/dev/null; then
                continue
            else
                expired_soon=$((expired_soon + 1))
            fi
        fi
    done

    if [ $expired_soon -eq 0 ]; then
        echo "‚úì Tous les certificats sont valides pour plus de 30 jours"
    else
        echo "‚ö† $expired_soon certificats expirent dans moins de 30 jours"
    fi
}

check_crypto_policy
echo
check_key_management
```

### Documentation et proc√©dures

#### Template de documentation cryptographique

```bash
#!/bin/bash
# /usr/local/bin/generate-crypto-documentation.sh

DOC_DIR="/usr/share/doc/crypto-infrastructure"
mkdir -p "$DOC_DIR"

# G√©n√©ration de la documentation technique
cat > "$DOC_DIR/README.md" << 'EOF'
# Infrastructure Cryptographique

## Vue d'ensemble

Cette documentation d√©crit l'infrastructure cryptographique mise en place sur ce syst√®me pour assurer la s√©curit√© des donn√©es et des communications.

## Composants principaux

### 1. SSH (Secure Shell)
- **Port**: 2222 (modifi√© depuis 22 par d√©faut)
- **Protocole**: SSH-2 uniquement
- **Authentification**: Cl√©s publiques uniquement
- **Algorithmes**:
  - √âchange de cl√©s: Curve25519, ECDH-SHA2
  - Chiffrement: ChaCha20-Poly1305, AES-256-GCM
  - MAC: HMAC-SHA2-256-ETM, HMAC-SHA2-512-ETM

### 2. VPN (Virtual Private Network)
- **Type**: WireGuard / OpenVPN
- **Port**: 51820 (WireGuard) / 1194 (OpenVPN)
- **Chiffrement**: ChaCha20-Poly1305 / AES-256-GCM
- **Authentification**: Cl√©s publiques / certificats X.509

### 3. SSL/TLS
- **Protocoles**: TLS 1.3, TLS 1.2
- **Certificats**: Let's Encrypt / auto-sign√©s
- **Suites de chiffrement**: ECDHE-RSA-AES256-GCM-SHA384

### 4. Chiffrement de donn√©es
- **Au repos**: LUKS (AES-256-XTS)
- **Fichiers**: GPG (RSA-4096/Ed25519)
- **Sauvegardes**: GPG chiffr√©

## Proc√©dures de maintenance

### Rotation des cl√©s
- **Certificats SSL**: Automatique (Let's Encrypt)
- **Cl√©s SSH**: Manuellement, tous les 2 ans
- **Cl√©s VPN**: Manuellement, annuellement

### Audit de s√©curit√©
- **Fr√©quence**: Mensuelle
- **Script**: `/usr/local/bin/crypto-audit.sh`
- **Rapport**: `/var/log/crypto-audit.log`

### Sauvegarde des cl√©s
- **Localisation**: `/backup/keys/`
- **Chiffrement**: GPG avec cl√© ma√Ætre
- **Fr√©quence**: Apr√®s chaque modification

## Contacts et responsabilit√©s

- **Administrateur s√©curit√©**: admin@exemple.com
- **√âquipe technique**: tech@exemple.com
- **Proc√©dures d'urgence**: security@exemple.com

## R√©f√©rences

- Politique de s√©curit√©: `/etc/security/crypto-policy.txt`
- Standards: ISO 27001, NIST Cybersecurity Framework
- R√©glementation: RGPD, ANSSI
EOF

# G√©n√©ration du manuel d'utilisation
cat > "$DOC_DIR/MANUAL.md" << 'EOF'
# Manuel d'utilisation - Infrastructure Cryptographique

## Connexion SSH s√©curis√©e

### Premi√®re connexion
```bash
# G√©n√©rer une paire de cl√©s
ssh-keygen -t ed25519 -C "votre.email@exemple.com"

# Copier la cl√© publique sur le serveur
ssh-copy-id -p 2222 utilisateur@serveur.exemple.com
```

### Connexion habituelle
```bash
ssh -p 2222 utilisateur@serveur.exemple.com
```

## Utilisation du VPN

### WireGuard
```bash
# D√©marrer la connexion
sudo wg-quick up wg0

# V√©rifier l'√©tat
sudo wg show

# Arr√™ter la connexion
sudo wg-quick down wg0
```

### OpenVPN
```bash
# Connexion avec fichier .ovpn
sudo openvpn client.ovpn

# Connexion en arri√®re-plan
sudo openvpn --config client.ovpn --daemon
```

## Chiffrement de fichiers

### Avec GPG
```bash
# Chiffrer un fichier
gpg --encrypt --recipient destinataire@exemple.com fichier.txt

# D√©chiffrer un fichier
gpg --decrypt fichier.txt.gpg > fichier.txt

# Chiffrement sym√©trique
gpg --symmetric fichier.txt
```

### Chiffrement de r√©pertoire
```bash
# Cr√©er un r√©pertoire chiffr√©
encfs ~/.encrypted ~/decrypted

# Monter un r√©pertoire existant
encfs ~/.encrypted ~/decrypted

# D√©monter
fusermount -u ~/decrypted
```

## Maintenance courante

### V√©rification des services
```bash
# SSH
sudo systemctl status ssh

# VPN WireGuard
sudo systemctl status wg-quick@wg0

# VPN OpenVPN
sudo systemctl status openvpn-server@server

# Pare-feu
sudo ufw status

# Fail2ban
sudo fail2ban-client status
```

### Audit de s√©curit√©
```bash
# Audit complet
sudo /usr/local/bin/crypto-audit.sh

# V√©rification SSL
sudo /usr/local/bin/ssl-audit.sh exemple.com

# Conformit√© RGPD
sudo /usr/local/bin/gdpr-crypto-compliance.sh
```

## R√©solution de probl√®mes

### SSH
- V√©rifier le port (2222)
- V√©rifier les permissions des cl√©s (600)
- Consulter les logs: `sudo journalctl -u ssh -f`

### VPN
- V√©rifier les ports ouverts dans le pare-feu
- V√©rifier les cl√©s et certificats
- Consulter les logs syst√®me

### SSL/TLS
- V√©rifier l'expiration des certificats
- Tester avec: `openssl s_client -connect exemple.com:443`
- Renouveler: `sudo certbot renew`

## Proc√©dures d'urgence

### Compromission de cl√©
1. R√©voquer imm√©diatement la cl√©/certificat
2. G√©n√©rer de nouvelles cl√©s
3. D√©ployer sur tous les syst√®mes
4. Analyser les logs d'acc√®s
5. Documenter l'incident

### Perte d'acc√®s
1. Utiliser l'acc√®s physique ou console
2. V√©rifier la configuration r√©seau
3. Red√©marrer les services concern√©s
4. Contacter l'√©quipe de s√©curit√©

EOF

echo "Documentation g√©n√©r√©e dans $DOC_DIR/"
ls -la "$DOC_DIR/"
```

### Tests et validation

#### Suite de tests automatis√©s

```bash
#!/bin/bash
# /usr/local/bin/crypto-test-suite.sh

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

TESTS_PASSED=0
TESTS_FAILED=0
TESTS_TOTAL=0

# Fonction de test
run_test() {
    local test_name="$1"
    local test_command="$2"
    local expected_result="$3"

    TESTS_TOTAL=$((TESTS_TOTAL + 1))

    echo -n "Test: $test_name ... "

    if eval "$test_command" >/dev/null 2>&1; then
        if [ "$expected_result" = "pass" ]; then
            echo -e "${GREEN}PASS${NC}"
            TESTS_PASSED=$((TESTS_PASSED + 1))
        else
            echo -e "${RED}FAIL${NC} (attendu: √©chec)"
            TESTS_FAILED=$((TESTS_FAILED + 1))
        fi
    else
        if [ "$expected_result" = "fail" ]; then
            echo -e "${GREEN}PASS${NC} (√©chec attendu)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
        else
            echo -e "${RED}FAIL${NC}"
            TESTS_FAILED=$((TESTS_FAILED + 1))
        fi
    fi
}

echo "=== SUITE DE TESTS CRYPTOGRAPHIQUES ==="
echo "Date: $(date)"
echo

# Tests SSH
echo "=== Tests SSH ==="
run_test "Service SSH actif" "systemctl is-active ssh" "pass"
run_test "Port SSH non-standard" "netstat -tlnp | grep ':2222'" "pass"
run_test "Connexion SSH port 22 bloqu√©e" "timeout 5 nc -z localhost 22" "fail"
run_test "Cl√©s SSH pr√©sentes" "ls /etc/ssh/ssh_host_*_key" "pass"
run_test "Permissions cl√©s SSH" "find /etc/ssh -name '*_key' -perm 600" "pass"

echo

# Tests VPN
echo "=== Tests VPN ==="
if systemctl is-active wg-quick@wg0 >/dev/null 2>&1; then
    run_test "WireGuard actif" "systemctl is-active wg-quick@wg0" "pass"
    run_test "Interface WireGuard pr√©sente" "ip link show wg0" "pass"
    run_test "Port WireGuard ouvert" "netstat -unlp | grep ':51820'" "pass"
elif systemctl is-active openvpn-server@server >/dev/null 2>&1; then
    run_test "OpenVPN actif" "systemctl is-active openvpn-server@server" "pass"
    run_test "Interface OpenVPN pr√©sente" "ip link show tun0" "pass"
    run_test "Port OpenVPN ouvert" "netstat -unlp | grep ':1194'" "pass"
else
    echo "Aucun VPN d√©tect√©"
fi

echo

# Tests SSL/TLS
echo "=== Tests SSL/TLS ==="
if netstat -tlnp | grep -q ':443'; then
    run_test "HTTPS actif" "netstat -tlnp | grep ':443'" "pass"

    # Test avec un domaine local si disponible
    if [ -f "/etc/ssl/certs/apache-selfsigned.crt" ]; then
        run_test "Certificat SSL pr√©sent" "openssl x509 -in /etc/ssl/certs/apache-selfsigned.crt -noout -text" "pass"
    fi
else
    echo "HTTPS non configur√©"
fi

echo

# Tests de chiffrement
echo "=== Tests de chiffrement ==="
run_test "OpenSSL disponible" "openssl version" "pass"
run_test "GPG disponible" "gpg --version" "pass"

# Test de g√©n√©ration de cl√© temporaire
TEMP_KEY="/tmp/test_key.gpg"
run_test "G√©n√©ration cl√© GPG test" "gpg --batch --generate-key <<< 'Key-Type: RSA
Key-Length: 2048
Name-Real: Test User
Name-Email: test@test.com
Expire-Date: 1d
Passphrase: test123'" "pass"

# Test de chiffrement/d√©chiffrement
echo "test data" > /tmp/test_file.txt
run_test "Chiffrement GPG" "gpg --trust-model always --encrypt --recipient test@test.com /tmp/test_file.txt" "pass"
run_test "D√©chiffrement GPG" "echo 'test123' | gpg --batch --yes --passphrase-fd 0 --decrypt /tmp/test_file.txt.gpg" "pass"

# Nettoyage
rm -f /tmp/test_file.txt*
gpg --batch --yes --delete-secret-keys test@test.com >/dev/null 2>&1
gpg --batch --yes --delete-keys test@test.com >/dev/null 2>&1

echo

# Tests de s√©curit√©
echo "=== Tests de s√©curit√© ==="
run_test "Pare-feu actif" "ufw status | grep -q 'Status: active'" "pass"
run_test "Fail2ban actif" "systemctl is-active fail2ban" "pass"
run_test "Forwarding IP activ√©" "sysctl net.ipv4.ip_forward | grep -q '= 1'" "pass"

echo

# Tests de conformit√©
echo "=== Tests de conformit√© ==="
run_test "Politique cryptographique pr√©sente" "[ -f /etc/security/crypto-policy.txt ]" "pass"
run_test "Documentation pr√©sente" "[ -d /usr/share/doc/crypto-infrastructure ]" "pass"

echo
echo "=== R√âSULTATS ==="
echo "Tests r√©ussis: $TESTS_PASSED"
echo "Tests √©chou√©s: $TESTS_FAILED"
echo "Total: $TESTS_TOTAL"

if [ $TESTS_FAILED -eq 0 ]; then
    echo -e "${GREEN}Tous les tests sont pass√©s avec succ√®s!${NC}"
    exit 0
else
    echo -e "${RED}$TESTS_FAILED test(s) ont √©chou√©${NC}"
    exit 1
fi
```

---

## Conclusion du Module 5.4

### R√©capitulatif des comp√©tences acquises

√Ä l'issue de cette section sur les VPN et le chiffrement, vous ma√Ætrisez :

**Technologies VPN :**
- **OpenVPN** : Configuration serveur/client compl√®te avec PKI
- **WireGuard** : D√©ploiement moderne et performant
- **Comparaison** : Choix appropri√© selon le contexte

**Infrastructure de cl√©s (PKI) :**
- **Easy-RSA** : Gestion simplifi√©e des certificats
- **OpenSSL** : Contr√¥le total sur la cryptographie
- **Let's Encrypt** : Certificats SSL/TLS automatis√©s

**Chiffrement des donn√©es :**
- **Au repos** : LUKS, EncFS, GPG
- **En transit** : SSL/TLS, SSH, VPN
- **Hybrid** : Combinaison des approches

**Conformit√© et audit :**
- **RGPD** : Mise en conformit√© cryptographique
- **ISO 27001** : Standards industriels
- **Documentation** : Proc√©dures et manuels

### Points cl√©s √† retenir

1. **Chiffrement multicouche** : Prot√©ger les donn√©es au repos et en transit
2. **Gestion des cl√©s** : G√©n√©ration, stockage, rotation s√©curis√©s
3. **Algorithmes modernes** : Privil√©gier les standards actuels
4. **Audit r√©gulier** : V√©rification continue de la s√©curit√©
5. **Documentation** : Proc√©dures claires et accessibles

### Applications pratiques

**Pour l'entreprise :**
- Acc√®s distant s√©curis√© pour le t√©l√©travail
- Protection des donn√©es sensibles
- Conformit√© r√©glementaire (RGPD, ISO 27001)
- Interconnexion de sites distants

**Pour l'administration syst√®me :**
- Automatisation du d√©ploiement s√©curis√©
- Monitoring et alerting proactif
- Proc√©dures de r√©ponse aux incidents
- Formation et sensibilisation des √©quipes

### Prochaines √©tapes

Ces comp√©tences vous pr√©parent pour :
- **Module 6** : Services de base s√©curis√©s (web, base de donn√©es)
- **Module 8** : Virtualisation et conteneurs avec chiffrement
- **Module 14** : S√©curit√© cloud-native avanc√©e

### Ressources pour approfondir

**Documentation officielle :**
- **OpenVPN** : https://openvpn.net/community-resources/
- **WireGuard** : https://www.wireguard.com/quickstart/
- **OpenSSL** : https://www.openssl.org/docs/
- **Let's Encrypt** : https://letsencrypt.org/docs/

**Standards et r√©f√©rences :**
- **NIST Cryptographic Standards** : https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines
- **ANSSI R√©f√©rentiels** : https://www.ssi.gouv.fr/particulier/bonnes-pratiques/
- **RFC Standards** : RFC 8446 (TLS 1.3), RFC 7748 (Curve25519)

**Outils et utilitaires :**
- **Testssl.sh** : Test complet SSL/TLS
- **Nmap** : Scan de ports et services
- **Wireshark** : Analyse de trafic r√©seau
- **John the Ripper** : Test de robustesse des mots de passe

### Bonnes pratiques de maintenance

**Quotidienne :**
- V√©rification des logs de s√©curit√©
- Surveillance des connexions VPN actives
- Contr√¥le de l'√©tat des services critiques

**Hebdomadaire :**
- Audit des tentatives de connexion
- V√©rification des mises √† jour de s√©curit√©
- Test des sauvegardes chiffr√©es

**Mensuelle :**
- Audit cryptographique complet
- R√©vision des acc√®s et permissions
- Test de restauration des cl√©s

**Annuelle :**
- Rotation des certificats et cl√©s
- R√©vision de la politique de s√©curit√©
- Formation du personnel
- Audit de conformit√© externe

---

## Conclusion du Module 5 : R√©seau et s√©curit√©

Le Module 5 vous a fourni une base solide en s√©curit√© r√©seau, couvrant depuis la configuration r√©seau avanc√©e jusqu'au chiffrement des donn√©es. Ces comp√©tences sont essentielles pour tout administrateur syst√®me moderne.

### Comp√©tences transversales acquises

**S√©curit√© multicouche :**
- Configuration r√©seau s√©curis√©e et diagnostics
- Pare-feu et protection contre les intrusions
- SSH s√©curis√© et acc√®s distant
- VPN et chiffrement des communications

**Automatisation et monitoring :**
- Scripts d'automatisation pour le d√©ploiement
- Outils de monitoring et d'audit
- Proc√©dures de r√©ponse aux incidents
- Documentation et conformit√©

### Pr√©paration aux modules avanc√©s

Ces fondations vous permettent d'aborder sereinement :
- Les services r√©seau avanc√©s (DNS, DHCP, mail)
- La virtualisation et les conteneurs
- L'orchestration avec Kubernetes
- Les architectures cloud-native

La s√©curit√© √©tant un domaine en constante √©volution, il est crucial de maintenir une veille technologique et de pratiquer r√©guli√®rement pour perfectionner ces comp√©tences essentielles.

‚è≠Ô∏è
