üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.3 SSH et acc√®s distant
*Module 5 : R√©seau et s√©curit√© - Formation Debian Desktop et Server*

## Introduction √† SSH et l'acc√®s distant

**SSH** (Secure Shell) est le protocole standard pour l'acc√®s distant s√©curis√© aux syst√®mes Unix/Linux. Il remplace les anciens protocoles non s√©curis√©s comme Telnet et rsh en chiffrant toutes les communications entre le client et le serveur.

### Pourquoi SSH est-il indispensable ?

Dans un monde o√π l'administration √† distance est devenue la norme, SSH offre :

- **S√©curit√©** : Chiffrement fort de toutes les communications
- **Authentification robuste** : Mots de passe et cl√©s cryptographiques
- **Int√©grit√©** : V√©rification que les donn√©es n'ont pas √©t√© alt√©r√©es
- **Flexibilit√©** : Tunneling, transfert de fichiers, ex√©cution de commandes
- **Universalit√©** : Disponible sur tous les syst√®mes Unix/Linux

### Concepts fondamentaux

**Architecture client-serveur :**
- **Serveur SSH** : D√©mon qui √©coute les connexions (g√©n√©ralement port 22)
- **Client SSH** : Application qui initie la connexion

**M√©thodes d'authentification :**
- **Par mot de passe** : Simple mais moins s√©curis√©
- **Par cl√©s publiques** : Plus s√©curis√© et pratique
- **Par certificats** : Pour les grandes infrastructures

**Protocoles de chiffrement :**
- **SSH-1** : Obsol√®te et non s√©curis√©
- **SSH-2** : Standard moderne (uniquement celui-ci)

---

## 5.3.1 Installation et configuration d'OpenSSH

### Installation du serveur OpenSSH

#### Sur Debian/Ubuntu

```bash
# Mise √† jour des paquets
sudo apt update

# Installation du serveur SSH
sudo apt install openssh-server

# Installation du client SSH (g√©n√©ralement d√©j√† pr√©sent)
sudo apt install openssh-client

# V√©rifier l'installation
ssh -V
```

#### V√©rification et d√©marrage du service

```bash
# V√©rifier le statut du service
sudo systemctl status ssh

# D√©marrer le service SSH
sudo systemctl start ssh

# Activer le d√©marrage automatique
sudo systemctl enable ssh

# Red√©marrer le service
sudo systemctl restart ssh

# Arr√™ter le service
sudo systemctl stop ssh
```

### Configuration de base du serveur SSH

Le fichier de configuration principal se trouve dans `/etc/ssh/sshd_config`.

#### Structure du fichier de configuration

```bash
# Cr√©er une sauvegarde avant modification
sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup

# √âditer la configuration
sudo nano /etc/ssh/sshd_config
```

#### Configuration s√©curis√©e recommand√©e

```bash
# /etc/ssh/sshd_config - Configuration s√©curis√©e

# Port d'√©coute (changer du port par d√©faut pour plus de s√©curit√©)
Port 2222

# Adresses d'√©coute (sp√©cifier les interfaces si n√©cessaire)
#ListenAddress 0.0.0.0
#ListenAddress ::

# Version du protocole (uniquement SSH-2)
Protocol 2

# Fichiers de cl√©s du serveur
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key

# Logging
SyslogFacility AUTH
LogLevel VERBOSE

# Authentification
LoginGraceTime 60
PermitRootLogin no
StrictModes yes
MaxAuthTries 3
MaxSessions 4

# Authentification par cl√©s publiques
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys

# Authentification par mot de passe (√† d√©sactiver apr√®s config des cl√©s)
PasswordAuthentication yes
PermitEmptyPasswords no
ChallengeResponseAuthentication no

# Configuration Kerberos et GSSAPI
KerberosAuthentication no
GSSAPIAuthentication no

# Forwarding
AllowAgentForwarding yes
AllowTcpForwarding yes
GatewayPorts no
X11Forwarding yes

# Autres param√®tres de s√©curit√©
PrintMotd no
PrintLastLog yes
TCPKeepAlive yes
UsePrivilegeSeparation sandbox
Compression delayed

# Limitation des utilisateurs (optionnel)
AllowUsers admin user1 user2
#AllowGroups ssh-users

# Banni√®re (optionnel)
#Banner /etc/issue.net

# Subsystem SFTP
Subsystem sftp /usr/lib/openssh/sftp-server
```

#### Param√®tres importants expliqu√©s

**S√©curit√© de base :**
- `Port 2222` : Change le port par d√©faut (22) pour r√©duire les attaques automatis√©es
- `PermitRootLogin no` : Interdit la connexion directe en root
- `Protocol 2` : Force l'utilisation de SSH-2 uniquement
- `MaxAuthTries 3` : Limite les tentatives d'authentification

**Authentification :**
- `PubkeyAuthentication yes` : Active l'authentification par cl√©s
- `PasswordAuthentication yes` : Authentification par mot de passe (√† d√©sactiver apr√®s)
- `PermitEmptyPasswords no` : Interdit les mots de passe vides

**Logging et monitoring :**
- `LogLevel VERBOSE` : Logging d√©taill√© pour le monitoring
- `SyslogFacility AUTH` : Utilise le facility AUTH pour les logs

#### Application de la configuration

```bash
# Tester la configuration
sudo sshd -t

# Si pas d'erreur, red√©marrer le service
sudo systemctl restart ssh

# V√©rifier que le service √©coute sur le nouveau port
sudo netstat -tlnp | grep :2222
# ou
sudo ss -tlnp | grep :2222
```

### Configuration du client SSH

#### Fichier de configuration client

```bash
# Configuration globale (tous les utilisateurs)
sudo nano /etc/ssh/ssh_config

# Configuration utilisateur (recommand√©)
nano ~/.ssh/config
```

#### Exemple de configuration client

```bash
# ~/.ssh/config

# Configuration par d√©faut
Host *
    Protocol 2
    ForwardAgent no
    ForwardX11 no
    PasswordAuthentication yes
    CheckHostIP yes
    AddressFamily any
    ConnectTimeout 30
    StrictHostKeyChecking ask
    IdentitiesOnly yes

# Serveur sp√©cifique
Host monserveur
    HostName 192.168.1.100
    Port 2222
    User admin
    IdentityFile ~/.ssh/id_rsa_monserveur
    ServerAliveInterval 60
    ServerAliveCountMax 3

# Serveur de production
Host prod
    HostName prod.example.com
    Port 2222
    User deploy
    IdentityFile ~/.ssh/id_ed25519_prod
    StrictHostKeyChecking yes
    UserKnownHostsFile ~/.ssh/known_hosts_prod

# Bastion/Jump host
Host bastion
    HostName bastion.example.com
    Port 22
    User admin

# Serveur derri√®re bastion
Host serveur-interne
    HostName 10.0.1.100
    Port 22
    User admin
    ProxyCommand ssh -W %h:%p bastion
```

### Commandes SSH de base

#### Connexion simple

```bash
# Connexion basique
ssh utilisateur@serveur.example.com

# Avec port sp√©cifique
ssh -p 2222 utilisateur@serveur.example.com

# Avec cl√© sp√©cifique
ssh -i ~/.ssh/ma_cle_privee utilisateur@serveur.example.com

# Ex√©cution d'une commande distante
ssh utilisateur@serveur.example.com "ls -la /var/log"

# Connexion avec forwarding X11 (interface graphique)
ssh -X utilisateur@serveur.example.com
```

#### Utilisation du fichier de configuration

```bash
# Avec la configuration ~/.ssh/config
ssh monserveur

# √âquivaut √† :
ssh -p 2222 -i ~/.ssh/id_rsa_monservever admin@192.168.1.100
```

### Gestion des cl√©s d'h√¥te

#### V√©rification des empreintes

```bash
# Voir l'empreinte des cl√©s du serveur
ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub
ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub
ssh-keygen -l -f /etc/ssh/ssh_host_ed25519_key.pub

# Voir l'empreinte depuis le client
ssh-keygen -l -f ~/.ssh/known_hosts
```

#### Gestion du fichier known_hosts

```bash
# Ajouter manuellement une cl√© d'h√¥te
ssh-keyscan -p 2222 serveur.example.com >> ~/.ssh/known_hosts

# Supprimer une entr√©e
ssh-keygen -R serveur.example.com
ssh-keygen -R [serveur.example.com]:2222

# V√©rifier une cl√© d'h√¥te
ssh-keygen -F serveur.example.com
```

---

## 5.3.2 Authentification par cl√©s

L'authentification par cl√©s publiques est plus s√©curis√©e que les mots de passe et permet l'automatisation des connexions.

### Comprendre la cryptographie √† cl√©s publiques

**Principe :**
- **Cl√© priv√©e** : Gard√©e secr√®te sur votre machine cliente
- **Cl√© publique** : Copi√©e sur le serveur dans `~/.ssh/authorized_keys`
- **Authentification** : Le serveur v√©rifie que vous poss√©dez la cl√© priv√©e correspondante

**Avantages :**
- Plus s√©curis√© que les mots de passe
- R√©sistant aux attaques par force brute
- Permet l'automatisation (scripts, t√¢ches cron)
- Peut √™tre prot√©g√© par une passphrase

### G√©n√©ration des cl√©s SSH

#### Types de cl√©s disponibles

```bash
# RSA (traditionnel, compatible)
ssh-keygen -t rsa -b 4096

# ECDSA (moderne, plus rapide)
ssh-keygen -t ecdsa -b 521

# Ed25519 (recommand√©, tr√®s s√©curis√© et rapide)
ssh-keygen -t ed25519

# Avec commentaire et fichier sp√©cifique
ssh-keygen -t ed25519 -C "admin@monserveur" -f ~/.ssh/id_ed25519_monserveur
```

#### G√©n√©ration recommand√©e √©tape par √©tape

```bash
# G√©n√©ration d'une cl√© Ed25519 s√©curis√©e
ssh-keygen -t ed25519 -C "votre.email@exemple.com"

# Le syst√®me demande :
# Nom du fichier : (appuyer Entr√©e pour ~/.ssh/id_ed25519)
# Passphrase : (recommand√© pour la s√©curit√©)
# Confirmation passphrase

# R√©sultat :
# ~/.ssh/id_ed25519      (cl√© priv√©e)
# ~/.ssh/id_ed25519.pub  (cl√© publique)
```

#### G√©n√©ration avec options avanc√©es

```bash
# Cl√© avec passphrase complexe et nom personnalis√©
ssh-keygen -t ed25519 \
           -C "admin-prod-$(date +%Y%m%d)" \
           -f ~/.ssh/id_ed25519_prod \
           -N "ma_passphrase_complexe"

# Cl√© RSA 4096 bits pour compatibilit√©
ssh-keygen -t rsa \
           -b 4096 \
           -C "admin@$(hostname)-$(date +%Y%m%d)" \
           -f ~/.ssh/id_rsa_compat
```

### D√©ploiement des cl√©s publiques

#### M√©thode automatique avec ssh-copy-id

```bash
# Copie automatique de la cl√© par d√©faut
ssh-copy-id utilisateur@serveur.example.com

# Avec port sp√©cifique
ssh-copy-id -p 2222 utilisateur@serveur.example.com

# Avec cl√© sp√©cifique
ssh-copy-id -i ~/.ssh/id_ed25519_prod.pub utilisateur@serveur.example.com

# Avec options SSH
ssh-copy-id -o "StrictHostKeyChecking=no" -p 2222 utilisateur@serveur.example.com
```

#### M√©thode manuelle

```bash
# Afficher la cl√© publique
cat ~/.ssh/id_ed25519.pub

# Se connecter au serveur et cr√©er le r√©pertoire .ssh
ssh utilisateur@serveur.example.com
mkdir -p ~/.ssh
chmod 700 ~/.ssh

# Ajouter la cl√© publique au fichier authorized_keys
echo "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILpyGmkF... votre.email@exemple.com" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```

#### M√©thode avec redirection

```bash
# Copier la cl√© publique via SSH
cat ~/.ssh/id_ed25519.pub | ssh utilisateur@serveur.example.com \
  "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys"
```

### Gestion des cl√©s multiples

#### Organisation des cl√©s

```bash
# Structure recommand√©e
~/.ssh/
‚îú‚îÄ‚îÄ config                    # Configuration SSH
‚îú‚îÄ‚îÄ known_hosts              # Cl√©s d'h√¥tes v√©rifi√©es
‚îú‚îÄ‚îÄ id_rsa                   # Cl√© par d√©faut (priv√©e)
‚îú‚îÄ‚îÄ id_rsa.pub               # Cl√© par d√©faut (publique)
‚îú‚îÄ‚îÄ id_ed25519_prod          # Cl√© production (priv√©e)
‚îú‚îÄ‚îÄ id_ed25519_prod.pub      # Cl√© production (publique)
‚îú‚îÄ‚îÄ id_ed25519_dev           # Cl√© d√©veloppement (priv√©e)
‚îú‚îÄ‚îÄ id_ed25519_dev.pub       # Cl√© d√©veloppement (publique)
‚îî‚îÄ‚îÄ authorized_keys          # Cl√©s autoris√©es (si serveur SSH)
```

#### Configuration pour cl√©s multiples

```bash
# ~/.ssh/config
Host prod
    HostName prod.example.com
    User admin
    IdentityFile ~/.ssh/id_ed25519_prod
    IdentitiesOnly yes

Host dev
    HostName dev.example.com
    User developer
    IdentityFile ~/.ssh/id_ed25519_dev
    IdentitiesOnly yes

Host legacy
    HostName old.example.com
    User admin
    IdentityFile ~/.ssh/id_rsa_legacy
    IdentitiesOnly yes
```

### Gestion de l'agent SSH

L'agent SSH garde vos cl√©s priv√©es en m√©moire pour √©viter de retaper la passphrase.

#### D√©marrage de l'agent SSH

```bash
# D√©marrer l'agent SSH
eval $(ssh-agent)

# Ou dans un nouveau shell
ssh-agent bash

# V√©rifier que l'agent fonctionne
echo $SSH_AUTH_SOCK
```

#### Ajout de cl√©s √† l'agent

```bash
# Ajouter la cl√© par d√©faut
ssh-add

# Ajouter une cl√© sp√©cifique
ssh-add ~/.ssh/id_ed25519_prod

# Ajouter avec dur√©e de vie limit√©e (1 heure)
ssh-add -t 3600 ~/.ssh/id_ed25519_prod

# Lister les cl√©s charg√©es
ssh-add -l

# Lister les cl√©s avec empreintes compl√®tes
ssh-add -L
```

#### Suppression de cl√©s

```bash
# Supprimer une cl√© sp√©cifique
ssh-add -d ~/.ssh/id_ed25519_prod

# Supprimer toutes les cl√©s
ssh-add -D

# Tuer l'agent SSH
ssh-agent -k
```

#### Configuration automatique au d√©marrage

```bash
# Ajouter au ~/.bashrc ou ~/.profile
if [ -z "$SSH_AUTH_SOCK" ]; then
    eval $(ssh-agent)
    ssh-add ~/.ssh/id_ed25519
fi
```

### S√©curisation avanc√©e des cl√©s

#### Protection par passphrase

```bash
# Ajouter/changer la passphrase d'une cl√© existante
ssh-keygen -p -f ~/.ssh/id_ed25519

# Supprimer la passphrase (non recommand√©)
ssh-keygen -p -f ~/.ssh/id_ed25519 -N ""
```

#### Restrictions sur les cl√©s autoris√©es

```bash
# ~/.ssh/authorized_keys avec restrictions

# Restriction par commande
command="rsync --server --daemon ." ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... backup@client

# Restriction par IP source
from="192.168.1.100,192.168.1.101" ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... admin@workstation

# Interdiction du forwarding
no-port-forwarding,no-agent-forwarding,no-X11-forwarding ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... script@server

# Combinaison de restrictions
command="/usr/local/bin/backup.sh",no-port-forwarding,from="10.0.1.100" ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... backup@client
```

#### R√©vocation et rotation des cl√©s

```bash
#!/bin/bash
# Script de rotation des cl√©s SSH

KEY_NAME="id_ed25519_$(date +%Y%m%d)"
SERVERS="server1.example.com server2.example.com"

# G√©n√©rer nouvelle cl√©
ssh-keygen -t ed25519 -f ~/.ssh/$KEY_NAME -C "rotation-$(date +%Y%m%d)"

# D√©ployer sur tous les serveurs
for server in $SERVERS; do
    echo "D√©ploiement sur $server..."
    ssh-copy-id -i ~/.ssh/$KEY_NAME.pub $server
done

# Tester les nouvelles cl√©s
for server in $SERVERS; do
    echo "Test de $server..."
    ssh -i ~/.ssh/$KEY_NAME -o PasswordAuthentication=no $server "echo 'OK'"
done

echo "Rotation termin√©e. Nouvelle cl√©: $KEY_NAME"
echo "Pensez √† supprimer l'ancienne cl√© des serveurs apr√®s validation."
```

---

## 5.3.3 Tunneling et port forwarding

SSH offre des capacit√©s de tunneling puissantes pour s√©curiser les communications et contourner les restrictions r√©seau.

### Types de tunneling SSH

#### Local Port Forwarding (Tunnel local)

Redirige un port local vers un port distant via le serveur SSH.

```bash
# Syntaxe g√©n√©rale
ssh -L [bind_address:]port_local:host_destination:port_destination user@ssh_server

# Exemples pratiques
# Acc√©der √† une base de donn√©es distante
ssh -L 3306:localhost:3306 admin@db-server.example.com

# Acc√©der √† un serveur web via SSH
ssh -L 8080:localhost:80 admin@web-server.example.com

# Tunnel vers un autre serveur via le serveur SSH
ssh -L 5432:db-internal.example.com:5432 admin@gateway.example.com

# Avec interface sp√©cifique
ssh -L 127.0.0.1:3306:localhost:3306 admin@db-server.example.com
```

**Cas d'usage typiques :**
- Acc√®s √† une base de donn√©es depuis un client local
- Administration web s√©curis√©e (phpMyAdmin, etc.)
- Contournement de pare-feu restrictifs

#### Remote Port Forwarding (Tunnel distant)

Permet √† un serveur distant de rediriger son trafic vers votre machine locale.

```bash
# Syntaxe g√©n√©rale
ssh -R [bind_address:]port_distant:host_local:port_local user@ssh_server

# Exemples pratiques
# Permettre l'acc√®s √† votre serveur web local depuis l'ext√©rieur
ssh -R 8080:localhost:80 admin@public-server.example.com

# Acc√®s SSH inverse (utile pour machines derri√®re NAT)
ssh -R 2222:localhost:22 admin@public-server.example.com

# Partage temporaire d'un service local
ssh -R 3000:localhost:3000 admin@demo-server.example.com
```

**Cas d'usage typiques :**
- D√©monstration d'applications en d√©veloppement
- Acc√®s SSH inverse pour machines sans IP publique
- Partage temporaire de services

#### Dynamic Port Forwarding (Proxy SOCKS)

Cr√©e un proxy SOCKS qui route tout le trafic via le serveur SSH.

```bash
# Cr√©er un proxy SOCKS
ssh -D 1080 admin@proxy-server.example.com

# Avec interface sp√©cifique
ssh -D 127.0.0.1:1080 admin@proxy-server.example.com

# Combin√© avec autres options
ssh -D 1080 -C -N admin@proxy-server.example.com
```

**Configuration du navigateur :**
- Proxy SOCKS5 : 127.0.0.1:1080
- Utilisation pour anonymiser le trafic web

### Techniques avanc√©es de tunneling

#### Tunnels persistants

```bash
# Tunnel avec reconnexion automatique
ssh -L 3306:localhost:3306 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 admin@db-server.example.com

# Tunnel en arri√®re-plan
ssh -f -N -L 3306:localhost:3306 admin@db-server.example.com

# Avec autossh pour maintenir le tunnel
sudo apt install autossh
autossh -M 20000 -f -N -L 3306:localhost:3306 admin@db-server.example.com
```

#### Configuration avec fichier config

```bash
# ~/.ssh/config
Host db-tunnel
    HostName db-server.example.com
    User admin
    LocalForward 3306 localhost:3306
    ServerAliveInterval 60
    ServerAliveCountMax 3
    ExitOnForwardFailure yes

Host socks-proxy
    HostName proxy-server.example.com
    User admin
    DynamicForward 1080
    ServerAliveInterval 30
```

```bash
# Utilisation simplifi√©e
ssh -N db-tunnel
ssh -N socks-proxy
```

#### Tunnels multiples et complexes

```bash
# Multiples forwards dans une connexion
ssh -L 3306:db1.internal:3306 \
    -L 5432:db2.internal:5432 \
    -L 6379:redis.internal:6379 \
    admin@gateway.example.com

# Cha√Ænage de tunnels (double hop)
# √âtape 1 : Tunnel vers le bastion
ssh -L 2222:internal-server:22 admin@bastion.example.com

# √âtape 2 : Tunnel via le bastion (nouveau terminal)
ssh -p 2222 -L 3306:database:3306 admin@localhost
```

### Jump hosts et proxy commands

#### Configuration ProxyCommand

```bash
# ~/.ssh/config
Host bastion
    HostName bastion.example.com
    User admin

Host internal-server
    HostName 10.0.1.100
    User admin
    ProxyCommand ssh -W %h:%p bastion

# Ou avec ProxyJump (SSH 7.3+)
Host internal-server-v2
    HostName 10.0.1.100
    User admin
    ProxyJump bastion
```

#### Cha√Ænage de multiples jump hosts

```bash
# ~/.ssh/config
Host jump1
    HostName jump1.example.com
    User admin

Host jump2
    HostName jump2.internal
    User admin
    ProxyJump jump1

Host final-server
    HostName server.private
    User admin
    ProxyJump jump1,jump2
```

### Scripts d'automatisation

#### Script de gestion de tunnels

```bash
#!/bin/bash
# tunnel-manager.sh - Gestionnaire de tunnels SSH

TUNNEL_DIR="$HOME/.ssh/tunnels"
mkdir -p $TUNNEL_DIR

case "$1" in
    start)
        case "$2" in
            db)
                echo "D√©marrage tunnel base de donn√©es..."
                ssh -f -N -L 3306:localhost:3306 admin@db-server.example.com
                echo $! > $TUNNEL_DIR/db.pid
                ;;
            web)
                echo "D√©marrage tunnel web..."
                ssh -f -N -L 8080:localhost:80 admin@web-server.example.com
                echo $! > $TUNNEL_DIR/web.pid
                ;;
            socks)
                echo "D√©marrage proxy SOCKS..."
                ssh -f -N -D 1080 admin@proxy-server.example.com
                echo $! > $TUNNEL_DIR/socks.pid
                ;;
            *)
                echo "Usage: $0 start {db|web|socks}"
                ;;
        esac
        ;;
    stop)
        case "$2" in
            db|web|socks)
                if [ -f $TUNNEL_DIR/$2.pid ]; then
                    kill $(cat $TUNNEL_DIR/$2.pid)
                    rm $TUNNEL_DIR/$2.pid
                    echo "Tunnel $2 arr√™t√©"
                else
                    echo "Tunnel $2 non trouv√©"
                fi
                ;;
            all)
                for pidfile in $TUNNEL_DIR/*.pid; do
                    if [ -f "$pidfile" ]; then
                        kill $(cat "$pidfile")
                        rm "$pidfile"
                    fi
                done
                echo "Tous les tunnels arr√™t√©s"
                ;;
            *)
                echo "Usage: $0 stop {db|web|socks|all}"
                ;;
        esac
        ;;
    status)
        echo "=== Tunnels actifs ==="
        for pidfile in $TUNNEL_DIR/*.pid; do
            if [ -f "$pidfile" ]; then
                tunnel=$(basename "$pidfile" .pid)
                pid=$(cat "$pidfile")
                if ps -p $pid > /dev/null; then
                    echo "‚úì $tunnel (PID: $pid)"
                else
                    echo "‚úó $tunnel (PID mort: $pid)"
                    rm "$pidfile"
                fi
            fi
        done
        ;;
    *)
        echo "Usage: $0 {start|stop|status} [tunnel_name]"
        echo "Tunnels disponibles: db, web, socks"
        ;;
esac
```

---

## 5.3.4 S√©curisation d'SSH (fail2ban, port knocking)

### Hardening SSH - Configuration s√©curis√©e avanc√©e

#### Configuration s√©curis√©e compl√®te

```bash
# /etc/ssh/sshd_config - Configuration renforc√©e
Port 2222
Protocol 2

# Binding et interfaces
ListenAddress 192.168.1.100
#ListenAddress 0.0.0.0

# Cl√©s d'h√¥te (uniquement les plus s√©curis√©es)
HostKey /etc/ssh/ssh_host_ed25519_key
HostKey /etc/ssh/ssh_host_rsa_key

# Algorithmes cryptographiques s√©curis√©s
KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group16-sha512
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes256-ctr
MACs hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com

# Authentification renforc√©e
PermitRootLogin no
MaxAuthTries 2
MaxSessions 2
LoginGraceTime 30
StrictModes yes

# Authentification par cl√©s uniquement (apr√®s configuration)
PubkeyAuthentication yes
PasswordAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no

# D√©sactiver l'authentification par h√¥te
HostbasedAuthentication no
IgnoreUserKnownHosts yes
IgnoreRhosts yes

# Restrictions utilisateurs
AllowUsers admin deploy
#AllowGroups ssh-users
DenyUsers guest nobody
#DenyGroups wheel

# Timeouts et keep-alive
ClientAliveInterval 300
ClientAliveCountMax 2
TCPKeepAlive no

# Forwarding (restreindre selon les besoins)
AllowAgentForwarding no
AllowTcpForwarding no
GatewayPorts no
PermitTunnel no

# X11 (uniquement si n√©cessaire)
X11Forwarding no

# Autres s√©curisations
PermitUserEnvironment no
Compression no
UseDNS no
PrintMotd no
PrintLastLog yes

# Banni√®re de s√©curit√©
Banner /etc/ssh/banner
```

#### Cr√©ation d'une banni√®re de s√©curit√©

```bash
# /etc/ssh/banner
sudo nano /etc/ssh/banner
```

```
***************************************************************************
                            AVERTISSEMENT LEGAL
***************************************************************************

Ce syst√®me est r√©serv√© aux utilisateurs autoris√©s uniquement.
Toute tentative d'acc√®s non autoris√© est strictement interdite et sera
poursuivie conform√©ment √† la loi.

Toutes les activit√©s sur ce syst√®me sont surveill√©es et enregistr√©es.

En continuant, vous acceptez que vos actions soient surveill√©es.
***************************************************************************
```

### Int√©gration avec fail2ban

#### Configuration sp√©cialis√©e pour SSH

```bash
# /etc/fail2ban/jail.local
[sshd]
enabled = true
port = 2222  # Port personnalis√©
filter = sshd
logpath = /var/log/auth.log
maxretry = 2
bantime = 86400
findtime = 600
action = iptables-multiport[name=SSH, port="2222", protocol=tcp]
         sendmail-whois[name=SSH, dest=admin@example.com, sender=fail2ban@example.com]

[sshd-ddos]
enabled = true
port = 2222
filter = sshd-ddos
logpath = /var/log/auth.log
maxretry = 2
bantime = 86400
findtime = 120

[sshd-aggressive]
enabled = true
port = 2222
filter = sshd-aggressive
logpath = /var/log/auth.log
maxretry = 1  # Ban imm√©diat pour certaines attaques
bantime = 604800  # 7 jours
findtime = 31536000  # 1 an de m√©moire
```

#### Filtres personnalis√©s SSH

**Filtre pour attaques agressives :**
```bash
# /etc/fail2ban/filter.d/sshd-aggressive.conf
sudo nano /etc/fail2ban/filter.d/sshd-aggressive.conf
```

```ini
[Definition]
# D√©tection d'attaques SSH sophistiqu√©es
failregex = ^%(__prefix_line)s(?:error: PAM: )?[aA]uthentication (?:failure|error|failed) for .* from <HOST>( via \S+)?\s*$
            ^%(__prefix_line)s(?:error: )?Received disconnect from <HOST>: 3: .*: Auth fail$
            ^%(__prefix_line)sFailed \S+ for invalid user .* from <HOST>$
            ^%(__prefix_line)sFailed \S+ for .* from <HOST>$
            ^%(__prefix_line)sROOT LOGIN REFUSED.* FROM <HOST>$
            ^%(__prefix_line)s[iI](?:llegal|nvalid) user .* from <HOST>$
            ^%(__prefix_line)sUser .+ from <HOST> not allowed because not listed in AllowUsers$
            ^%(__prefix_line)sUser .+ from <HOST> not allowed because listed in DenyUsers$
            ^%(__prefix_line)sUser .+ from <HOST> not allowed because not in any group$
            ^%(__prefix_line)srefused connect from \S+ \(<HOST>\)$
            ^%(__prefix_line)sReceived disconnect from <HOST>: 11: Bye Bye$
            ^%(__prefix_line)sConnection closed by <HOST>$

ignoreregex =

[Init]
# Journalctl prefix for systemd
journalmatch = _SYSTEMD_UNIT=ssh.service + _COMM=sshd
```

**Filtre pour tentatives de connexion root :**
```bash
# /etc/fail2ban/filter.d/sshd-rootattempt.conf
sudo nano /etc/fail2ban/filter.d/sshd-rootattempt.conf
```

```ini
[Definition]
# Bannissement imm√©diat pour tentatives de connexion root
failregex = ^%(__prefix_line)sFailed \S+ for root from <HOST>$
            ^%(__prefix_line)sROOT LOGIN REFUSED.* FROM <HOST>$
            ^%(__prefix_line)sUser root from <HOST> not allowed because.*$

ignoreregex =

[Init]
journalmatch = _SYSTEMD_UNIT=ssh.service + _COMM=sshd
```

#### Jail sp√©cialis√©e pour root

```bash
# Ajouter dans /etc/fail2ban/jail.local
[sshd-rootattempt]
enabled = true
port = 2222
filter = sshd-rootattempt
logpath = /var/log/auth.log
maxretry = 1      # Ban imm√©diat
bantime = 2592000 # 30 jours
findtime = 86400  # 24h de m√©moire
action = iptables-multiport[name=SSH-ROOT, port="2222", protocol=tcp]
         sendmail[name=SSH-ROOT, dest=security@example.com]
```

### Port Knocking - S√©curit√© par obscurit√©

Le port knocking consiste √† "frapper" une s√©quence de ports ferm√©s pour d√©bloquer l'acc√®s SSH.

#### Installation de knockd

```bash
# Installation du d√©mon de port knocking
sudo apt update
sudo apt install knockd

# V√©rifier l'installation
knockd --version
```

#### Configuration de knockd

```bash
# Configuration du serveur
sudo nano /etc/knockd.conf
```

```bash
[options]
    # Interface √† surveiller
    Interface = eth0

    # Utilisateur sous lequel s'ex√©cute knockd
    UseSyslog

[openSSH]
    # S√©quence pour ouvrir SSH (ports √† frapper dans l'ordre)
    sequence    = 7000,8000,9000

    # Timeout entre les frappes (secondes)
    seq_timeout = 5

    # Commande √† ex√©cuter pour ouvrir l'acc√®s
    command     = /sbin/iptables -A INPUT -s %IP% -p tcp --dport 2222 -j ACCEPT

    # Timeout avant fermeture automatique (secondes)
    tcpflags    = syn

[closeSSH]
    # S√©quence pour fermer SSH
    sequence    = 9000,8000,7000

    # Timeout entre les frappes
    seq_timeout = 5

    # Commande pour fermer l'acc√®s
    command     = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 2222 -j ACCEPT

    tcpflags    = syn
```

#### Configuration avec dur√©e limit√©e

```bash
# Configuration avanc√©e avec auto-fermeture
[openSSH]
    sequence      = 7000,8000,9000
    seq_timeout   = 10
    start_command = /sbin/iptables -A INPUT -s %IP% -p tcp --dport 2222 -j ACCEPT
    cmd_timeout   = 300  # Fermeture automatique apr√®s 5 minutes
    stop_command  = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 2222 -j ACCEPT
    tcpflags      = syn
```

#### Activation de knockd

```bash
# √âditer la configuration du d√©mon
sudo nano /etc/default/knockd

# Activer knockd
KNOCKD_OPTS="-i eth0"

# D√©marrer et activer le service
sudo systemctl start knockd
sudo systemctl enable knockd

# V√©rifier le statut
sudo systemctl status knockd
```

#### Utilisation c√¥t√© client

```bash
# Installation du client
sudo apt install knock

# S√©quence d'ouverture
knock serveur.example.com 7000 8000 9000

# Connexion SSH (dans les 5 minutes)
ssh -p 2222 admin@serveur.example.com

# S√©quence de fermeture (optionnel)
knock serveur.example.com 9000 8000 7000
```

#### Script client automatis√©

```bash
#!/bin/bash
# /usr/local/bin/ssh-knock.sh

SERVER=$1
USER=${2:-admin}
KNOCK_PORTS="7000 8000 9000"

if [ -z "$SERVER" ]; then
    echo "Usage: $0 <server> [user]"
    exit 1
fi

echo "Port knocking sur $SERVER..."
knock $SERVER $KNOCK_PORTS

echo "Attente de 2 secondes..."
sleep 2

echo "Connexion SSH..."
ssh -p 2222 $USER@$SERVER

echo "Fermeture du port knocking..."
knock $SERVER 9000 8000 7000
```

### SPA (Single Packet Authorization)

SPA est une alternative plus s√©curis√©e au port knocking traditionnel.

#### Installation de fwknop

```bash
# Installation du serveur SPA
sudo apt update
sudo apt install fwknop-server fwknop-client

# V√©rification
fwknopd --version
fwknop --version
```

#### Configuration du serveur SPA

```bash
# Configuration principale
sudo nano /etc/fwknop/fwknopd.conf
```

```bash
# Interface d'√©coute
PCAP_INTF           eth0;

# Filtres de capture
PCAP_FILTER         udp port 62201;

# R√®gles de pare-feu
ENABLE_IPT_FORWARDING   N;
ENABLE_IPT_LOCAL_NAT    N;
ENABLE_IPT_SNAT         N;
ENABLE_IPT_OUTPUT       N;

# Cha√Ænes iptables
IPT_INPUT_ACCESS        FWKNOP_INPUT_ACCESS;
IPT_OUTPUT_ACCESS       FWKNOP_OUTPUT_ACCESS;
IPT_FORWARD_ACCESS      FWKNOP_FORWARD_ACCESS;

# Timeout par d√©faut
IPT_ACCESS_TIMEOUT      300;

# Logging
ENABLE_SPA_PACKET_AGING Y;
MAX_SPA_PACKET_AGE      120;
```

#### Configuration des cl√©s d'acc√®s

```bash
# Fichier de configuration des acc√®s
sudo nano /etc/fwknop/access.conf
```

```bash
# Entr√©e pour utilisateur admin
SOURCE                  ANY
OPEN_PORTS              tcp/2222
FW_ACCESS_TIMEOUT       300
KEY_BASE64              [cl√© g√©n√©r√©e automatiquement]
HMAC_KEY_BASE64         [cl√© HMAC g√©n√©r√©e automatiquement]
REQUIRE_SOURCE_ADDRESS  Y
```

#### G√©n√©ration des cl√©s

```bash
# G√©n√©rer les cl√©s pour un utilisateur
sudo fwknop --key-gen --use-gpg --gpg-recipient admin@example.com

# Ou sans GPG (moins s√©curis√©)
sudo fwknop --key-gen --key-base64-len 32 --hmac-key-base64-len 32
```

#### Utilisation c√¥t√© client

```bash
# Envoi d'un paquet SPA pour ouvrir SSH
fwknop -A tcp/2222 -a 192.168.1.100 -D serveur.example.com

# Avec cl√© personnalis√©e
fwknop -A tcp/2222 -a 192.168.1.100 -D serveur.example.com --key-base64 [votre_cl√©]

# Connexion SSH apr√®s autorisation
ssh -p 2222 admin@serveur.example.com
```

### Monitoring et alertes SSH

#### Script de surveillance des connexions

```bash
#!/bin/bash
# /usr/local/bin/ssh-monitor.sh

LOG_FILE="/var/log/auth.log"
ALERT_EMAIL="admin@example.com"
TEMP_FILE="/tmp/ssh-monitor.tmp"

# Analyser les connexions des derni√®res 10 minutes
grep "$(date -d '10 minutes ago' '+%b %d %H:%M')" $LOG_FILE | grep sshd > $TEMP_FILE

# Connexions r√©ussies
SUCCESSFUL=$(grep "Accepted" $TEMP_FILE | wc -l)

# Tentatives √©chou√©es
FAILED=$(grep "Failed" $TEMP_FILE | wc -l)

# IPs suspectes (plus de 5 √©checs)
SUSPECT_IPS=$(grep "Failed" $TEMP_FILE | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 > 5 {print $2}')

# G√©n√©ration du rapport
REPORT="/tmp/ssh-report-$(date +%Y%m%d-%H%M).txt"
echo "=== Rapport SSH $(date) ===" > $REPORT
echo "Connexions r√©ussies: $SUCCESSFUL" >> $REPORT
echo "Tentatives √©chou√©es: $FAILED" >> $REPORT
echo >> $REPORT

if [ -n "$SUSPECT_IPS" ]; then
    echo "IPs suspectes:" >> $REPORT
    for ip in $SUSPECT_IPS; do
        echo "- $ip" >> $REPORT
        # Informations Whois
        whois $ip | grep -E "(country|Country)" >> $REPORT
    done

    # Envoyer alerte si IPs suspectes
    mail -s "Alerte SSH - Activit√© suspecte" $ALERT_EMAIL < $REPORT
fi

# Nettoyage
rm -f $TEMP_FILE $REPORT
```

#### Configuration du monitoring en temps r√©el

```bash
# Installation de multitail pour monitoring en temps r√©el
sudo apt install multitail

# Monitoring SSH en temps r√©el
multitail -C -s 2 /var/log/auth.log | grep --color=always ssh

# Ou avec watch et tail
watch -n 1 'tail -20 /var/log/auth.log | grep ssh'
```

### Audit et conformit√© SSH

#### Script d'audit de configuration SSH

```bash
#!/bin/bash
# /usr/local/bin/ssh-audit.sh

CONFIG_FILE="/etc/ssh/sshd_config"
SCORE=0
MAX_SCORE=0

echo "=== Audit de s√©curit√© SSH ==="
echo "Date: $(date)"
echo "Configuration: $CONFIG_FILE"
echo

# Fonction de test
check_config() {
    local setting=$1
    local expected=$2
    local description=$3
    local weight=${4:-1}

    MAX_SCORE=$((MAX_SCORE + weight))

    current=$(grep "^$setting" $CONFIG_FILE | awk '{print $2}')

    if [ "$current" = "$expected" ]; then
        echo "‚úì $description: $current"
        SCORE=$((SCORE + weight))
    else
        echo "‚úó $description: $current (attendu: $expected)"
    fi
}

# Tests de s√©curit√©
check_config "Protocol" "2" "Version du protocole SSH" 2
check_config "PermitRootLogin" "no" "Connexion root interdite" 3
check_config "PasswordAuthentication" "no" "Authentification par mot de passe" 2
check_config "PermitEmptyPasswords" "no" "Mots de passe vides interdits" 1
check_config "MaxAuthTries" "3" "Tentatives d'authentification limit√©es" 1
check_config "X11Forwarding" "no" "Forwarding X11 d√©sactiv√©" 1
check_config "AllowTcpForwarding" "no" "Forwarding TCP contr√¥l√©" 1

# V√©rification du port
PORT=$(grep "^Port" $CONFIG_FILE | awk '{print $2}')
if [ "$PORT" != "22" ]; then
    echo "‚úì Port SSH modifi√©: $PORT"
    SCORE=$((SCORE + 2))
else
    echo "‚úó Port SSH par d√©faut (22)"
fi
MAX_SCORE=$((MAX_SCORE + 2))

# V√©rification des algorithmes cryptographiques
if grep -q "KexAlgorithms" $CONFIG_FILE; then
    echo "‚úì Algorithmes d'√©change de cl√©s sp√©cifi√©s"
    SCORE=$((SCORE + 1))
else
    echo "‚úó Algorithmes d'√©change de cl√©s non sp√©cifi√©s"
fi
MAX_SCORE=$((MAX_SCORE + 1))

# Score final
echo
echo "=== R√©sultat ==="
PERCENTAGE=$((SCORE * 100 / MAX_SCORE))
echo "Score: $SCORE/$MAX_SCORE ($PERCENTAGE%)"

if [ $PERCENTAGE -ge 90 ]; then
    echo "üü¢ Excellent niveau de s√©curit√©"
elif [ $PERCENTAGE -ge 70 ]; then
    echo "üü° Bon niveau de s√©curit√©"
else
    echo "üî¥ Niveau de s√©curit√© insuffisant"
fi
```

#### Logging avanc√© pour audit

```bash
# Configuration rsyslog pour SSH
sudo nano /etc/rsyslog.d/50-ssh.conf
```

```bash
# Logging SSH d√©taill√©
if $programname == 'sshd' then {
    # Toutes les tentatives de connexion
    *.* /var/log/ssh-audit.log

    # Connexions r√©ussies uniquement
    :msg, regex, "Accepted" /var/log/ssh-accepted.log

    # √âchecs uniquement
    :msg, regex, "Failed\|Invalid" /var/log/ssh-failed.log

    # Arr√™ter le traitement pour √©viter la duplication
    stop
}
```

```bash
# Red√©marrer rsyslog
sudo systemctl restart rsyslog

# Cr√©er la rotation des logs
sudo nano /etc/logrotate.d/ssh-audit
```

```bash
/var/log/ssh-audit.log /var/log/ssh-accepted.log /var/log/ssh-failed.log {
    daily
    missingok
    rotate 365
    compress
    delaycompress
    notifempty
    postrotate
        /usr/bin/killall -HUP rsyslogd 2> /dev/null || true
    endscript
}
```

### Techniques de d√©tection d'intrusion SSH

#### D√©tection d'attaques par dictionnaire

```bash
#!/bin/bash
# /usr/local/bin/detect-ssh-dictionary.sh

LOG_FILE="/var/log/auth.log"
THRESHOLD=10
TIME_WINDOW=300  # 5 minutes

# Chercher les tentatives avec des noms d'utilisateur courants
COMMON_USERS="admin administrator root guest test user oracle postgres mysql ftp mail"

for user in $COMMON_USERS; do
    # Compter les tentatives dans la fen√™tre de temps
    count=$(grep "$(date -d "$TIME_WINDOW seconds ago" "+%b %d %H:%M")" $LOG_FILE | \
            grep "Failed password for $user" | wc -l)

    if [ $count -gt $THRESHOLD ]; then
        echo "ALERTE: Attaque par dictionnaire d√©tect√©e pour l'utilisateur '$user' ($count tentatives)"

        # Extraire les IPs sources
        grep "Failed password for $user" $LOG_FILE | \
        grep "$(date -d "$TIME_WINDOW seconds ago" "+%b %d %H:%M")" | \
        awk '{print $(NF-3)}' | sort | uniq -c | sort -nr
    fi
done
```

#### D√©tection de connexions anormales

```bash
#!/bin/bash
# /usr/local/bin/detect-ssh-anomalies.sh

LOG_FILE="/var/log/auth.log"
WHITELIST="192.168.1.0/24 10.0.0.0/8"

# Fonction pour v√©rifier si une IP est dans la whitelist
is_whitelisted() {
    local ip=$1
    for network in $WHITELIST; do
        if ipcalc -c -n $network $ip 2>/dev/null; then
            return 0
        fi
    done
    return 1
}

# Analyser les connexions des derni√®res 24h
grep "$(date '+%b %d')" $LOG_FILE | grep "Accepted" | while read line; do
    ip=$(echo $line | awk '{print $(NF-3)}')
    user=$(echo $line | awk '{print $(NF-5)}')
    time=$(echo $line | awk '{print $1" "$2" "$3}')

    # V√©rifier si l'IP est dans la whitelist
    if ! is_whitelisted $ip; then
        echo "ALERTE: Connexion depuis IP non autoris√©e"
        echo "  IP: $ip"
        echo "  Utilisateur: $user"
        echo "  Heure: $time"
        echo "  Localisation: $(geoiplookup $ip 2>/dev/null || echo 'Inconnue')"
        echo
    fi
done
```

### Automatisation et orchestration

#### Script de d√©ploiement s√©curis√© SSH

```bash
#!/bin/bash
# /usr/local/bin/deploy-secure-ssh.sh

# Configuration s√©curis√©e SSH automatis√©e

set -e  # Arr√™t en cas d'erreur

# Variables
SSH_PORT=${1:-2222}
ADMIN_USER=${2:-admin}
BACKUP_DIR="/root/ssh-backup-$(date +%Y%m%d)"

echo "=== D√©ploiement SSH s√©curis√© ==="
echo "Port: $SSH_PORT"
echo "Utilisateur admin: $ADMIN_USER"
echo

# Sauvegarde de la configuration actuelle
mkdir -p $BACKUP_DIR
cp -r /etc/ssh/ $BACKUP_DIR/
echo "Sauvegarde cr√©√©e dans $BACKUP_DIR"

# G√©n√©ration des nouvelles cl√©s d'h√¥te
echo "G√©n√©ration des nouvelles cl√©s d'h√¥te..."
rm -f /etc/ssh/ssh_host_*
ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N ""
ssh-keygen -t rsa -b 4096 -f /etc/ssh/ssh_host_rsa_key -N ""

# Configuration s√©curis√©e
cat > /etc/ssh/sshd_config << EOF
Port $SSH_PORT
Protocol 2
HostKey /etc/ssh/ssh_host_ed25519_key
HostKey /etc/ssh/ssh_host_rsa_key

# Algorithmes s√©curis√©s
KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group16-sha512
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes256-ctr
MACs hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com

# Authentification
PermitRootLogin no
MaxAuthTries 2
MaxSessions 4
LoginGraceTime 60
PubkeyAuthentication yes
PasswordAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no

# Restrictions
AllowUsers $ADMIN_USER
UseDNS no
X11Forwarding no
AllowTcpForwarding no
GatewayPorts no
PermitTunnel no

# Monitoring
LogLevel VERBOSE
SyslogFacility AUTH

# Timeouts
ClientAliveInterval 300
ClientAliveCountMax 2

# Banni√®re
Banner /etc/ssh/banner
EOF

# Cr√©ation de la banni√®re
cat > /etc/ssh/banner << EOF
***************************************************************************
                            SYST√àME S√âCURIS√â
***************************************************************************
Acc√®s r√©serv√© aux utilisateurs autoris√©s uniquement.
Toute activit√© est surveill√©e et enregistr√©e.
***************************************************************************
EOF

# Mise √† jour du pare-feu
echo "Mise √† jour du pare-feu..."
ufw allow $SSH_PORT/tcp comment 'SSH s√©curis√©'
ufw delete allow 22/tcp 2>/dev/null || true

# Test de la configuration
sshd -t
if [ $? -eq 0 ]; then
    echo "Configuration SSH valide"
    systemctl restart ssh
    echo "Service SSH red√©marr√©"
else
    echo "ERREUR: Configuration SSH invalide"
    echo "Restauration de la sauvegarde..."
    cp -r $BACKUP_DIR/ssh/* /etc/ssh/
    systemctl restart ssh
    exit 1
fi

# Configuration de fail2ban
cat > /etc/fail2ban/jail.local << EOF
[DEFAULT]
bantime = 86400
findtime = 600
maxretry = 3

[sshd]
enabled = true
port = $SSH_PORT
filter = sshd
logpath = /var/log/auth.log
maxretry = 2
bantime = 86400
EOF

systemctl restart fail2ban

echo
echo "=== D√©ploiement termin√© ==="
echo "Port SSH: $SSH_PORT"
echo "Utilisateur autoris√©: $ADMIN_USER"
echo "IMPORTANT: Testez la connexion SSH avant de fermer cette session !"
echo "Commande de test: ssh -p $SSH_PORT $ADMIN_USER@$(hostname -I | awk '{print $1}')"
```

---

## Conclusion de la section 5.3

La s√©curisation de SSH est un √©l√©ment critique de l'infrastructure moderne. Cette section vous a fourni les connaissances et outils n√©cessaires pour :

### Comp√©tences acquises

- **Installation et configuration** d'OpenSSH avec les meilleures pratiques de s√©curit√©
- **Authentification par cl√©s** pour √©liminer les risques li√©s aux mots de passe
- **Tunneling avanc√©** pour s√©curiser les communications et contourner les restrictions
- **S√©curisation multicouche** avec fail2ban, port knocking, et monitoring

### Points cl√©s √† retenir

1. **Authentification par cl√©s** : Toujours privil√©gier les cl√©s aux mots de passe
2. **Port non-standard** : Changer le port par d√©faut r√©duit les attaques automatis√©es
3. **Principe de moindre privil√®ge** : Limiter les utilisateurs et fonctionnalit√©s autoris√©s
4. **Monitoring continu** : Surveiller les tentatives de connexion et comportements anormaux
5. **D√©fense en profondeur** : Combiner plusieurs couches de protection

### Bonnes pratiques essentielles

- D√©sactiver la connexion root directe
- Utiliser des algorithmes cryptographiques modernes
- Impl√©menter le monitoring et l'alerting
- Maintenir une documentation √† jour des acc√®s
- Effectuer des audits r√©guliers de s√©curit√©

### Prochaines √©tapes

Ces connaissances vous pr√©parent pour :
- **5.4 VPN et chiffrement** : Protection des communications sur r√©seaux non fiables
- **Modules avanc√©s** : Int√©gration dans des architectures cloud-native
- **Automatisation** : D√©ploiement et gestion √† grande √©chelle

La ma√Ætrise de SSH s√©curis√© est fondamentale pour tout administrateur syst√®me moderne et constitue la base de nombreuses autres technologies d'infrastructure.

‚è≠Ô∏è
