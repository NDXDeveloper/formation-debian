üîù Retour au [Sommaire](/SOMMAIRE.md)

# Module 6.3 : Base de donn√©es

*Tutoriel accessible aux d√©butants - Niveau : Interm√©diaire-Avanc√©*

## Introduction

Les bases de donn√©es sont le **c≈ìur de stockage** de toute application web moderne. Elles permettent de stocker, organiser et r√©cup√©rer efficacement des informations critiques comme les comptes utilisateurs, les contenus, les commandes, etc.

### Pourquoi MySQL/MariaDB vs PostgreSQL ?

**MySQL/MariaDB** :
- ‚úÖ Plus populaire dans l'h√©bergement web
- ‚úÖ Excellentes performances pour les applications web
- ‚úÖ √âcosyst√®me riche (phpMyAdmin, etc.)
- ‚úÖ Compatible avec la plupart des CMS (WordPress, Drupal)
- ‚ùå Moins de fonctionnalit√©s avanc√©es

**PostgreSQL** :
- ‚úÖ Base de donn√©es la plus avanc√©e techniquement
- ‚úÖ Excellente pour les applications complexes
- ‚úÖ Support JSON natif, extensions puissantes
- ‚úÖ Conformit√© SQL stricte
- ‚ùå Plus complexe √† administrer

> **üí° Conseil d√©butant** : Commencez par MariaDB (fork libre de MySQL) qui est plus simple, puis explorez PostgreSQL pour des projets avanc√©s.

---

## 6.3.1 MySQL/MariaDB

### Comprendre la diff√©rence MySQL vs MariaDB

**Historique simplifi√©** :
- **MySQL** : Base de donn√©es originale, maintenant propri√©t√© d'Oracle
- **MariaDB** : Fork libre de MySQL cr√©√© par les d√©veloppeurs originaux
- **Compatibilit√©** : MariaDB est 100% compatible avec MySQL
- **Avantages MariaDB** : Plus d'innovations, totalement open source

### Installation de MariaDB

#### Installation des paquets

```bash
# Mise √† jour du syst√®me
apt update

# Installation de MariaDB
apt install -y mariadb-server mariadb-client

# D√©marrer et activer MariaDB
systemctl start mariadb
systemctl enable mariadb

# V√©rifier l'installation
systemctl status mariadb
mariadb --version
```

**R√©sultat attendu** :
```
mariadb  Ver 15.1 Distrib 10.11.3-MariaDB, for debian-linux-gnu (x86_64)
```

#### S√©curisation initiale de MariaDB

La premi√®re √©tape cruciale est de s√©curiser l'installation :

```bash
# Lancer le script de s√©curisation
mysql_secure_installation
```

**R√©ponses recommand√©es pour d√©butants** :
1. **Enter current password for root** : Appuyez sur Entr√©e (pas de mot de passe initialement)
2. **Switch to unix_socket authentication** : Y (recommand√© pour la s√©curit√©)
3. **Change the root password** : Y, puis choisir un mot de passe fort
4. **Remove anonymous users** : Y (s√©curit√©)
5. **Disallow root login remotely** : Y (s√©curit√©)
6. **Remove test database** : Y (nettoyage)
7. **Reload privilege tables** : Y (appliquer les modifications)

#### Premi√®re connexion et configuration

```bash
# Se connecter √† MariaDB
mysql -u root -p

# Ou avec l'authentification unix_socket
sudo mysql
```

**Une fois connect√©, vous verrez** :
```sql
MariaDB [(none)]>
```

**Commandes de base pour d√©buter** :
```sql
-- Voir les bases de donn√©es existantes
SHOW DATABASES;

-- Voir les utilisateurs
SELECT User, Host FROM mysql.user;

-- Voir la version
SELECT VERSION();

-- Quitter
EXIT;
```

### Configuration de base MariaDB

#### Fichiers de configuration importants

```bash
# Configuration principale
ls -la /etc/mysql/

# Fichier principal de configuration
nano /etc/mysql/mariadb.conf.d/50-server.cnf
```

**Structure des fichiers de configuration** :
```
/etc/mysql/
‚îú‚îÄ‚îÄ mariadb.cnf              # Configuration principale
‚îú‚îÄ‚îÄ mariadb.conf.d/          # Configurations modulaires
‚îÇ   ‚îú‚îÄ‚îÄ 50-server.cnf        # Configuration serveur
‚îÇ   ‚îú‚îÄ‚îÄ 50-mysql-clients.cnf # Configuration clients
‚îî‚îÄ‚îÄ conf.d/                  # Configurations personnalis√©es
```

#### Configuration s√©curis√©e pour d√©buter

```bash
# Cr√©er une configuration personnalis√©e
nano /etc/mysql/conf.d/custom-security.cnf
```

```ini
[mysqld]
# === S√âCURIT√â ===

# √âcouter uniquement sur localhost (plus s√©curis√©)
bind-address = 127.0.0.1

# D√©sactiver les connexions distantes pour root
skip-networking = 0

# D√©sactiver le chargement de fichiers locaux
local-infile = 0

# Activer les logs d'erreur
log-error = /var/log/mysql/error.log

# Log des requ√™tes lentes (pour optimisation)
slow-query-log = 1
slow-query-log-file = /var/log/mysql/slow.log
long_query_time = 2

# === PERFORMANCE DE BASE ===

# Taille du cache des requ√™tes (128MB pour d√©buter)
query_cache_size = 128M
query_cache_type = 1

# Pool de buffers InnoDB (75% de la RAM d√©di√©e √† MySQL)
# Pour un serveur avec 4GB RAM et autres services
innodb_buffer_pool_size = 1G

# Logs InnoDB
innodb_log_file_size = 256M
innodb_log_buffer_size = 64M

# Connexions simultan√©es
max_connections = 100
max_connect_errors = 10

# D√©lai d'attente des connexions inactives
wait_timeout = 300
interactive_timeout = 300
```

```bash
# Red√©marrer MariaDB pour appliquer la configuration
systemctl restart mariadb

# V√©rifier que le service d√©marre correctement
systemctl status mariadb
```

### Gestion des utilisateurs et bases de donn√©es

#### Cr√©er une base de donn√©es et un utilisateur

**Sc√©nario** : Cr√©er une base de donn√©es pour une application web.

```bash
# Se connecter √† MariaDB
sudo mysql
```

```sql
-- Cr√©er une base de donn√©es pour notre application
CREATE DATABASE app_web_prod CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- Cr√©er un utilisateur d√©di√© √† cette application
CREATE USER 'appweb_user'@'localhost' IDENTIFIED BY 'MotDePasseSecurise123!';

-- Donner tous les privil√®ges sur cette base √† cet utilisateur
GRANT ALL PRIVILEGES ON app_web_prod.* TO 'appweb_user'@'localhost';

-- Cr√©er un utilisateur avec privil√®ges limit√©s (lecture seule)
CREATE USER 'appweb_readonly'@'localhost' IDENTIFIED BY 'MotDePasseLecture456!';
GRANT SELECT ON app_web_prod.* TO 'appweb_readonly'@'localhost';

-- Appliquer les modifications
FLUSH PRIVILEGES;

-- V√©rifier les utilisateurs cr√©√©s
SELECT User, Host FROM mysql.user WHERE User LIKE 'appweb%';

-- Voir les privil√®ges d'un utilisateur
SHOW GRANTS FOR 'appweb_user'@'localhost';
```

#### Test de la configuration

```bash
# Tester la connexion avec le nouvel utilisateur
mysql -u appweb_user -p app_web_prod
```

```sql
-- Une fois connect√©, cr√©er une table de test
CREATE TABLE test_connexion (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Ins√©rer des donn√©es de test
INSERT INTO test_connexion (nom, email) VALUES
('Jean Dupont', 'jean@exemple.com'),
('Marie Martin', 'marie@exemple.com');

-- V√©rifier les donn√©es
SELECT * FROM test_connexion;

-- Quitter
EXIT;
```

### Installation de phpMyAdmin (optionnel mais recommand√©)

phpMyAdmin facilite grandement l'administration de MySQL/MariaDB via une interface web.

#### Installation de phpMyAdmin

```bash
# Installer phpMyAdmin et ses d√©pendances
apt install -y phpmyadmin php-mbstring php-zip php-gd php-json php-curl

# Pendant l'installation :
# 1. Choisir "apache2" comme serveur web
# 2. Configurer la base de donn√©es : "Oui"
# 3. Entrer le mot de passe root MariaDB
```

#### Configuration s√©curis√©e de phpMyAdmin

```bash
# Cr√©er un alias s√©curis√© pour phpMyAdmin
nano /etc/apache2/conf-available/phpmyadmin-security.conf
```

```apache
# Configuration s√©curis√©e phpMyAdmin
Alias /admin-db /usr/share/phpmyadmin

<Directory /usr/share/phpmyadmin>
    Options -Indexes
    DirectoryIndex index.php

    # Restriction d'acc√®s par IP (ajustez selon vos besoins)
    <RequireAll>
        Require ip 127.0.0.1
        Require ip 192.168.1.0/24
        # Require ip VOTRE_IP_FIXE
    </RequireAll>

    # S√©curit√© additionnelle
    <Files "config.inc.php">
        Require all denied
    </Files>

    # D√©sactiver les fichiers de configuration
    <Files ~ "^(.*\.conf|.*\.sql|.*\.sh)$">
        Require all denied
    </Files>
</Directory>

# D√©sactiver la configuration par d√©faut
<Directory /usr/share/phpmyadmin/setup>
    Require all denied
</Directory>
```

```bash
# Activer la nouvelle configuration
a2enconf phpmyadmin-security

# D√©sactiver la configuration par d√©faut
a2disconf phpmyadmin

# Recharger Apache
systemctl reload apache2
```

**Acc√®s s√©curis√©** : `https://votre-serveur.com/admin-db`

---

## 6.3.2 PostgreSQL

PostgreSQL est une base de donn√©es relationnelle avanc√©e, id√©ale pour les applications n√©cessitant des fonctionnalit√©s complexes.

### Installation de PostgreSQL

```bash
# Installation de PostgreSQL et outils
apt install -y postgresql postgresql-contrib postgresql-client

# D√©marrer et activer PostgreSQL
systemctl start postgresql
systemctl enable postgresql

# V√©rifier l'installation
systemctl status postgresql
sudo -u postgres psql -c "SELECT version();"
```

### Configuration initiale de PostgreSQL

#### Premi√®re connexion et configuration

```bash
# Se connecter en tant qu'utilisateur postgres
sudo -i -u postgres

# Acc√©der √† l'interface PostgreSQL
psql
```

**Une fois dans PostgreSQL** :
```sql
-- Voir les bases de donn√©es
\l

-- Voir les utilisateurs
\du

-- Cr√©er un mot de passe pour l'utilisateur postgres
ALTER USER postgres PASSWORD 'MotDePasseSecurise789!';

-- Quitter PostgreSQL
\q

-- Quitter la session postgres
exit
```

#### Configuration des acc√®s

```bash
# √âditer la configuration des connexions
nano /etc/postgresql/15/main/pg_hba.conf
```

**Configuration s√©curis√©e pour d√©buter** :
```bash
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# "local" pour connexions Unix domain socket
local   all             postgres                                peer
local   all             all                                     md5

# IPv4 local connections:
host    all             all             127.0.0.1/32            md5

# IPv6 local connections:
host    all             all             ::1/128                 md5

# Connexions depuis le r√©seau local (ajustez selon vos besoins)
# host    all             all             192.168.1.0/24          md5
```

#### Configuration du serveur PostgreSQL

```bash
# √âditer la configuration principale
nano /etc/postgresql/15/main/postgresql.conf
```

**Optimisations de base** :
```bash
# === CONNEXIONS ===
listen_addresses = 'localhost'         # √âcouter seulement en local
port = 5432                            # Port par d√©faut
max_connections = 100                  # Connexions simultan√©es

# === M√âMOIRE ===
shared_buffers = 256MB                 # 25% de la RAM pour d√©buter
effective_cache_size = 1GB             # Cache estim√© du syst√®me
work_mem = 4MB                         # M√©moire par op√©ration
maintenance_work_mem = 64MB            # M√©moire pour maintenance

# === LOGS ===
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_min_duration_statement = 1000      # Log requ√™tes > 1 seconde

# === PERFORMANCE ===
checkpoint_timeout = 10min
max_wal_size = 2GB
min_wal_size = 1GB
```

```bash
# Red√©marrer PostgreSQL pour appliquer les modifications
systemctl restart postgresql
```

### Gestion des utilisateurs PostgreSQL

#### Cr√©er une base de donn√©es et un utilisateur

```bash
# Se connecter en tant que postgres
sudo -i -u postgres
```

```sql
-- Cr√©er une base de donn√©es
CREATE DATABASE app_postgresql_prod
    WITH ENCODING 'UTF8'
    LC_COLLATE='fr_FR.UTF-8'
    LC_CTYPE='fr_FR.UTF-8'
    TEMPLATE=template0;

-- Cr√©er un utilisateur pour l'application
CREATE USER app_pg_user WITH PASSWORD 'MotDePasseApp123!';

-- Donner tous les privil√®ges sur la base √† cet utilisateur
GRANT ALL PRIVILEGES ON DATABASE app_postgresql_prod TO app_pg_user;

-- Cr√©er un utilisateur en lecture seule
CREATE USER app_pg_readonly WITH PASSWORD 'MotDePasseLecture456!';
GRANT CONNECT ON DATABASE app_postgresql_prod TO app_pg_readonly;

-- Se connecter √† la base pour donner les privil√®ges sur les tables
\c app_postgresql_prod

-- Donner les privil√®ges de lecture sur toutes les tables existantes et futures
GRANT USAGE ON SCHEMA public TO app_pg_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_pg_readonly;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO app_pg_readonly;

-- Quitter
\q
exit
```

#### Test de la configuration PostgreSQL

```bash
# Tester la connexion avec le nouvel utilisateur
psql -h localhost -U app_pg_user -d app_postgresql_prod
```

```sql
-- Cr√©er une table de test
CREATE TABLE test_postgresql (
    id SERIAL PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    donnees_json JSONB,
    date_creation TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Ins√©rer des donn√©es avec JSON (sp√©cialit√© de PostgreSQL)
INSERT INTO test_postgresql (nom, email, donnees_json) VALUES
('Alice Dubois', 'alice@exemple.com', '{"age": 30, "ville": "Paris", "hobbies": ["lecture", "sport"]}'),
('Bob Martin', 'bob@exemple.com', '{"age": 25, "ville": "Lyon", "hobbies": ["musique", "cin√©ma"]}');

-- Requ√™te avec recherche JSON
SELECT nom, donnees_json->'ville' as ville
FROM test_postgresql
WHERE donnees_json->>'age' = '30';

-- Quitter
\q
```

### Installation de pgAdmin (interface web pour PostgreSQL)

```bash
# Installer pgAdmin via APT (plus simple)
apt install -y pgadmin4 pgadmin4-apache2

# Configuration initiale
sudo -u postgres createuser --interactive pgadmin
# R√©pondre "y" pour superutilisateur

# Configurer Apache pour pgAdmin
a2enconf pgadmin4

# Red√©marrer Apache
systemctl reload apache2
```

**Acc√®s** : `https://votre-serveur.com/pgadmin4`

---

## 6.3.3 Configuration et optimisation

### Optimisation de MariaDB

#### Configuration de production pour MariaDB

```bash
# Cr√©er une configuration optimis√©e
nano /etc/mysql/conf.d/production-optimized.cnf
```

```ini
[mysqld]
# === OPTIMISATIONS M√âMOIRE ===

# InnoDB Buffer Pool (75-80% de la RAM d√©di√©e √† MySQL)
# Pour un serveur avec 4GB RAM total, 2GB pour MySQL
innodb_buffer_pool_size = 2G
innodb_buffer_pool_instances = 2

# Query Cache (attention : deprecated dans MySQL 8.0+)
query_cache_type = 1
query_cache_size = 256M
query_cache_limit = 2M

# Caches des tables
table_open_cache = 4000
table_definition_cache = 1000

# === OPTIMISATIONS INNODB ===

# Logs de transaction
innodb_log_file_size = 512M
innodb_log_buffer_size = 128M
innodb_flush_log_at_trx_commit = 2

# Fichiers par table (recommand√©)
innodb_file_per_table = 1

# Compression des pages
innodb_page_size = 16k

# Threads d'√©criture
innodb_write_io_threads = 4
innodb_read_io_threads = 4

# === OPTIMISATIONS CONNEXIONS ===

# Connexions simultan√©es
max_connections = 200
max_connect_errors = 100000

# Timeouts
wait_timeout = 600
interactive_timeout = 600
connect_timeout = 10

# === OPTIMISATIONS REQU√äTES ===

# Tailles des buffers pour les JOIN et ORDER BY
join_buffer_size = 8M
sort_buffer_size = 8M
read_buffer_size = 2M
read_rnd_buffer_size = 4M

# Taille des paquets r√©seau
max_allowed_packet = 64M

# === LOGS ET MONITORING ===

# Logs des requ√™tes lentes
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 1
log_queries_not_using_indexes = 1

# Logs g√©n√©raux (attention √† la performance)
general_log = 0
general_log_file = /var/log/mysql/general.log

# Logs des erreurs
log_error = /var/log/mysql/error.log
log_warnings = 2
```

#### Outils d'optimisation MariaDB

**Installation de MySQLTuner** :
```bash
# T√©l√©charger MySQLTuner
wget http://mysqltuner.pl/ -O mysqltuner.pl

# Rendre le script ex√©cutable
chmod +x mysqltuner.pl

# Ex√©cuter l'analyse (apr√®s quelques jours d'utilisation)
perl mysqltuner.pl
```

**Analyse des performances** :
```bash
# Script de monitoring MySQL
nano /usr/local/bin/mysql-performance-monitor
```

```bash
#!/bin/bash
# Monitor de performance MySQL/MariaDB

echo "=== PERFORMANCE MYSQL/MARIADB ==="
echo "Date: $(date)"
echo

# Informations g√©n√©rales
mysql -e "
SELECT
    'Version' as Info, VERSION() as Value
UNION ALL SELECT
    'Uptime (hours)', ROUND(UPTIME/3600, 2)
UNION ALL SELECT
    'Total Connections', VARIABLE_VALUE
    FROM INFORMATION_SCHEMA.GLOBAL_STATUS
    WHERE VARIABLE_NAME = 'CONNECTIONS'
UNION ALL SELECT
    'Active Connections', VARIABLE_VALUE
    FROM INFORMATION_SCHEMA.GLOBAL_STATUS
    WHERE VARIABLE_NAME = 'THREADS_CONNECTED';
"

echo
echo "=== TOP 5 REQU√äTES LENTES ==="
# Afficher les requ√™tes les plus lentes (n√©cessite slow query log)
if [ -f /var/log/mysql/slow.log ]; then
    mysqldumpslow -t 5 /var/log/mysql/slow.log | head -20
else
    echo "Slow query log non activ√©"
fi

echo
echo "=== UTILISATION INNODB ==="
mysql -e "
SELECT
    'Buffer Pool Size (MB)' as Metric,
    ROUND(@@innodb_buffer_pool_size/1024/1024, 2) as Value
UNION ALL SELECT
    'Buffer Pool Usage (%)',
    ROUND(
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') * 100 /
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'),
        2
    );
"
```

```bash
chmod +x /usr/local/bin/mysql-performance-monitor

# Ex√©cuter le monitoring
mysql-performance-monitor
```

### Optimisation de PostgreSQL

#### Configuration de production PostgreSQL

```bash
nano /etc/postgresql/15/main/postgresql.conf
```

```bash
# === OPTIMISATIONS M√âMOIRE POSTGRESQL ===

# M√©moire partag√©e (25% de la RAM totale)
shared_buffers = 1GB

# Cache estim√© du syst√®me (75% de la RAM totale)
effective_cache_size = 3GB

# M√©moire de travail par op√©ration
work_mem = 16MB

# M√©moire pour les op√©rations de maintenance
maintenance_work_mem = 256MB

# === OPTIMISATIONS DISQUE ===

# Points de contr√¥le (checkpoints)
checkpoint_timeout = 15min
checkpoint_completion_target = 0.9
max_wal_size = 4GB
min_wal_size = 2GB

# √âcriture WAL
wal_buffers = 16MB
wal_writer_delay = 200ms

# === OPTIMISATIONS REQU√äTES ===

# Co√ªt d'acc√®s s√©quentiel vs al√©atoire
random_page_cost = 1.1  # Pour SSD, 4.0 pour HDD
seq_page_cost = 1.0

# Statistiques des requ√™tes
default_statistics_target = 100

# === CONNEXIONS ===
max_connections = 100
superuser_reserved_connections = 3

# === LOGS AVANC√âS ===
log_min_duration_statement = 500
log_checkpoints = on
log_connections = on
log_disconnections = on
log_lock_waits = on

# Analyse automatique des requ√™tes
auto_explain.log_min_duration = 1000
```

#### Monitoring PostgreSQL

```bash
# Script de monitoring PostgreSQL
nano /usr/local/bin/postgresql-performance-monitor
```

```bash
#!/bin/bash
# Monitor de performance PostgreSQL

echo "=== PERFORMANCE POSTGRESQL ==="
echo "Date: $(date)"
echo

# Informations g√©n√©rales
sudo -u postgres psql -c "
SELECT
    'Version' as info,
    version() as value
UNION ALL
SELECT
    'Uptime',
    now() - pg_postmaster_start_time() as value
UNION ALL
SELECT
    'Active Connections',
    count(*)::text as value
FROM pg_stat_activity
WHERE state = 'active';
"

echo
echo "=== TOP 5 REQU√äTES LES PLUS CO√õTEUSES ==="
sudo -u postgres psql -c "
SELECT
    query,
    calls,
    total_time,
    mean_time,
    rows
FROM pg_stat_statements
ORDER BY total_time DESC
LIMIT 5;" 2>/dev/null || echo "Extension pg_stat_statements non install√©e"

echo
echo "=== UTILISATION CACHE ==="
sudo -u postgres psql -c "
SELECT
    'Shared Buffers Hit Ratio (%)' as metric,
    round(
        100.0 * sum(blks_hit) / (sum(blks_hit) + sum(blks_read)), 2
    ) as value
FROM pg_stat_database;"

echo
echo "=== TAILLE DES BASES DE DONN√âES ==="
sudo -u postgres psql -c "
SELECT
    datname as database,
    pg_size_pretty(pg_database_size(datname)) as size
FROM pg_database
WHERE datname NOT IN ('template0', 'template1', 'postgres')
ORDER BY pg_database_size(datname) DESC;"
```

```bash
chmod +x /usr/local/bin/postgresql-performance-monitor

# Installer l'extension pg_stat_statements pour un meilleur monitoring
sudo -u postgres psql -c "CREATE EXTENSION IF NOT EXISTS pg_stat_statements;"
```

---

## 6.3.4 Sauvegarde et restauration

### Strat√©gies de sauvegarde

#### Types de sauvegardes

**Sauvegarde logique** :
- Export/Import des donn√©es au format SQL
- Portable entre versions et syst√®mes
- Plus lente pour de gros volumes

**Sauvegarde physique** :
- Copie des fichiers de base de donn√©es
- Tr√®s rapide pour de gros volumes
- D√©pendante de la version et l'architecture

### Sauvegarde MariaDB/MySQL

#### Sauvegarde avec mysqldump

```bash
# Script de sauvegarde automatis√©
nano /usr/local/bin/mysql-backup
```

```bash
#!/bin/bash
# Script de sauvegarde automatis√© MySQL/MariaDB

# Configuration
BACKUP_DIR="/var/backups/mysql"
MYSQL_USER="root"
MYSQL_PASSWORD="votre_mot_de_passe_root"
DATE=$(date +"%Y%m%d_%H%M%S")
RETENTION_DAYS=30

# Cr√©er le r√©pertoire de sauvegarde
mkdir -p $BACKUP_DIR

# Fonction de log
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a $BACKUP_DIR/backup.log
}

log_message "D√©but de la sauvegarde MySQL"

# Obtenir la liste des bases de donn√©es (exclure les bases syst√®me)
DATABASES=$(mysql -u$MYSQL_USER -p$MYSQL_PASSWORD -e "SHOW DATABASES;" | grep -Ev "(Database|information_schema|performance_schema|mysql|sys)")

# Sauvegarder chaque base de donn√©es
for db in $DATABASES; do
    if [ "$db" != "" ]; then
        log_message "Sauvegarde de la base: $db"

        # Sauvegarde avec compression
        mysqldump -u$MYSQL_USER -p$MYSQL_PASSWORD \
            --routines \
            --triggers \
            --single-transaction \
            --lock-tables=false \
            --add-drop-database \
            --databases $db | gzip > $BACKUP_DIR/${db}_${DATE}.sql.gz

        if [ $? -eq 0 ]; then
            log_message "Sauvegarde de $db r√©ussie"
        else
            log_message "ERREUR: Sauvegarde de $db √©chou√©e"
        fi
    fi
done

# Sauvegarde compl√®te de toutes les bases
log_message "Sauvegarde compl√®te de toutes les bases"
mysqldump -u$MYSQL_USER -p$MYSQL_PASSWORD \
    --all-databases \
    --routines \
    --triggers \
    --single-transaction \
    --lock-tables=false | gzip > $BACKUP_DIR/full_backup_${DATE}.sql.gz

# Nettoyage des anciennes sauvegardes
log_message "Nettoyage des sauvegardes anciennes (>$RETENTION_DAYS jours)"
find $BACKUP_DIR -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete

# Statistiques
BACKUP_SIZE=$(du -sh $BACKUP_DIR | cut -f1)
log_message "Sauvegarde termin√©e - Taille totale: $BACKUP_SIZE"

# V√©rifier l'int√©grit√© de la derni√®re sauvegarde
LATEST_BACKUP=$(ls -t $BACKUP_DIR/full_backup_*.sql.gz | head -1)
if gzip -t $LATEST_BACKUP 2>/dev/null; then
    log_message "V√©rification d'int√©grit√©: OK"
else
    log_message "ERREUR: Probl√®me d'int√©grit√© de la sauvegarde"
fi
```

#### Configuration s√©curis√©e des mots de passe

```bash
# Cr√©er un fichier de configuration MySQL s√©curis√©
nano /root/.my.cnf
```

```ini
[client]
user=root
password=votre_mot_de_passe_root

[mysql]
user=root
password=votre_mot_de_passe_root

[mysqldump]
user=root
password=votre_mot_de_passe_root
```

```bash
# S√©curiser le fichier
chmod 600 /root/.my.cnf

# Modifier le script pour utiliser ce fichier
nano /usr/local/bin/mysql-backup
```

**Supprimer les variables de mot de passe et utiliser** :
```bash
# Les commandes deviennent plus simples
mysql -e "SHOW DATABASES;"
mysqldump --all-databases --routines --triggers --single-transaction
```

```bash
# Rendre le script ex√©cutable
chmod +x /usr/local/bin/mysql-backup

# Tester le script
/usr/local/bin/mysql-backup
```

#### Restauration MariaDB/MySQL

```bash
# Script de restauration
nano /usr/local/bin/mysql-restore
```

```bash
#!/bin/bash
# Script de restauration MySQL/MariaDB

BACKUP_DIR="/var/backups/mysql"

# Fonction d'aide
show_help() {
    echo "Usage: $0 [OPTIONS]"
    echo "Options:"
    echo "  -f <fichier>  : Fichier de sauvegarde √† restaurer"
    echo "  -d <database> : Restaurer une base sp√©cifique"
    echo "  -l           : Lister les sauvegardes disponibles"
    echo "  -h           : Afficher cette aide"
}

# Lister les sauvegardes
list_backups() {
    echo "=== SAUVEGARDES DISPONIBLES ==="
    ls -lh $BACKUP_DIR/*.sql.gz 2>/dev/null | awk '{print $9, $5, $6, $7, $8}'
}

# Restauration d'une base sp√©cifique
restore_database() {
    local backup_file=$1
    local database=$2

    echo "Restauration de $database depuis $backup_file"
    echo "ATTENTION: Cette op√©ration va √©craser la base existante!"
    read -p "Continuer ? (y/N): " confirm

    if [[ $confirm == [yY] ]]; then
        # Cr√©er une sauvegarde de s√©curit√© avant restauration
        echo "Cr√©ation d'une sauvegarde de s√©curit√©..."
        mysqldump --databases $database | gzip > $BACKUP_DIR/${database}_before_restore_$(date +%Y%m%d_%H%M%S).sql.gz

        # Restaurer depuis la sauvegarde
        echo "Restauration en cours..."
        zcat $backup_file | mysql

        if [ $? -eq 0 ]; then
            echo "Restauration r√©ussie!"
        else
            echo "ERREUR: Restauration √©chou√©e"
            exit 1
        fi
    else
        echo "Restauration annul√©e"
        exit 0
    fi
}

# Traitement des arguments
while getopts "f:d:lh" opt; do
    case $opt in
        f) BACKUP_FILE="$OPTARG" ;;
        d) DATABASE="$OPTARG" ;;
        l) list_backups; exit 0 ;;
        h) show_help; exit 0 ;;
        \?) echo "Option invalide: -$OPTARG"; show_help; exit 1 ;;
    esac
done

# V√©rifications
if [ -z "$BACKUP_FILE" ]; then
    echo "Fichier de sauvegarde requis (-f)"
    show_help
    exit 1
fi

if [ ! -f "$BACKUP_FILE" ]; then
    echo "Fichier de sauvegarde introuvable: $BACKUP_FILE"
    exit 1
fi

# Ex√©cuter la restauration
if [ -n "$DATABASE" ]; then
    restore_database "$BACKUP_FILE" "$DATABASE"
else
    echo "Restauration compl√®te depuis $BACKUP_FILE"
    echo "ATTENTION: Toutes les bases seront √©cras√©es!"
    read -p "Continuer ? (y/N): " confirm

    if [[ $confirm == [yY] ]]; then
        echo "Restauration compl√®te en cours..."
        zcat "$BACKUP_FILE" | mysql
        echo "Restauration compl√®te termin√©e!"
    fi
fi
```

```bash
# Rendre le script ex√©cutable
chmod +x /usr/local/bin/mysql-restore

# Exemples d'utilisation :
# Lister les sauvegardes
mysql-restore -l

# Restaurer une base sp√©cifique
mysql-restore -f /var/backups/mysql/app_web_prod_20231201_120000.sql.gz -d app_web_prod

# Restauration compl√®te
mysql-restore -f /var/backups/mysql/full_backup_20231201_120000.sql.gz
```

### Sauvegarde PostgreSQL

#### Sauvegarde avec pg_dump

```bash
# Script de sauvegarde PostgreSQL
nano /usr/local/bin/postgresql-backup
```

```bash
#!/bin/bash
# Script de sauvegarde PostgreSQL

# Configuration
BACKUP_DIR="/var/backups/postgresql"
PG_USER="postgres"
DATE=$(date +"%Y%m%d_%H%M%S")
RETENTION_DAYS=30

# Cr√©er le r√©pertoire de sauvegarde
mkdir -p $BACKUP_DIR

# Fonction de log
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a $BACKUP_DIR/backup.log
}

log_message "D√©but de la sauvegarde PostgreSQL"

# Obtenir la liste des bases de donn√©es (exclure les bases syst√®me)
DATABASES=$(sudo -u $PG_USER psql -t -c "SELECT datname FROM pg_database WHERE datistemplate = false AND datname != 'postgres';" | grep -v '^ | tr -d ' ')

# Sauvegarder chaque base de donn√©es
for db in $DATABASES; do
    if [ "$db" != "" ]; then
        log_message "Sauvegarde de la base: $db"

        # Sauvegarde au format custom (recommand√© pour PostgreSQL)
        sudo -u $PG_USER pg_dump -Fc -b -v -f $BACKUP_DIR/${db}_${DATE}.dump $db

        # Sauvegarde au format SQL (pour compatibilit√©)
        sudo -u $PG_USER pg_dump -f - $db | gzip > $BACKUP_DIR/${db}_${DATE}.sql.gz

        if [ $? -eq 0 ]; then
            log_message "Sauvegarde de $db r√©ussie"
        else
            log_message "ERREUR: Sauvegarde de $db √©chou√©e"
        fi
    fi
done

# Sauvegarde globale (inclut les r√¥les et tablespaces)
log_message "Sauvegarde globale avec pg_dumpall"
sudo -u $PG_USER pg_dumpall | gzip > $BACKUP_DIR/globals_${DATE}.sql.gz

# Sauvegarde des r√¥les uniquement
sudo -u $PG_USER pg_dumpall --roles-only > $BACKUP_DIR/roles_${DATE}.sql

# Nettoyage des anciennes sauvegardes
log_message "Nettoyage des sauvegardes anciennes (>$RETENTION_DAYS jours)"
find $BACKUP_DIR -name "*.dump" -mtime +$RETENTION_DAYS -delete
find $BACKUP_DIR -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete
find $BACKUP_DIR -name "*.sql" -mtime +$RETENTION_DAYS -delete

# Statistiques
BACKUP_SIZE=$(du -sh $BACKUP_DIR | cut -f1)
log_message "Sauvegarde termin√©e - Taille totale: $BACKUP_SIZE"

# V√©rifier l'int√©grit√© de la derni√®re sauvegarde
LATEST_DUMP=$(ls -t $BACKUP_DIR/*.dump | head -1)
if [ -f "$LATEST_DUMP" ]; then
    if sudo -u $PG_USER pg_restore -l "$LATEST_DUMP" > /dev/null 2>&1; then
        log_message "V√©rification d'int√©grit√©: OK"
    else
        log_message "ERREUR: Probl√®me d'int√©grit√© de la sauvegarde"
    fi
fi
```

#### Restauration PostgreSQL

```bash
# Script de restauration PostgreSQL
nano /usr/local/bin/postgresql-restore
```

```bash
#!/bin/bash
# Script de restauration PostgreSQL

BACKUP_DIR="/var/backups/postgresql"
PG_USER="postgres"

# Fonction d'aide
show_help() {
    echo "Usage: $0 [OPTIONS]"
    echo "Options:"
    echo "  -f <fichier>  : Fichier de sauvegarde √† restaurer (.dump ou .sql.gz)"
    echo "  -d <database> : Nom de la base de destination"
    echo "  -c           : Cr√©er la base si elle n'existe pas"
    echo "  -l           : Lister les sauvegardes disponibles"
    echo "  -h           : Afficher cette aide"
}

# Lister les sauvegardes
list_backups() {
    echo "=== SAUVEGARDES POSTGRESQL DISPONIBLES ==="
    echo "Fichiers .dump (format custom):"
    ls -lh $BACKUP_DIR/*.dump 2>/dev/null | awk '{print $9, $5, $6, $7, $8}' || echo "Aucun fichier .dump"
    echo
    echo "Fichiers .sql.gz (format SQL):"
    ls -lh $BACKUP_DIR/*.sql.gz 2>/dev/null | awk '{print $9, $5, $6, $7, $8}' || echo "Aucun fichier .sql.gz"
}

# Restauration depuis un fichier .dump
restore_from_dump() {
    local backup_file=$1
    local database=$2
    local create_db=$3

    echo "Restauration depuis le fichier dump: $backup_file"

    if [ "$create_db" = "true" ]; then
        echo "Cr√©ation de la base de donn√©es $database"
        sudo -u $PG_USER createdb $database
    fi

    echo "ATTENTION: Cette op√©ration va modifier la base existante!"
    read -p "Continuer ? (y/N): " confirm

    if [[ $confirm == [yY] ]]; then
        # Sauvegarde de s√©curit√©
        echo "Cr√©ation d'une sauvegarde de s√©curit√©..."
        sudo -u $PG_USER pg_dump -Fc $database > $BACKUP_DIR/${database}_before_restore_$(date +%Y%m%d_%H%M%S).dump

        # Restauration
        echo "Restauration en cours..."
        sudo -u $PG_USER pg_restore -d $database -v --clean --if-exists $backup_file

        if [ $? -eq 0 ]; then
            echo "Restauration r√©ussie!"
        else
            echo "ERREUR: Restauration √©chou√©e"
        fi
    fi
}

# Restauration depuis un fichier SQL
restore_from_sql() {
    local backup_file=$1
    local database=$2
    local create_db=$3

    echo "Restauration depuis le fichier SQL: $backup_file"

    if [ "$create_db" = "true" ]; then
        echo "Cr√©ation de la base de donn√©es $database"
        sudo -u $PG_USER createdb $database
    fi

    read -p "Continuer ? (y/N): " confirm

    if [[ $confirm == [yY] ]]; then
        echo "Restauration en cours..."
        zcat $backup_file | sudo -u $PG_USER psql -d $database

        if [ $? -eq 0 ]; then
            echo "Restauration r√©ussie!"
        else
            echo "ERREUR: Restauration √©chou√©e"
        fi
    fi
}

# Variables par d√©faut
CREATE_DB=false

# Traitement des arguments
while getopts "f:d:clh" opt; do
    case $opt in
        f) BACKUP_FILE="$OPTARG" ;;
        d) DATABASE="$OPTARG" ;;
        c) CREATE_DB=true ;;
        l) list_backups; exit 0 ;;
        h) show_help; exit 0 ;;
        \?) echo "Option invalide: -$OPTARG"; show_help; exit 1 ;;
    esac
done

# V√©rifications
if [ -z "$BACKUP_FILE" ]; then
    echo "Fichier de sauvegarde requis (-f)"
    show_help
    exit 1
fi

if [ ! -f "$BACKUP_FILE" ]; then
    echo "Fichier de sauvegarde introuvable: $BACKUP_FILE"
    exit 1
fi

if [ -z "$DATABASE" ]; then
    echo "Nom de base de donn√©es requis (-d)"
    show_help
    exit 1
fi

# D√©terminer le type de fichier et restaurer
if [[ "$BACKUP_FILE" == *.dump ]]; then
    restore_from_dump "$BACKUP_FILE" "$DATABASE" "$CREATE_DB"
elif [[ "$BACKUP_FILE" == *.sql.gz ]]; then
    restore_from_sql "$BACKUP_FILE" "$DATABASE" "$CREATE_DB"
else
    echo "Type de fichier non support√©. Utilisez .dump ou .sql.gz"
    exit 1
fi
```

```bash
# Rendre les scripts ex√©cutables
chmod +x /usr/local/bin/postgresql-backup
chmod +x /usr/local/bin/postgresql-restore

# Exemples d'utilisation :
# Lister les sauvegardes
postgresql-restore -l

# Restaurer avec cr√©ation de base
postgresql-restore -f /var/backups/postgresql/app_postgresql_prod_20231201_120000.dump -d app_test -c
```

### Automatisation des sauvegardes

#### Configuration de cron pour les sauvegardes

```bash
# √âditer la crontab root
crontab -e
```

```bash
# Sauvegardes automatiques

# MySQL/MariaDB : tous les jours √† 2h du matin
0 2 * * * /usr/local/bin/mysql-backup >/dev/null 2>&1

# PostgreSQL : tous les jours √† 3h du matin
0 3 * * * /usr/local/bin/postgresql-backup >/dev/null 2>&1

# Sauvegarde hebdomadaire compl√®te le dimanche √† 1h
0 1 * * 0 /usr/local/bin/mysql-backup && /usr/local/bin/postgresql-backup

# Nettoyage des logs de sauvegarde (garder 90 jours)
0 4 * * * find /var/backups -name "backup.log" -mtime +90 -delete
```

#### Surveillance des sauvegardes

```bash
# Script de v√©rification des sauvegardes
nano /usr/local/bin/check-backups
```

```bash
#!/bin/bash
# V√©rification de l'√©tat des sauvegardes

MYSQL_BACKUP_DIR="/var/backups/mysql"
POSTGRESQL_BACKUP_DIR="/var/backups/postgresql"
LOG_FILE="/var/log/backup-check.log"
ALERT_EMAIL="admin@exemple.com"

# Fonction de log
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a $LOG_FILE
}

check_mysql_backups() {
    log_message "V√©rification des sauvegardes MySQL"

    # V√©rifier si une sauvegarde a √©t√© faite aujourd'hui
    TODAY=$(date +%Y%m%d)
    RECENT_BACKUP=$(find $MYSQL_BACKUP_DIR -name "*${TODAY}*.sql.gz" | head -1)

    if [ -n "$RECENT_BACKUP" ]; then
        # V√©rifier l'int√©grit√©
        if gzip -t "$RECENT_BACKUP" 2>/dev/null; then
            log_message "‚úì Sauvegarde MySQL r√©cente et int√®gre: $RECENT_BACKUP"
        else
            log_message "‚úó ERREUR: Sauvegarde MySQL corrompue: $RECENT_BACKUP"
            return 1
        fi
    else
        log_message "‚úó ALERTE: Aucune sauvegarde MySQL r√©cente trouv√©e"
        return 1
    fi

    return 0
}

check_postgresql_backups() {
    log_message "V√©rification des sauvegardes PostgreSQL"

    TODAY=$(date +%Y%m%d)
    RECENT_BACKUP=$(find $POSTGRESQL_BACKUP_DIR -name "*${TODAY}*.dump" | head -1)

    if [ -n "$RECENT_BACKUP" ]; then
        # V√©rifier l'int√©grit√© avec pg_restore
        if sudo -u postgres pg_restore -l "$RECENT_BACKUP" > /dev/null 2>&1; then
            log_message "‚úì Sauvegarde PostgreSQL r√©cente et int√®gre: $RECENT_BACKUP"
        else
            log_message "‚úó ERREUR: Sauvegarde PostgreSQL corrompue: $RECENT_BACKUP"
            return 1
        fi
    else
        log_message "‚úó ALERTE: Aucune sauvegarde PostgreSQL r√©cente trouv√©e"
        return 1
    fi

    return 0
}

# V√©rification de l'espace disque
check_disk_space() {
    log_message "V√©rification de l'espace disque"

    MYSQL_USAGE=$(df $MYSQL_BACKUP_DIR | tail -1 | awk '{print $5}' | sed 's/%//')
    POSTGRESQL_USAGE=$(df $POSTGRESQL_BACKUP_DIR | tail -1 | awk '{print $5}' | sed 's/%//')

    if [ $MYSQL_USAGE -gt 85 ]; then
        log_message "‚úó ALERTE: Espace disque faible pour MySQL ($MYSQL_USAGE%)"
        return 1
    fi

    if [ $POSTGRESQL_USAGE -gt 85 ]; then
        log_message "‚úó ALERTE: Espace disque faible pour PostgreSQL ($POSTGRESQL_USAGE%)"
        return 1
    fi

    log_message "‚úì Espace disque suffisant"
    return 0
}

# Ex√©cution des v√©rifications
ERRORS=0

check_mysql_backups || ERRORS=$((ERRORS + 1))
check_postgresql_backups || ERRORS=$((ERRORS + 1))
check_disk_space || ERRORS=$((ERRORS + 1))

# Envoyer une alerte si des erreurs sont d√©tect√©es
if [ $ERRORS -gt 0 ]; then
    log_message "ALERTE: $ERRORS erreur(s) d√©tect√©e(s) dans les sauvegardes"

    # Envoyer un email d'alerte (si mail est configur√©)
    if command -v mail >/dev/null; then
        tail -20 $LOG_FILE | mail -s "Alerte Sauvegarde - $HOSTNAME" $ALERT_EMAIL
    fi

    exit 1
else
    log_message "‚úì Toutes les v√©rifications de sauvegarde sont OK"
    exit 0
fi
```

```bash
chmod +x /usr/local/bin/check-backups

# Ajouter √† cron pour v√©rification quotidienne
crontab -e
```

```bash
# V√©rification des sauvegardes tous les jours √† 6h
0 6 * * * /usr/local/bin/check-backups
```

---

## 6.3.5 R√©plication et clustering

### Concepts de haute disponibilit√©

#### Types de r√©plication

**R√©plication Master-Slave (Lecture seule)** :
- Un serveur principal (master) pour les √©critures
- Un ou plusieurs serveurs secondaires (slaves) pour les lectures
- R√©plication asynchrone des donn√©es

**R√©plication Master-Master (Bidirectionnelle)** :
- Plusieurs serveurs peuvent recevoir des √©critures
- Plus complexe √† configurer et g√©rer
- Risque de conflits √† g√©rer

**Clustering (Galera pour MySQL)** :
- R√©plication synchrone multi-master
- Haute disponibilit√© et performance
- Configuration plus complexe

### R√©plication MySQL/MariaDB Master-Slave

#### Configuration du serveur Master

```bash
# √âditer la configuration du serveur master
nano /etc/mysql/conf.d/replication-master.cnf
```

```ini
[mysqld]
# === CONFIGURATION MASTER ===

# ID unique du serveur (doit √™tre diff√©rent sur chaque serveur)
server-id = 1

# Activer les logs binaires
log-bin = /var/log/mysql/mysql-bin.log
binlog_format = ROW

# Bases de donn√©es √† r√©pliquer (optionnel, par d√©faut toutes)
# binlog-do-db = app_web_prod
# binlog-ignore-db = mysql

# Dur√©e de conservation des logs binaires (7 jours)
expire_logs_days = 7

# Taille maximale des logs binaires
max_binlog_size = 500M

# Synchronisation des logs (s√©curit√© vs performance)
sync_binlog = 1

# Cache des requ√™tes (√† d√©sactiver en r√©plication)
query_cache_type = 0
query_cache_size = 0
```

```bash
# Red√©marrer MySQL sur le master
systemctl restart mariadb

# V√©rifier que les logs binaires sont activ√©s
mysql -e "SHOW VARIABLES LIKE 'log_bin';"
mysql -e "SHOW MASTER STATUS;"
```

#### Cr√©er un utilisateur de r√©plication

```bash
mysql
```

```sql
-- Cr√©er un utilisateur d√©di√© √† la r√©plication
CREATE USER 'replica_user'@'%' IDENTIFIED BY 'MotDePasseReplication123!';

-- Donner les privil√®ges de r√©plication
GRANT REPLICATION SLAVE ON *.* TO 'replica_user'@'%';

-- Appliquer les modifications
FLUSH PRIVILEGES;

-- V√©rifier l'√©tat du master
SHOW MASTER STATUS;
-- Noter les valeurs File et Position pour la configuration du slave
```

#### Configuration du serveur Slave

**Sur le serveur slave** :
```bash
# Configuration du serveur slave
nano /etc/mysql/conf.d/replication-slave.cnf
```

```ini
[mysqld]
# === CONFIGURATION SLAVE ===

# ID unique du serveur (diff√©rent du master)
server-id = 2

# Logs de relais pour la r√©plication
relay-log = /var/log/mysql/relay-bin.log
relay-log-index = /var/log/mysql/relay-bin.index

# Lectures seules sur le slave (s√©curit√©)
read_only = 1

# Logs des mises √† jour sur le slave
log_slave_updates = 1

# Auto-r√©cup√©ration en cas d'erreur
slave_skip_errors = 1062,1053,1146
```

```bash
# Red√©marrer MySQL sur le slave
systemctl restart mariadb

# Configurer la r√©plication
mysql
```

```sql
-- Configurer la connexion au master
CHANGE MASTER TO
    MASTER_HOST='IP_DU_MASTER',
    MASTER_USER='replica_user',
    MASTER_PASSWORD='MotDePasseReplication123!',
    MASTER_LOG_FILE='mysql-bin.000001',  -- Valeur du SHOW MASTER STATUS
    MASTER_LOG_POS=154;                  -- Position du SHOW MASTER STATUS

-- D√©marrer la r√©plication
START SLAVE;

-- V√©rifier l'√©tat de la r√©plication
SHOW SLAVE STATUS\G
```

#### Monitoring de la r√©plication

```bash
# Script de monitoring de la r√©plication
nano /usr/local/bin/mysql-replication-monitor
```

```bash
#!/bin/bash
# Monitoring de la r√©plication MySQL/MariaDB

LOG_FILE="/var/log/mysql-replication.log"

# Fonction de log
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a $LOG_FILE
}

check_master_status() {
    log_message "=== STATUS MASTER ==="
    mysql -e "SHOW MASTER STATUS;" | tee -a $LOG_FILE

    # Nombre de slaves connect√©s
    SLAVES_CONNECTED=$(mysql -e "SHOW PROCESSLIST;" | grep "Binlog Dump" | wc -l)
    log_message "Slaves connect√©s: $SLAVES_CONNECTED"
}

check_slave_status() {
    log_message "=== STATUS SLAVE ==="

    # Obtenir le statut d√©taill√© du slave
    SLAVE_STATUS=$(mysql -e "SHOW SLAVE STATUS\G")

    # V√©rifier si la r√©plication fonctionne
    SLAVE_IO_RUNNING=$(echo "$SLAVE_STATUS" | grep "Slave_IO_Running" | awk '{print $2}')
    SLAVE_SQL_RUNNING=$(echo "$SLAVE_STATUS" | grep "Slave_SQL_Running" | awk '{print $2}')
    SECONDS_BEHIND=$(echo "$SLAVE_STATUS" | grep "Seconds_Behind_Master" | awk '{print $2}')

    log_message "Slave IO Running: $SLAVE_IO_RUNNING"
    log_message "Slave SQL Running: $SLAVE_SQL_RUNNING"
    log_message "Secondes de retard: $SECONDS_BEHIND"

    # Alertes
    if [ "$SLAVE_IO_RUNNING" != "Yes" ] || [ "$SLAVE_SQL_RUNNING" != "Yes" ]; then
        log_message "ALERTE: R√©plication arr√™t√©e!"
        return 1
    fi

    if [ "$SECONDS_BEHIND" != "NULL" ] && [ $SECONDS_BEHIND -gt 300 ]; then
        log_message "ALERTE: Retard de r√©plication important ($SECONDS_BEHIND secondes)"
        return 1
    fi

    log_message "‚úì R√©plication fonctionnelle"
    return 0
}

# D√©tecter si c'est un master ou slave
IS_MASTER=$(mysql -e "SHOW VARIABLES LIKE 'log_bin';" | grep ON | wc -l)
IS_SLAVE=$(mysql -e "SHOW SLAVE STATUS\G" | grep "Master_Host" | wc -l)

if [ $IS_MASTER -gt 0 ]; then
    check_master_status
fi

if [ $IS_SLAVE -gt 0 ]; then
    check_slave_status
    if [ $? -ne 0 ]; then
        exit 1
    fi
fi

log_message "Monitoring termin√©"
```

```bash
chmod +x /usr/local/bin/mysql-replication-monitor

# Ajouter √† cron pour monitoring automatique
crontab -e
```

```bash
# Monitoring de la r√©plication toutes les 5 minutes
*/5 * * * * /usr/local/bin/mysql-replication-monitor
```

### R√©plication PostgreSQL (Streaming Replication)

#### Configuration du serveur Master PostgreSQL

```bash
# √âditer postgresql.conf sur le master
nano /etc/postgresql/15/main/postgresql.conf
```

```bash
# === CONFIGURATION STREAMING REPLICATION ===

# √âcouter sur toutes les interfaces (ajuster selon s√©curit√©)
listen_addresses = '*'

# R√©plication
wal_level = replica
max_wal_senders = 3
max_replication_slots = 3
wal_keep_size = 1GB

# Archivage des WAL (optionnel mais recommand√©)
archive_mode = on
archive_command = 'cp %p /var/lib/postgresql/15/archive/%f'

# Hot standby (permet les lectures sur le slave)
hot_standby = on
```

#### Configuration des acc√®s

```bash
# √âditer pg_hba.conf sur le master
nano /etc/postgresql/15/main/pg_hba.conf
```

```bash
# Ajouter ces lignes pour la r√©plication
# TYPE  DATABASE        USER            ADDRESS                 METHOD

# R√©plication streaming
host    replication     replica_user    IP_DU_SLAVE/32          md5

# Ou pour un r√©seau complet
host    replication     replica_user    192.168.1.0/24          md5
```

#### Cr√©er l'utilisateur de r√©plication

```bash
sudo -u postgres psql
```

```sql
-- Cr√©er l'utilisateur de r√©plication
CREATE USER replica_user REPLICATION LOGIN ENCRYPTED PASSWORD 'MotDePasseReplica456!';

-- V√©rifier
\du replica_user

-- Quitter
\q
```

```bash
# Red√©marrer PostgreSQL sur le master
systemctl restart postgresql

# Cr√©er le r√©pertoire d'archivage
mkdir -p /var/lib/postgresql/15/archive
chown postgres:postgres /var/lib/postgresql/15/archive
```

#### Configuration du serveur Slave PostgreSQL

**Sur le serveur slave** :
```bash
# Arr√™ter PostgreSQL sur le slave
systemctl stop postgresql

# Sauvegarder les donn√©es existantes
mv /var/lib/postgresql/15/main /var/lib/postgresql/15/main.backup

# Cr√©er une copie de base depuis le master
sudo -u postgres pg_basebackup -h IP_DU_MASTER -D /var/lib/postgresql/15/main -U replica_user -v -P -W

# Cr√©er le fichier de configuration de standby
nano /var/lib/postgresql/15/main/postgresql.auto.conf
```

```bash
# Configuration slave
primary_conninfo = 'host=IP_DU_MASTER port=5432 user=replica_user password=MotDePasseReplica456!'
primary_slot_name = 'slave1'
```

```bash
# Cr√©er le signal file pour activer le mode standby
touch /var/lib/postgresql/15/main/standby.signal

# Ajuster les permissions
chown -R postgres:postgres /var/lib/postgresql/15/main

# D√©marrer PostgreSQL sur le slave
systemctl start postgresql
```

#### V√©rification de la r√©plication PostgreSQL

**Sur le master** :
```bash
sudo -u postgres psql
```

```sql
-- Voir les connexions de r√©plication
SELECT client_addr, state, sync_state FROM pg_stat_replication;

-- Cr√©er un slot de r√©plication (recommand√©)
SELECT pg_create_physical_replication_slot('slave1');

-- Voir les slots
SELECT slot_name, slot_type, active FROM pg_replication_slots;
```

**Sur le slave** :
```bash
sudo -u postgres psql
```

```sql
-- V√©rifier que c'est bien en standby
SELECT pg_is_in_recovery();

-- Voir le statut de r√©plication
SELECT pg_last_wal_receive_lsn(), pg_last_wal_replay_lsn(), pg_last_xact_replay_timestamp();
```

### Script de basculement (Failover)

```bash
# Script de basculement PostgreSQL
nano /usr/local/bin/postgresql-failover
```

```bash
#!/bin/bash
# Script de basculement PostgreSQL

SLAVE_HOST="IP_DU_SLAVE"
MASTER_HOST="IP_DU_MASTER"
PG_DATA="/var/lib/postgresql/15/main"

# Fonction de log
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a /var/log/postgresql-failover.log
}

check_master_health() {
    log_message "V√©rification de l'√©tat du master..."

    if pg_isready -h $MASTER_HOST -p 5432 >/dev/null 2>&1; then
        log_message "Master accessible"
        return 0
    else
        log_message "Master inaccessible!"
        return 1
    fi
}

promote_slave() {
    log_message "PROMOTION DU SLAVE EN MASTER"

    # Promouvoir le slave
    sudo -u postgres pg_ctl promote -D $PG_DATA

    if [ $? -eq 0 ]; then
        log_message "‚úì Promotion r√©ussie"

        # Supprimer le fichier standby.signal
        rm -f $PG_DATA/standby.signal

        # Red√©marrer PostgreSQL
        systemctl restart postgresql

        log_message "Le slave est maintenant le nouveau master"
        return 0
    else
        log_message "‚úó √âchec de la promotion"
        return 1
    fi
}

# V√©rification des arguments
if [ "$1" = "--force" ]; then
    log_message "Basculement forc√© demand√©"
    promote_slave
    exit $?
fi

# V√©rification automatique
if ! check_master_health; then
    log_message "Master en panne d√©tect√© - Attente de 30 secondes avant basculement..."
    sleep 30

    # Double v√©rification
    if ! check_master_health; then
        log_message "Confirmation de la panne du master - Basculement automatique"
        promote_slave
        exit $?
    else
        log_message "Master de nouveau accessible - Pas de basculement"
        exit 0
    fi
else
    log_message "Master fonctionnel - Pas de basculement n√©cessaire"
    exit 0
fi
```

```bash
chmod +x /usr/local/bin/postgresql-failover

# Test manuel du script
postgresql-failover --force  # Attention : ne pas utiliser en production !
```

### Clustering avec MariaDB Galera

#### Installation de Galera Cluster

**Sur tous les n≈ìuds du cluster** :
```bash
# Installer MariaDB avec Galera
apt update
apt install -y mariadb-server galera-4 mariadb-backup

# Arr√™ter MariaDB sur tous les n≈ìuds
systemctl stop mariadb
```

#### Configuration du premier n≈ìud (Bootstrap)

```bash
# Configuration Galera sur le n≈ìud 1
nano /etc/mysql/conf.d/galera.cnf
```

```ini
[mysqld]
# === CONFIGURATION GALERA CLUSTER ===

# Param√®tres Galera
wsrep_on = ON
wsrep_cluster_name = "galera_cluster_prod"
wsrep_cluster_address = "gcomm://192.168.1.101,192.168.1.102,192.168.1.103"
wsrep_node_name = "node1"
wsrep_node_address = "192.168.1.101"

# M√©thode de r√©plication
wsrep_sst_method = rsync
wsrep_sst_auth = "galera_user:MotDePasseGalera789!"

# Provider Galera
wsrep_provider = /usr/lib/galera/libgalera_smm.so
wsrep_provider_options = "gcache.size=1G"

# === OPTIMISATIONS CLUSTER ===

# D√©sactiver le query cache (incompatible avec Galera)
query_cache_type = 0
query_cache_size = 0

# InnoDB optimis√© pour Galera
innodb_autoinc_lock_mode = 2
innodb_flush_log_at_trx_commit = 0
innodb_buffer_pool_size = 1G

# Logs binaires (optionnel avec Galera)
# log_bin = OFF
```

#### Bootstrap du cluster

```bash
# D√©marrer le premier n≈ìud en mode bootstrap
galera_new_cluster

# V√©rifier que le cluster est d√©marr√©
mysql -e "SHOW GLOBAL STATUS LIKE 'wsrep_cluster_size';"
# Doit afficher 1

# Cr√©er l'utilisateur de synchronisation
mysql
```

```sql
-- Cr√©er l'utilisateur pour la synchronisation Galera
CREATE USER 'galera_user'@'localhost' IDENTIFIED BY 'MotDePasseGalera789!';
GRANT ALL PRIVILEGES ON *.* TO 'galera_user'@'localhost';
FLUSH PRIVILEGES;

-- V√©rifier l'√©tat du cluster
SHOW GLOBAL STATUS LIKE 'wsrep_%';

EXIT;
```

#### Configuration des n≈ìuds suppl√©mentaires

**Sur le n≈ìud 2** :
```bash
# Configuration identique sauf l'adresse du n≈ìud
nano /etc/mysql/conf.d/galera.cnf
```

```ini
[mysqld]
# === Configuration identique au n≈ìud 1 sauf ===
wsrep_node_name = "node2"
wsrep_node_address = "192.168.1.102"
# Reste identique...
```

```bash
# D√©marrer MariaDB (rejoindra automatiquement le cluster)
systemctl start mariadb

# V√©rifier que le n≈ìud a rejoint
mysql -e "SHOW GLOBAL STATUS LIKE 'wsrep_cluster_size';"
# Doit afficher 2
```

**Sur le n≈ìud 3** :
```bash
# Configuration pour le n≈ìud 3
nano /etc/mysql/conf.d/galera.cnf
```

```ini
[mysqld]
wsrep_node_name = "node3"
wsrep_node_address = "192.168.1.103"
# Reste identique...
```

```bash
systemctl start mariadb

# V√©rifier le cluster complet
mysql -e "SHOW GLOBAL STATUS LIKE 'wsrep_cluster_size';"
# Doit afficher 3
```

### Monitoring du cluster Galera

```bash
# Script de monitoring Galera
nano /usr/local/bin/galera-cluster-monitor
```

```bash
#!/bin/bash
# Monitoring du cluster MariaDB Galera

LOG_FILE="/var/log/galera-monitor.log"

# Fonction de log
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a $LOG_FILE
}

check_cluster_status() {
    log_message "=== STATUS CLUSTER GALERA ==="

    # √âtat g√©n√©ral du cluster
    CLUSTER_STATUS=$(mysql -s -N -e "SHOW GLOBAL STATUS LIKE 'wsrep_cluster_status';" | awk '{print $2}')
    CLUSTER_SIZE=$(mysql -s -N -e "SHOW GLOBAL STATUS LIKE 'wsrep_cluster_size';" | awk '{print $2}')
    LOCAL_STATE=$(mysql -s -N -e "SHOW GLOBAL STATUS LIKE 'wsrep_local_state_comment';" | awk '{print $2}')
    READY=$(mysql -s -N -e "SHOW GLOBAL STATUS LIKE 'wsrep_ready';" | awk '{print $2}')

    log_message "Statut cluster: $CLUSTER_STATUS"
    log_message "Taille cluster: $CLUSTER_SIZE"
    log_message "√âtat local: $LOCAL_STATE"
    log_message "N≈ìud pr√™t: $READY"

    # V√©rifications critiques
    if [ "$CLUSTER_STATUS" != "Primary" ]; then
        log_message "‚úó ALERTE: Cluster pas en √©tat Primary"
        return 1
    fi

    if [ "$LOCAL_STATE" != "Synced" ]; then
        log_message "‚úó ALERTE: N≈ìud pas synchronis√©"
        return 1
    fi

    if [ "$READY" != "ON" ]; then
        log_message "‚úó ALERTE: N≈ìud pas pr√™t"
        return 1
    fi

    if [ "$CLUSTER_SIZE" -lt 2 ]; then
        log_message "‚ö† ATTENTION: Cluster de petite taille ($CLUSTER_SIZE n≈ìuds)"
    fi

    log_message "‚úì Cluster fonctionnel"
    return 0
}

check_replication_health() {
    log_message "=== SANT√â R√âPLICATION ==="

    # Queues de r√©plication
    SEND_QUEUE=$(mysql -s -N -e "SHOW GLOBAL STATUS LIKE 'wsrep_local_send_queue';" | awk '{print $2}')
    RECV_QUEUE=$(mysql -s -N -e "SHOW GLOBAL STATUS LIKE 'wsrep_local_recv_queue';" | awk '{print $2}')

    log_message "Queue d'envoi: $SEND_QUEUE"
    log_message "Queue de r√©ception: $RECV_QUEUE"

    # Alertes sur les queues
    if [ "$SEND_QUEUE" -gt 100 ]; then
        log_message "‚ö† ATTENTION: Queue d'envoi √©lev√©e ($SEND_QUEUE)"
    fi

    if [ "$RECV_QUEUE" -gt 100 ]; then
        log_message "‚ö† ATTENTION: Queue de r√©ception √©lev√©e ($RECV_QUEUE)"
    fi

    # Conflits de certification
    CERT_FAILURES=$(mysql -s -N -e "SHOW GLOBAL STATUS LIKE 'wsrep_local_cert_failures';" | awk '{print $2}')
    log_message "√âchecs de certification: $CERT_FAILURES"
}

show_cluster_members() {
    log_message "=== MEMBRES DU CLUSTER ==="

    mysql -e "
    SELECT
        VARIABLE_VALUE as 'Cluster Members'
    FROM INFORMATION_SCHEMA.GLOBAL_STATUS
    WHERE VARIABLE_NAME = 'wsrep_incoming_addresses';
    " | tee -a $LOG_FILE
}

# Ex√©cution des v√©rifications
ERRORS=0

check_cluster_status || ERRORS=$((ERRORS + 1))
check_replication_health
show_cluster_members

if [ $ERRORS -gt 0 ]; then
    log_message "ALERTE: Probl√®mes d√©tect√©s dans le cluster Galera"
    exit 1
else
    log_message "‚úì Monitoring Galera termin√© - Tout fonctionne"
    exit 0
fi
```

```bash
chmod +x /usr/local/bin/galera-cluster-monitor

# Ajouter √† cron
crontab -e
```

```bash
# Monitoring Galera toutes les 2 minutes
*/2 * * * * /usr/local/bin/galera-cluster-monitor
```

### Gestion des pannes dans Galera

#### Script de r√©cup√©ration automatique

```bash
nano /usr/local/bin/galera-recovery
```

```bash
#!/bin/bash
# Script de r√©cup√©ration automatique Galera

LOG_FILE="/var/log/galera-recovery.log"
NODES=("192.168.1.101" "192.168.1.102" "192.168.1.103")

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a $LOG_FILE
}

check_node_status() {
    local node=$1
    if mysql -h $node -e "SELECT 1;" >/dev/null 2>&1; then
        return 0  # N≈ìud accessible
    else
        return 1  # N≈ìud inaccessible
    fi
}

count_healthy_nodes() {
    local healthy=0
    for node in "${NODES[@]}"; do
        if check_node_status $node; then
            healthy=$((healthy + 1))
        fi
    done
    echo $healthy
}

bootstrap_cluster() {
    log_message "BOOTSTRAP: Red√©marrage complet du cluster"

    # Arr√™ter MariaDB sur tous les n≈ìuds
    for node in "${NODES[@]}"; do
        log_message "Arr√™t de MariaDB sur $node"
        ssh root@$node "systemctl stop mariadb" 2>/dev/null || true
    done

    sleep 5

    # Bootstrap depuis le premier n≈ìud
    log_message "Bootstrap depuis ${NODES[0]}"
    ssh root@${NODES[0]} "galera_new_cluster"

    sleep 10

    # D√©marrer les autres n≈ìuds
    for i in $(seq 1 $((${#NODES[@]} - 1))); do
        log_message "D√©marrage de MariaDB sur ${NODES[$i]}"
        ssh root@${NODES[$i]} "systemctl start mariadb"
        sleep 5
    done

    log_message "Bootstrap termin√©"
}

# V√©rification de l'√©tat du cluster
HEALTHY_NODES=$(count_healthy_nodes)
TOTAL_NODES=${#NODES[@]}

log_message "N≈ìuds sains: $HEALTHY_NODES/$TOTAL_NODES"

if [ $HEALTHY_NODES -eq 0 ]; then
    log_message "PANNE COMPL√àTE: Aucun n≈ìud accessible - Bootstrap n√©cessaire"
    bootstrap_cluster
elif [ $HEALTHY_NODES -lt $((TOTAL_NODES / 2 + 1)) ]; then
    log_message "QUORUM PERDU: Moins de la moiti√© des n≈ìuds disponibles"

    # V√©rifier si un bootstrap est n√©cessaire
    if ! mysql -e "SHOW GLOBAL STATUS LIKE 'wsrep_cluster_status';" | grep -q "Primary"; then
        log_message "Cluster pas en √©tat Primary - Bootstrap requis"
        bootstrap_cluster
    fi
else
    log_message "‚úì Cluster en bon √©tat"
fi
```

```bash
chmod +x /usr/local/bin/galera-recovery
```

### Load Balancing pour bases de donn√©es

#### Configuration HAProxy pour MySQL/MariaDB

```bash
# Installer HAProxy
apt install -y haproxy

# Configuration HAProxy pour MySQL
nano /etc/haproxy/haproxy.cfg
```

```
global
    daemon
    user haproxy
    group haproxy

defaults
    mode tcp
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

# Interface de monitoring
listen stats
    bind :8080
    stats enable
    stats uri /stats
    stats refresh 30s
    stats admin if TRUE

# Backend pour lectures (slaves ou tous les n≈ìuds Galera)
backend mysql_read
    balance roundrobin
    option mysql-check user haproxy_check
    server mysql1 192.168.1.101:3306 check
    server mysql2 192.168.1.102:3306 check backup
    server mysql3 192.168.1.103:3306 check backup

# Backend pour √©critures (master uniquement)
backend mysql_write
    server mysql_master 192.168.1.101:3306 check

# Frontend MySQL lecture
frontend mysql_read_frontend
    bind :3307
    default_backend mysql_read

# Frontend MySQL √©criture
frontend mysql_write_frontend
    bind :3306
    default_backend mysql_write
```

#### Utilisateur de v√©rification pour HAProxy

```sql
-- Cr√©er un utilisateur pour les health checks HAProxy
CREATE USER 'haproxy_check'@'%';
FLUSH PRIVILEGES;
```

```bash
# Red√©marrer HAProxy
systemctl restart haproxy
systemctl enable haproxy

# V√©rifier les statistiques
curl http://localhost:8080/stats
```

#### Test du load balancing

```bash
# Script de test de charge r√©partie
nano /usr/local/bin/test-mysql-loadbalancing
```

```bash
#!/bin/bash
# Test du load balancing MySQL

WRITE_HOST="localhost"
READ_HOST="localhost"
WRITE_PORT="3306"
READ_PORT="3307"
DATABASE="test"

echo "=== TEST LOAD BALANCING MYSQL ==="

# Test d'√©criture
echo "Test √©criture (port $WRITE_PORT):"
for i in {1..5}; do
    mysql -h $WRITE_HOST -P $WRITE_PORT -e "
    USE $DATABASE;
    INSERT INTO test_loadbalancing (message, serveur)
    VALUES ('Test $i', @@hostname);
    SELECT @@hostname as 'Serveur √©criture', NOW() as 'Timestamp';
    "
    sleep 1
done

echo
echo "Test lecture (port $READ_PORT):"
for i in {1..10}; do
    mysql -h $READ_HOST -P $READ_PORT -e "
    USE $DATABASE;
    SELECT @@hostname as 'Serveur lecture', COUNT(*) as 'Nb enregistrements'
    FROM test_loadbalancing;
    "
    sleep 0.5
done
```

---

## Maintenance et troubleshooting

### Outils de diagnostic

#### Diagnostic MySQL/MariaDB

```bash
# Script de diagnostic complet MySQL
nano /usr/local/bin/mysql-diagnostic
```

```bash
#!/bin/bash
# Diagnostic complet MySQL/MariaDB

echo "=== DIAGNOSTIC MYSQL/MARIADB ==="
echo "Date: $(date)"
echo "Serveur: $(hostname)"
echo

# Informations g√©n√©rales
echo "=== INFORMATIONS G√âN√âRALES ==="
mysql -e "SELECT VERSION() as 'Version MySQL', @@hostname as 'Hostname';"
mysql -e "SHOW GLOBAL STATUS LIKE 'Uptime';"
mysql -e "SHOW GLOBAL STATUS LIKE 'Threads_connected';"
mysql -e "SHOW GLOBAL STATUS LIKE 'Connections';"
echo

# Performance
echo "=== PERFORMANCE ==="
mysql -e "SHOW GLOBAL STATUS LIKE 'Slow_queries';"
mysql -e "SHOW GLOBAL STATUS LIKE 'Questions';"
mysql -e "SHOW GLOBAL STATUS LIKE 'Queries';"

# Cache de requ√™tes
echo
echo "=== CACHE DE REQU√äTES ==="
mysql -e "SHOW GLOBAL STATUS LIKE 'Qcache%';" 2>/dev/null || echo "Query cache non disponible"

# InnoDB
echo
echo "=== INNODB ==="
mysql -e "SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool%';" | head -10

# Processus actifs
echo
echo "=== PROCESSUS ACTIFS ==="
mysql -e "SHOW PROCESSLIST;" | head -10

# Bases de donn√©es et tailles
echo
echo "=== TAILLES DES BASES ==="
mysql -e "
SELECT
    table_schema as 'Database',
    ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) as 'Size (MB)'
FROM information_schema.tables
GROUP BY table_schema
ORDER BY SUM(data_length + index_length) DESC;
"

# Variables importantes
echo
echo "=== VARIABLES CRITIQUES ==="
mysql -e "SHOW VARIABLES LIKE 'innodb_buffer_pool_size';"
mysql -e "SHOW VARIABLES LIKE 'max_connections';"
mysql -e "SHOW VARIABLES LIKE 'query_cache_size';" 2>/dev/null || echo "Query cache non configur√©"
```

#### Diagnostic PostgreSQL

```bash
# Script de diagnostic PostgreSQL
nano /usr/local/bin/postgresql-diagnostic
```

```bash
#!/bin/bash
# Diagnostic complet PostgreSQL

echo "=== DIAGNOSTIC POSTGRESQL ==="
echo "Date: $(date)"
echo "Serveur: $(hostname)"
echo

# Informations g√©n√©rales
echo "=== INFORMATIONS G√âN√âRALES ==="
sudo -u postgres psql -c "SELECT version();"
sudo -u postgres psql -c "SELECT current_database(), current_user;"
sudo -u postgres psql -c "SELECT pg_postmaster_start_time() as start_time, now() - pg_postmaster_start_time() as uptime;"
echo

# Connexions
echo "=== CONNEXIONS ==="
sudo -u postgres psql -c "
SELECT
    count(*) as total_connections,
    count(*) FILTER (WHERE state = 'active') as active_connections,
    count(*) FILTER (WHERE state = 'idle') as idle_connections
FROM pg_stat_activity;
"

# Performance
echo
echo "=== PERFORMANCE ==="
sudo -u postgres psql -c "
SELECT
    'Cache Hit Ratio' as metric,
    round(100.0 * sum(blks_hit) / (sum(blks_hit) + sum(blks_read)), 2) as value
FROM pg_stat_database
UNION ALL
SELECT
    'Transactions/sec',
    round(sum(xact_commit + xact_rollback) / extract(epoch from now() - stats_reset), 2)
FROM pg_stat_database;
"

# Tailles des bases
echo
echo "=== TAILLES DES BASES ==="
sudo -u postgres psql -c "
SELECT
    datname as database,
    pg_size_pretty(pg_database_size(datname)) as size,
    pg_database_size(datname) as size_bytes
FROM pg_database
WHERE datname NOT IN ('template0', 'template1')
ORDER BY size_bytes DESC;
"

# Tables les plus volumineuses
echo
echo "=== PLUS GROSSES TABLES ==="
sudo -u postgres psql -c "
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 10;
"

# Configuration importante
echo
echo "=== CONFIGURATION CRITIQUE ==="
sudo -u postgres psql -c "
SELECT name, setting, unit, source
FROM pg_settings
WHERE name IN ('shared_buffers', 'effective_cache_size', 'work_mem', 'maintenance_work_mem', 'max_connections')
ORDER BY name;
"
```

### Scripts de maintenance automatique

#### Maintenance MySQL/MariaDB

```bash
nano /usr/local/bin/mysql-maintenance
```

```bash
#!/bin/bash
# Maintenance automatique MySQL/MariaDB

LOG_FILE="/var/log/mysql-maintenance.log"

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a $LOG_FILE
}

log_message "=== D√âBUT MAINTENANCE MYSQL ==="

# Optimisation des tables
log_message "Optimisation des tables..."
mysql -e "
SELECT CONCAT('OPTIMIZE TABLE ', table_schema, '.', table_name, ';') as 'Optimize Commands'
FROM information_schema.tables
WHERE table_schema NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
AND engine = 'MyISAM'
" | grep -v "Optimize Commands" | mysql

# Analyse des tables InnoDB
log_message "Analyse des tables InnoDB..."
mysql -e "
SELECT CONCAT('ANALYZE TABLE ', table_schema, '.', table_name, ';') as 'Analyze Commands'
FROM information_schema.tables
WHERE table_schema NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
AND engine = 'InnoDB'
" | grep -v "Analyze Commands" | mysql

# Nettoyage des logs binaires anciens
log_message "Nettoyage des logs binaires..."
mysql -e "PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 7 DAY);"

# Statistiques post-maintenance
log_message "Statistiques post-maintenance:"
mysql -e "SHOW ENGINE INNODB STATUS\G" | grep -A 10 "BUFFER POOL AND MEMORY"

log_message "=== FIN MAINTENANCE MYSQL ==="
```

#### Maintenance PostgreSQL

```bash
nano /usr/local/bin/postgresql-maintenance
```

```bash
#!/bin/bash
# Maintenance automatique PostgreSQL

LOG_FILE="/var/log/postgresql-maintenance.log"

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a $LOG_FILE
}

log_message "=== D√âBUT MAINTENANCE POSTGRESQL ==="

# VACUUM et ANALYZE sur toutes les bases
DATABASES=$(sudo -u postgres psql -t -c "SELECT datname FROM pg_database WHERE datistemplate = false AND datname != 'postgres';" | grep -v '^$' | tr -d ' ')

for db in $DATABASES; do
    log_message "Maintenance de la base: $db"

    # VACUUM ANALYZE complet
    sudo -u postgres psql -d $db -c "VACUUM ANALYZE;"

    # Statistiques de la base apr√®s maintenance
    SIZE=$(sudo -u postgres psql -d $db -t -c "SELECT pg_size_pretty(pg_database_size('$db'));" | tr -d ' ')
    log_message "Taille de $db apr√®s maintenance: $SIZE"
done

# REINDEX si n√©cessaire (attention : bloquant)
log_message "V√©rification de la n√©cessit√© de REINDEX..."
sudo -u postgres psql -c "
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    correlation
FROM pg_stats
WHERE schemaname NOT IN ('information_schema', 'pg_catalog')
AND abs(correlation) < 0.1
AND n_distinct > 100;
" | tee -a $LOG_FILE

# Nettoyage des WAL anciens (si archivage activ√©)
if [ -d "/var/lib/postgresql/15/archive" ]; then
    log_message "Nettoyage des WAL archiv√©s (>7 jours)..."
    find /var/lib/postgresql/15/archive -name "*.backup" -mtime +7 -delete
    find /var/lib/postgresql/15/archive -name "00000*" -mtime +7 -delete
fi

log_message "=== FIN MAINTENANCE POSTGRESQL ==="
```

### Automatisation compl√®te

```bash
# Script ma√Ætre de maintenance bases de donn√©es
nano /usr/local/bin/database-maintenance
```

```bash
#!/bin/bash
# Maintenance compl√®te des bases de donn√©es

LOG_DIR="/var/log/database-maintenance"
mkdir -p $LOG_DIR

# Maintenance MySQL/MariaDB
if systemctl is-active --quiet mariadb || systemctl is-active --quiet mysql; then
    echo "Maintenance MySQL/MariaDB..."
    /usr/local/bin/mysql-maintenance > $LOG_DIR/mysql-$(date +%Y%m%d).log 2>&1
    /usr/local/bin/mysql-backup > $LOG_DIR/mysql-backup-$(date +%Y%m%d).log 2>&1
fi

# Maintenance PostgreSQL
if systemctl is-active --quiet postgresql; then
    echo "Maintenance PostgreSQL..."
    /usr/local/bin/postgresql-maintenance > $LOG_DIR/postgresql-$(date +%Y%m%d).log 2>&1
    /usr/local/bin/postgresql-backup > $LOG_DIR/postgresql-backup-$(date +%Y%m%d).log 2>&1
fi

# V√©rifications post-maintenance
/usr/local/bin/check-backups > $LOG_DIR/backup-check-$(date +%Y%m%d).log 2>&1

# Nettoyage des logs anciens
find $LOG_DIR -name "*.log" -mtime +30 -delete

echo "Maintenance termin√©e. Logs dans $LOG_DIR"
```

```bash
# Rendre tous les scripts ex√©cutables
chmod +x /usr/local/bin/mysql-diagnostic
chmod +x /usr/local/bin/postgresql-diagnostic
chmod +x /usr/local/bin/mysql-maintenance
chmod +x /usr/local/bin/postgresql-maintenance
chmod +x /usr/local/bin/database-maintenance

# Automatisation via cron
crontab -e
```

```bash
# Maintenance compl√®te chaque dimanche √† 2h
0 2 * * 0 /usr/local/bin/database-maintenance

# Diagnostics quotidiens
0 6 * * * /usr/local/bin/mysql-diagnostic > /var/log/mysql-daily-diagnostic.log 2>&1
0 6 * * * /usr/local/bin/postgresql-diagnostic > /var/log/postgresql-daily-diagnostic.log 2>&1
```

---

## Conclusion du Module 6.3

### Ce que nous avons accompli

‚úÖ **Installation et configuration** de MariaDB et PostgreSQL s√©curis√©es
‚úÖ **Optimisation performance** avec monitoring automatique
‚úÖ **Sauvegarde et restauration** automatis√©es et test√©es
‚úÖ **R√©plication Master-Slave** pour haute disponibilit√©
‚úÖ **Clustering Galera** pour r√©plication multi-master
‚úÖ **Load balancing** avec HAProxy
‚úÖ **Maintenance automatique** compl√®te

### Points cl√©s √† retenir

- **S√©curit√©** : Utilisateurs d√©di√©s, acc√®s restreints, chiffrement
- **Performance** : Configuration optimis√©e selon la charge
- **Disponibilit√©** : R√©plication et clustering pour tol√©rance de panne
- **Sauvegarde** : Strat√©gie 3-2-1 avec v√©rification d'int√©grit√©
- **Monitoring** : Surveillance proactive et alertes automatiques

### Pr√©requis pour la suite

Avant de passer au Module 6.4 (Serveur de fichiers), v√©rifiez que :
- Les bases de donn√©es sont performantes et surveill√©es
- Les sauvegardes fonctionnent et sont test√©es
- La r√©plication est op√©rationnelle (si configur√©e)
- Les scripts de maintenance sont automatis√©s

**Vos bases de donn√©es sont maintenant pr√™tes pour supporter des applications web en production avec haute disponibilit√© !**

---

*Prochaine √©tape : Module 6.4 - Configuration du serveur de fichiers (Samba/NFS)*

‚è≠Ô∏è
