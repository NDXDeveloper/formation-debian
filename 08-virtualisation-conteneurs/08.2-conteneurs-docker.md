üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.2 Conteneurs Docker

## Introduction

Docker r√©volutionne le d√©ploiement d'applications en utilisant la conteneurisation. Contrairement aux machines virtuelles qui virtualisent le mat√©riel complet, Docker partage le noyau du syst√®me h√¥te tout en isolant les applications dans des conteneurs l√©gers et portables.

**Avantages de Docker :**
- **L√©g√®ret√©** : d√©marrage en secondes vs minutes pour les VMs
- **Portabilit√©** : "Build once, run anywhere"
- **Efficacit√©** : utilisation optimale des ressources syst√®me
- **Isolation** : applications s√©par√©es sans interf√©rence
- **Scalabilit√©** : facilit√© de mise √† l'√©chelle horizontale
- **DevOps** : int√©gration parfaite dans les pipelines CI/CD

**Concepts cl√©s :**
- **Image** : mod√®le de conteneur (comme un ISO pour VM)
- **Conteneur** : instance d'ex√©cution d'une image
- **Dockerfile** : recette pour construire une image
- **Registry** : d√©p√¥t d'images (Docker Hub, registries priv√©s)

---

## 8.2.1 Installation et configuration

### Installation de Docker sur Debian

**M√©thode 1 : Installation depuis les d√©p√¥ts officiels Docker**

```bash
# Suppression des anciennes versions
sudo apt remove docker docker-engine docker.io containerd runc

# Mise √† jour et installation des pr√©requis
sudo apt update
sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release

# Ajout de la cl√© GPG officielle Docker
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Ajout du d√©p√¥t Docker
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Installation de Docker Engine
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

**M√©thode 2 : Installation depuis les d√©p√¥ts Debian (plus simple)**

```bash
# Installation directe depuis les d√©p√¥ts Debian
sudo apt update
sudo apt install docker.io docker-compose

# Cette m√©thode installe une version l√©g√®rement plus ancienne mais stable
```

### Configuration post-installation

**Ajouter l'utilisateur au groupe docker :**
```bash
# Ajouter votre utilisateur au groupe docker
sudo usermod -aG docker $USER

# Appliquer les changements (se d√©connecter/reconnecter ou utiliser)
newgrp docker

# V√©rifier que vous pouvez ex√©cuter docker sans sudo
docker run hello-world
```

**Configuration du daemon Docker :**
```bash
# D√©marrage automatique de Docker
sudo systemctl enable docker
sudo systemctl start docker

# V√©rifier l'√©tat du service
sudo systemctl status docker

# Voir les informations syst√®me Docker
docker info
```

### Configuration avanc√©e du daemon

**Fichier de configuration `/etc/docker/daemon.json` :**
```json
{
  "storage-driver": "overlay2",
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m",
    "max-file": "5"
  },
  "default-address-pools": [
    {
      "base": "172.17.0.0/16",
      "size": 24
    }
  ]
}
```

**Options importantes :**
- `storage-driver` : pilote de stockage (overlay2 recommand√©)
- `log-driver` : format des logs
- `log-opts` : rotation automatique des logs
- `default-address-pools` : plages IP pour les r√©seaux Docker

### Premi√®re utilisation

**Commandes de base pour v√©rifier l'installation :**
```bash
# Version de Docker install√©e
docker --version

# Informations d√©taill√©es du syst√®me Docker
docker info

# Test avec le conteneur hello-world
docker run hello-world

# Lister les conteneurs en cours d'ex√©cution
docker ps

# Lister tous les conteneurs (y compris arr√™t√©s)
docker ps -a

# Lister les images disponibles localement
docker images
```

---

## 8.2.2 Images et conteneurs avanc√©s

### Comprendre les images Docker

**Qu'est-ce qu'une image Docker ?**
Une image Docker est un mod√®le en lecture seule contenant :
- Le syst√®me de fichiers de base (OS minimal)
- L'application et ses d√©pendances
- Les variables d'environnement
- Les m√©tadonn√©es de configuration

**Architecture en couches :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Application       ‚îÇ ‚Üê Couche application
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   D√©pendances      ‚îÇ ‚Üê Couche runtime
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   OS de base       ‚îÇ ‚Üê Couche syst√®me
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Gestion des images

**Recherche et t√©l√©chargement d'images :**
```bash
# Rechercher une image sur Docker Hub
docker search nginx

# T√©l√©charger une image
docker pull nginx
docker pull nginx:1.21-alpine  # version sp√©cifique

# Lister les images locales
docker images

# Supprimer une image
docker rmi nginx:latest

# Nettoyer les images non utilis√©es
docker image prune
```

**Inspection d'images :**
```bash
# Informations d√©taill√©es sur une image
docker inspect nginx

# Historique des couches d'une image
docker history nginx

# Taille d√©taill√©e par couche
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
```

### Cr√©ation de conteneurs avanc√©e

**Commande docker run compl√®te :**
```bash
# Syntaxe de base
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

# Exemples d'utilisation avanc√©e
docker run -d \
  --name mon-nginx \
  -p 8080:80 \
  -e NGINX_HOST=example.com \
  -v /host/data:/usr/share/nginx/html:ro \
  --restart unless-stopped \
  nginx:alpine
```

**Options importantes :**
- `-d` : ex√©cution en arri√®re-plan (daemon)
- `--name` : nom personnalis√© du conteneur
- `-p host:container` : mappage de ports
- `-e` : variables d'environnement
- `-v` : montage de volumes
- `--restart` : politique de red√©marrage
- `--rm` : suppression automatique √† l'arr√™t

### Gestion du cycle de vie des conteneurs

**√âtats d'un conteneur :**
1. **Created** : conteneur cr√©√© mais pas d√©marr√©
2. **Running** : conteneur en cours d'ex√©cution
3. **Paused** : conteneur suspendu
4. **Stopped** : conteneur arr√™t√©
5. **Deleted** : conteneur supprim√©

**Commandes de gestion :**
```bash
# D√©marrer un conteneur arr√™t√©
docker start nom-conteneur

# Arr√™ter un conteneur
docker stop nom-conteneur

# Red√©marrer un conteneur
docker restart nom-conteneur

# Mettre en pause/reprendre
docker pause nom-conteneur
docker unpause nom-conteneur

# Supprimer un conteneur
docker rm nom-conteneur

# Forcer la suppression d'un conteneur en cours
docker rm -f nom-conteneur
```

### Construction d'images avec Dockerfile

**Structure d'un Dockerfile :**
```dockerfile
# Commentaire : Image de base
FROM debian:12-slim

# Maintainer de l'image
LABEL maintainer="votre-email@example.com"

# Installation de paquets
RUN apt-get update && \
    apt-get install -y nginx && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Copie de fichiers depuis l'h√¥te
COPY nginx.conf /etc/nginx/nginx.conf
COPY website/ /var/www/html/

# Variables d'environnement
ENV NGINX_HOST=localhost

# Port expos√©
EXPOSE 80

# R√©pertoire de travail
WORKDIR /var/www/html

# Commande par d√©faut
CMD ["nginx", "-g", "daemon off;"]
```

**Instructions Dockerfile importantes :**
- `FROM` : image de base
- `RUN` : ex√©cuter des commandes lors de la construction
- `COPY/ADD` : copier des fichiers dans l'image
- `ENV` : d√©finir des variables d'environnement
- `EXPOSE` : documenter les ports utilis√©s
- `WORKDIR` : r√©pertoire de travail
- `CMD` : commande par d√©faut
- `ENTRYPOINT` : point d'entr√©e non modifiable

**Construction d'une image :**
```bash
# Construire une image depuis un Dockerfile
docker build -t mon-app:v1.0 .

# Construction avec arguments
docker build --build-arg VERSION=1.2.3 -t mon-app:v1.2.3 .

# Construction sans cache
docker build --no-cache -t mon-app:latest .
```

### Optimisation des images

**Bonnes pratiques pour des images l√©g√®res :**

1. **Utiliser des images de base minimales :**
```dockerfile
# Pr√©f√©rer les images alpine (tr√®s petites)
FROM alpine:3.18
FROM python:3.11-alpine
FROM node:18-alpine
```

2. **Multi-stage builds :**
```dockerfile
# Stage de construction
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Stage final
FROM alpine:3.18
RUN apk add --no-cache nodejs npm
COPY --from=builder /app/node_modules ./node_modules
COPY . .
CMD ["node", "server.js"]
```

3. **Optimiser les couches :**
```dockerfile
# Mauvais : plusieurs couches RUN
RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get clean

# Bon : une seule couche RUN
RUN apt-get update && \
    apt-get install -y nginx && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

---

## 8.2.3 Docker Compose et orchestration

### Introduction √† Docker Compose

**Docker Compose** permet de d√©finir et g√©rer des applications multi-conteneurs avec un fichier YAML. Il simplifie :
- La d√©finition de services multiples
- La gestion des d√©pendances entre conteneurs
- La configuration des r√©seaux et volumes
- Le d√©ploiement coordonn√© de l'application compl√®te

### Installation de Docker Compose

```bash
# V√©rifier si Docker Compose est d√©j√† install√©
docker compose version

# Si pas install√©, installation via le gestionnaire de paquets
sudo apt install docker-compose-plugin

# Ou installation manuelle (version r√©cente)
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
```

### Structure d'un fichier docker-compose.yml

**Exemple simple : Application web + base de donn√©es**
```yaml
version: '3.8'

services:
  # Service web
  web:
    build: .                    # Construire depuis Dockerfile local
    ports:
      - "8080:80"              # Port mapping
    depends_on:
      - db                     # D√©pendance vers la base
    environment:
      - DB_HOST=db
      - DB_NAME=myapp
    volumes:
      - ./app:/var/www/html    # Montage de code source
    restart: unless-stopped

  # Service base de donn√©es
  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=secret
      - MYSQL_DATABASE=myapp
    volumes:
      - db_data:/var/lib/mysql # Volume persistant
    restart: unless-stopped

# D√©finition des volumes
volumes:
  db_data:
```

### Commandes Docker Compose

**Gestion du cycle de vie :**
```bash
# D√©marrer tous les services
docker compose up

# D√©marrer en arri√®re-plan
docker compose up -d

# Reconstruire les images avant d√©marrage
docker compose up --build

# Arr√™ter tous les services
docker compose down

# Arr√™ter et supprimer volumes
docker compose down -v

# Voir l'√©tat des services
docker compose ps

# Voir les logs
docker compose logs
docker compose logs web  # logs d'un service sp√©cifique
```

**Gestion individuelle des services :**
```bash
# D√©marrer un service sp√©cifique
docker compose start web

# Arr√™ter un service
docker compose stop db

# Red√©marrer un service
docker compose restart web

# Reconstruire un service
docker compose build web

# Ex√©cuter une commande dans un service
docker compose exec web bash
```

### Exemple avanc√© : Stack LAMP

```yaml
version: '3.8'

services:
  # Serveur web Apache + PHP
  web:
    image: php:8.1-apache
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./website:/var/www/html
      - ./apache-config:/etc/apache2/sites-available
    depends_on:
      - db
    environment:
      - APACHE_DOCUMENT_ROOT=/var/www/html
    networks:
      - lamp-network

  # Base de donn√©es MySQL
  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD}
      - MYSQL_DATABASE=${DB_NAME}
      - MYSQL_USER=${DB_USER}
      - MYSQL_PASSWORD=${DB_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
      - ./init-scripts:/docker-entrypoint-initdb.d
    networks:
      - lamp-network

  # phpMyAdmin pour administration
  phpmyadmin:
    image: phpmyadmin:latest
    ports:
      - "8080:80"
    depends_on:
      - db
    environment:
      - PMA_HOST=db
      - PMA_USER=root
      - PMA_PASSWORD=${DB_ROOT_PASSWORD}
    networks:
      - lamp-network

volumes:
  mysql_data:

networks:
  lamp-network:
    driver: bridge
```

**Fichier `.env` pour les variables :**
```env
DB_ROOT_PASSWORD=motdepasse_root_securise
DB_NAME=mon_application
DB_USER=app_user
DB_PASSWORD=motdepasse_user_securise
```

### Orchestration avanc√©e

**Mise √† l'√©chelle des services :**
```bash
# Lancer plusieurs instances d'un service
docker compose up --scale web=3

# √âquilibrage de charge avec nginx
# (n√©cessite configuration nginx upstream)
```

**Profils pour diff√©rents environnements :**
```yaml
version: '3.8'

services:
  web:
    image: nginx
    profiles: ["production", "development"]

  web-dev:
    image: nginx:alpine
    profiles: ["development"]
    volumes:
      - ./src:/usr/share/nginx/html

  db:
    image: mysql:8.0
    profiles: ["production"]

  db-dev:
    image: mysql:8.0
    profiles: ["development"]
    environment:
      - MYSQL_ROOT_PASSWORD=dev123
```

```bash
# Utiliser un profil sp√©cifique
docker compose --profile development up
docker compose --profile production up
```

---

## 8.2.4 Volumes et r√©seaux

### Gestion des volumes Docker

**Types de stockage Docker :**

1. **Volumes** : g√©r√©s par Docker, recommand√©s pour la persistance
2. **Bind mounts** : montage direct de dossiers h√¥te
3. **tmpfs mounts** : stockage temporaire en m√©moire

**Volumes Docker :**
```bash
# Cr√©er un volume
docker volume create mon-volume

# Lister les volumes
docker volume ls

# Inspecter un volume
docker volume inspect mon-volume

# Supprimer un volume
docker volume rm mon-volume

# Nettoyer les volumes non utilis√©s
docker volume prune
```

**Utilisation des volumes :**
```bash
# Volume nomm√©
docker run -d -v mon-volume:/data nginx

# Bind mount (dossier h√¥te)
docker run -d -v /host/path:/container/path nginx

# Volume temporaire en m√©moire
docker run -d --tmpfs /tmp nginx
```

### Configuration avanc√©e des volumes

**Dans docker-compose.yml :**
```yaml
version: '3.8'

services:
  app:
    image: nginx
    volumes:
      # Volume nomm√© pour donn√©es persistantes
      - app_data:/var/lib/app

      # Bind mount pour d√©veloppement
      - ./src:/usr/share/nginx/html:ro

      # Sous-chemin sp√©cifique
      - app_data:/var/lib/app/uploads:rw

      # Volume temporaire
      - type: tmpfs
        target: /tmp
        tmpfs:
          size: 100M

volumes:
  app_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /opt/app-data
```

### Gestion des r√©seaux Docker

**Types de r√©seaux Docker :**

1. **bridge** : r√©seau par d√©faut, isolation des conteneurs
2. **host** : utilise directement la pile r√©seau de l'h√¥te
3. **none** : pas de r√©seau, isolation compl√®te
4. **custom** : r√©seaux personnalis√©s pour segmentation

**Gestion des r√©seaux :**
```bash
# Lister les r√©seaux
docker network ls

# Cr√©er un r√©seau personnalis√©
docker network create mon-reseau

# Inspecter un r√©seau
docker network inspect bridge

# Connecter un conteneur √† un r√©seau
docker network connect mon-reseau mon-conteneur

# D√©connecter un conteneur
docker network disconnect mon-reseau mon-conteneur

# Supprimer un r√©seau
docker network rm mon-reseau
```

### Configuration r√©seau avanc√©e

**R√©seau personnalis√© avec sous-r√©seau :**
```bash
# Cr√©er un r√©seau avec configuration IP
docker network create \
  --driver bridge \
  --subnet=172.20.0.0/16 \
  --ip-range=172.20.240.0/20 \
  --gateway=172.20.0.1 \
  mon-reseau-custom
```

**Dans docker-compose.yml :**
```yaml
version: '3.8'

services:
  web:
    image: nginx
    networks:
      - frontend
      - backend
    ports:
      - "80:80"

  api:
    image: node:alpine
    networks:
      - backend
      - database

  db:
    image: mysql:8.0
    networks:
      - database

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
  database:
    driver: bridge
    internal: true  # Pas d'acc√®s internet
```

### Communication entre conteneurs

**R√©solution DNS automatique :**
```bash
# Les conteneurs sur le m√™me r√©seau peuvent se joindre par nom
docker run -d --name web nginx
docker run -d --name db mysql
docker run -it --rm alpine ping web  # fonctionne automatiquement
```

**Variables d'environnement pour la configuration :**
```yaml
version: '3.8'

services:
  app:
    image: mon-app
    environment:
      - DB_HOST=database
      - DB_PORT=3306
      - REDIS_URL=redis://cache:6379
    networks:
      - app-network

  database:
    image: mysql:8.0
    networks:
      - app-network

  cache:
    image: redis:alpine
    networks:
      - app-network

networks:
  app-network:
```

---

## 8.2.5 Registry priv√© et distribution

### Comprendre les registries Docker

**Qu'est-ce qu'un registry ?**
Un registry Docker est un service de stockage et distribution d'images Docker. Il permet de :
- Stocker des images de mani√®re centralis√©e
- Partager des images entre √©quipes/environnements
- G√©rer les versions et tags d'images
- Contr√¥ler l'acc√®s aux images

**Types de registries :**
- **Docker Hub** : registry public officiel
- **Registries cloud** : AWS ECR, Google GCR, Azure ACR
- **Registries priv√©s** : Harbor, GitLab Registry, Nexus
- **Registry Docker officiel** : solution simple auto-h√©berg√©e

### Installation d'un registry priv√©

**Registry Docker officiel :**
```bash
# D√©marrage d'un registry simple
docker run -d \
  --name registry \
  --restart unless-stopped \
  -p 5000:5000 \
  registry:2

# Registry avec stockage persistant
docker run -d \
  --name registry \
  --restart unless-stopped \
  -p 5000:5000 \
  -v registry_data:/var/lib/registry \
  registry:2
```

**Registry avec authentification :**
```bash
# Cr√©er un utilisateur/mot de passe
mkdir auth
docker run --rm \
  --entrypoint htpasswd \
  httpd:2 -Bbn testuser testpassword > auth/htpasswd

# D√©marrer le registry avec authentification
docker run -d \
  --name registry \
  --restart unless-stopped \
  -p 5000:5000 \
  -v $(pwd)/auth:/auth \
  -v registry_data:/var/lib/registry \
  -e "REGISTRY_AUTH=htpasswd" \
  -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" \
  -e "REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd" \
  registry:2
```

### Configuration avanc√©e avec Docker Compose

```yaml
version: '3.8'

services:
  registry:
    image: registry:2
    ports:
      - "5000:5000"
    environment:
      # Configuration du stockage
      REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY: /var/lib/registry

      # Configuration de l'authentification
      REGISTRY_AUTH: htpasswd
      REGISTRY_AUTH_HTPASSWD_REALM: "Registry Realm"
      REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd

      # Configuration HTTPS
      REGISTRY_HTTP_TLS_CERTIFICATE: /certs/domain.crt
      REGISTRY_HTTP_TLS_KEY: /certs/domain.key

      # Configuration des logs
      REGISTRY_LOG_LEVEL: info

    volumes:
      - registry_data:/var/lib/registry
      - ./auth:/auth
      - ./certs:/certs
    restart: unless-stopped

  # Interface web pour le registry
  registry-ui:
    image: joxit/docker-registry-ui:static
    ports:
      - "8080:80"
    environment:
      - REGISTRY_TITLE=Mon Registry Priv√©
      - REGISTRY_URL=http://registry:5000
      - DELETE_IMAGES=true
    depends_on:
      - registry

volumes:
  registry_data:
```

### Utilisation d'un registry priv√©

**Configuration du client Docker :**
```bash
# Pour un registry HTTP (non-s√©curis√©)
# √âditer /etc/docker/daemon.json
{
  "insecure-registries": ["192.168.1.100:5000"]
}

# Red√©marrer Docker
sudo systemctl restart docker
```

**Authentification sur le registry :**
```bash
# Se connecter au registry priv√©
docker login localhost:5000
# ou
docker login 192.168.1.100:5000

# V√©rifier la connexion
docker info | grep -A 5 "Registry"
```

**Pousser et r√©cup√©rer des images :**
```bash
# Tagger une image pour le registry priv√©
docker tag mon-app:latest localhost:5000/mon-app:v1.0

# Pousser l'image
docker push localhost:5000/mon-app:v1.0

# R√©cup√©rer l'image
docker pull localhost:5000/mon-app:v1.0

# Lister les images du registry (via API)
curl -X GET http://localhost:5000/v2/_catalog
curl -X GET http://localhost:5000/v2/mon-app/tags/list
```

### Registry avec Harbor

**Harbor** est une solution de registry entreprise avec interface web compl√®te :

```yaml
# docker-compose.yml pour Harbor
version: '3.8'

services:
  harbor-core:
    image: goharbor/harbor-core:v2.8.0
    depends_on:
      - registry
      - postgresql
      - redis
    volumes:
      - /data/harbor/common/config:/etc/core/app.conf
      - /data/harbor/ca_download/:/etc/core/ca/
    environment:
      - CORE_SECRET=your-secret-key

  registry:
    image: goharbor/registry-photon:v2.8.0
    volumes:
      - /data/harbor/registry:/storage

  postgresql:
    image: goharbor/harbor-db:v2.8.0
    environment:
      - POSTGRES_PASSWORD=root123
    volumes:
      - /data/harbor/database:/var/lib/postgresql/data

  redis:
    image: goharbor/redis-photon:v2.8.0
    volumes:
      - /data/harbor/redis:/var/lib/redis
```

### Strat√©gies de distribution

**Multi-registry pour haute disponibilit√© :**
```yaml
version: '3.8'

services:
  # Registry principal
  registry-primary:
    image: registry:2
    ports:
      - "5000:5000"
    volumes:
      - primary_data:/var/lib/registry

  # Registry miroir
  registry-mirror:
    image: registry:2
    ports:
      - "5001:5000"
    environment:
      REGISTRY_PROXY_REMOTEURL: http://registry-primary:5000
    volumes:
      - mirror_data:/var/lib/registry

volumes:
  primary_data:
  mirror_data:
```

---

## 8.2.6 S√©curit√© des conteneurs

### Principes de s√©curit√© des conteneurs

**D√©fis sp√©cifiques aux conteneurs :**
- **Partage du noyau** : vuln√©rabilit√© kernel = risque pour tous les conteneurs
- **Surface d'attaque √©largie** : plus de composants √† s√©curiser
- **Images non v√©rifi√©es** : risque de malware dans les images
- **Privil√®ges √©lev√©s** : conteneurs root par d√©faut
- **Secrets management** : gestion des credentials

### Ex√©cution de conteneurs non-privil√©gi√©s

**Utilisateur non-root dans les conteneurs :**
```dockerfile
# Dans le Dockerfile
FROM debian:12-slim

# Cr√©er un utilisateur non-privil√©gi√©
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Installer l'application
COPY app /opt/app
RUN chown -R appuser:appuser /opt/app

# Basculer vers l'utilisateur non-root
USER appuser

CMD ["/opt/app/start.sh"]
```

**Ex√©cution avec utilisateur sp√©cifique :**
```bash
# Sp√©cifier l'utilisateur lors de l'ex√©cution
docker run --user 1000:1000 mon-image

# Ou dans docker-compose.yml
version: '3.8'
services:
  app:
    image: mon-app
    user: "1000:1000"
```

### Limitation des capacit√©s et privil√®ges

**Retrait des capacit√©s dangereuses :**
```bash
# Supprimer toutes les capacit√©s puis ajouter seulement celles n√©cessaires
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx

# Ex√©cution sans privil√®ges
docker run --security-opt=no-new-privileges nginx
```

**Configuration dans docker-compose.yml :**
```yaml
version: '3.8'

services:
  web:
    image: nginx
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
      - /var/cache/nginx
```

### S√©curisation des images

**Scanning des vuln√©rabilit√©s :**
```bash
# Utiliser docker scan (n√©cessite Docker Desktop ou plugin)
docker scan mon-image:latest

# Utiliser Trivy (outil opensource)
# Installation
sudo apt install wget apt-transport-https gnupg
wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
echo "deb https://aquasecurity.github.io/trivy-repo/deb generic main" | sudo tee -a /etc/apt/sources.list
sudo apt update && sudo apt install trivy

# Scanner une image
trivy image nginx:latest
trivy image --severity HIGH,CRITICAL mon-app:latest
```

**Bonnes pratiques pour images s√©curis√©es :**

1. **Images de base minimales :**
```dockerfile
# Pr√©f√©rer les images distroless ou alpine
FROM gcr.io/distroless/java:11
# ou
FROM alpine:3.18
```

2. **Mise √† jour des paquets :**
```dockerfile
FROM debian:12-slim
RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y mon-package && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

3. **V√©rification des signatures :**
```bash
# V√©rifier la signature d'une image
docker trust inspect --pretty nginx:latest

# Activer la v√©rification des signatures
export DOCKER_CONTENT_TRUST=1
docker pull nginx:latest
```

### Gestion s√©curis√©e des secrets

**√âviter les secrets dans les images :**
```dockerfile
# Mauvais : secret dans l'image
ENV API_KEY=secret123

# Bon : secret via variable d'environnement au runtime
ENV API_KEY=""
```

**Docker Secrets (Swarm mode) :**
```bash
# Cr√©er un secret
echo "motdepasse_db" | docker secret create db_password -

# Utiliser le secret dans un service
docker service create \
  --name webapp \
  --secret db_password \
  mon-app:latest
```

# 8.2 Conteneurs Docker - Suite (S√©curit√©)

## Gestion s√©curis√©e des secrets (suite)

**Gestion via fichiers externes :**
```yaml
version: '3.8'

services:
  app:
    image: mon-app
    environment:
      - DB_PASSWORD_FILE=/run/secrets/db_password
    secrets:
      - db_password
    volumes:
      - ./config:/app/config:ro

secrets:
  db_password:
    file: ./secrets/db_password.txt
```

**Utilisation de variables d'environnement s√©curis√©es :**
```bash
# Fichier .env (ne jamais commiter en Git)
DB_PASSWORD=motdepasse_securise
API_KEY=cle_api_secrete

# Dans docker-compose.yml
version: '3.8'
services:
  app:
    image: mon-app
    environment:
      - DB_PASSWORD=${DB_PASSWORD}
      - API_KEY=${API_KEY}
```

**Outils externes pour secrets :**
```yaml
# Int√©gration avec HashiCorp Vault
version: '3.8'

services:
  app:
    image: mon-app
    environment:
      - VAULT_ADDR=https://vault.example.com
      - VAULT_TOKEN_FILE=/run/secrets/vault_token
    secrets:
      - vault_token

secrets:
  vault_token:
    external: true
```

### Isolation r√©seau et pare-feu

**Segmentation r√©seau :**
```yaml
version: '3.8'

services:
  # Frontend accessible depuis internet
  nginx:
    image: nginx
    ports:
      - "80:80"
      - "443:443"
    networks:
      - frontend

  # Backend accessible seulement depuis frontend
  api:
    image: mon-api
    networks:
      - frontend
      - backend
    # Pas de ports expos√©s vers l'h√¥te

  # Base de donn√©es isol√©e
  database:
    image: mysql:8.0
    networks:
      - backend
    environment:
      - MYSQL_ROOT_PASSWORD_FILE=/run/secrets/db_root_password
    secrets:
      - db_root_password

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true  # Pas d'acc√®s internet

secrets:
  db_root_password:
    file: ./secrets/db_root_password.txt
```

**Configuration de pare-feu pour Docker :**
```bash
# Docker modifie automatiquement iptables
# Voir les r√®gles Docker
sudo iptables -L DOCKER

# Bloquer l'acc√®s externe √† un port sp√©cifique
sudo iptables -I DOCKER-USER -p tcp --dport 5432 -j DROP

# Autoriser seulement un sous-r√©seau sp√©cifique
sudo iptables -I DOCKER-USER -s 192.168.1.0/24 -p tcp --dport 5432 -j ACCEPT
```

### Contr√¥le d'acc√®s et authentification

**Authentification multi-facteur pour registry :**
```yaml
# docker-compose.yml avec authentification avanc√©e
version: '3.8'

services:
  registry:
    image: registry:2
    environment:
      # Authentification LDAP
      REGISTRY_AUTH: ldap
      REGISTRY_AUTH_LDAP_ADDR: ldap://ldap.example.com:389
      REGISTRY_AUTH_LDAP_BASEDN: dc=example,dc=com
      REGISTRY_AUTH_LDAP_BINDDN: cn=admin,dc=example,dc=com
      REGISTRY_AUTH_LDAP_BINDPASSWORD_FILE: /run/secrets/ldap_password
    secrets:
      - ldap_password

secrets:
  ldap_password:
    file: ./secrets/ldap_password.txt
```

**Int√©gration avec syst√®mes d'authentification :**
```bash
# Authentification via token JWT
docker login -u oauth2accesstoken -p "$(gcloud auth print-access-token)" gcr.io

# Authentification via AWS ECR
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 123456789.dkr.ecr.us-east-1.amazonaws.com
```

### Monitoring et logging s√©curis√©

**Configuration des logs s√©curis√©s :**
```yaml
version: '3.8'

services:
  app:
    image: mon-app
    logging:
      driver: "syslog"
      options:
        syslog-address: "tcp://log-server:514"
        syslog-facility: "local0"
        tag: "{{.Name}}/{{.ID}}"

  # Collecteur de logs centralis√©
  logstash:
    image: logstash:8.7.0
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline:ro
      - ./logstash/config:/usr/share/logstash/config:ro
    ports:
      - "514:514/tcp"
      - "514:514/udp"
```

**Monitoring de s√©curit√© avec Falco :**
```yaml
version: '3.8'

services:
  # Falco pour d√©tection d'intrusion runtime
  falco:
    image: falcosecurity/falco:latest
    privileged: true
    volumes:
      - /var/run/docker.sock:/host/var/run/docker.sock
      - /dev:/host/dev
      - /proc:/host/proc:ro
      - /boot:/host/boot:ro
      - /lib/modules:/host/lib/modules:ro
      - /usr:/host/usr:ro
      - /etc:/host/etc:ro
    environment:
      - FALCO_GRPC_BIND_ADDRESS=0.0.0.0:5060
    ports:
      - "5060:5060"

  # Application surveill√©e
  app:
    image: mon-app
    security_opt:
      - apparmor:docker-default
    read_only: true
    tmpfs:
      - /tmp:noexec,nosuid
```

### AppArmor et SELinux

**Configuration AppArmor pour conteneurs :**
```bash
# V√©rifier si AppArmor est actif
sudo aa-status

# Profil AppArmor pour Docker
sudo nano /etc/apparmor.d/docker-nginx

# Contenu du profil
profile docker-nginx flags=(attach_disconnected,mediate_deleted) {
  #include <abstractions/base>

  # Autoriser lecture seule du syst√®me de fichiers
  /usr/share/nginx/** r,
  /etc/nginx/** r,

  # Interdire l'acc√®s au syst√®me
  deny /proc/sys/** w,
  deny /sys/** w,
}

# Charger le profil
sudo apparmor_parser -r /etc/apparmor.d/docker-nginx
```

**Utilisation dans Docker :**
```bash
# Appliquer un profil AppArmor
docker run --security-opt apparmor=docker-nginx nginx

# Dans docker-compose.yml
version: '3.8'
services:
  web:
    image: nginx
    security_opt:
      - apparmor:docker-nginx
```

### Outils d'audit et conformit√©

**Docker Bench Security :**
```bash
# Installation et ex√©cution
git clone https://github.com/docker/docker-bench-security.git
cd docker-bench-security
sudo ./docker-bench-security.sh

# G√©n√©ration d'un rapport
sudo ./docker-bench-security.sh -l /tmp/docker-bench-report.log
```

**Audit avec Lynis :**
```bash
# Installation de Lynis
sudo apt install lynis

# Audit sp√©cifique aux conteneurs
sudo lynis audit system --tests-from-group containers

# Rapport d√©taill√©
sudo lynis audit system --no-colors --quiet --report-file /tmp/lynis-report.dat
```

**CIS Benchmarks pour Docker :**
```bash
# V√©rifications automatiques selon les standards CIS
# Exemple de v√©rifications importantes :

# 1. Utilisateur non-root dans les conteneurs
docker inspect mon-conteneur | grep -i user

# 2. V√©rification des capacit√©s
docker inspect mon-conteneur | grep -i cap

# 3. V√©rification des montages sensibles
docker inspect mon-conteneur | grep -A 10 -i mounts

# 4. V√©rification de la configuration r√©seau
docker network ls
docker network inspect bridge
```

### R√©ponse aux incidents de s√©curit√©

**Proc√©dures d'urgence :**
```bash
# Arr√™t d'urgence de tous les conteneurs
docker stop $(docker ps -q)

# Isolation d'un conteneur suspect
docker network disconnect bridge conteneur-suspect

# Collecte d'informations forensiques
docker logs conteneur-suspect > /tmp/incident-logs.txt
docker exec conteneur-suspect ps aux > /tmp/incident-processes.txt

# Sauvegarde de l'√©tat du conteneur
docker commit conteneur-suspect evidence:$(date +%Y%m%d-%H%M%S)
```

**Script d'audit automatique :**
```bash
#!/bin/bash
# audit-docker-security.sh

echo "=== Audit de s√©curit√© Docker ==="
echo "Date: $(date)"

echo "1. Conteneurs en cours d'ex√©cution avec privil√®ges root:"
docker ps --format "table {{.Names}}\t{{.Image}}" | xargs -I {} docker inspect {} | grep -B 5 -A 5 '"User": ""'

echo "2. Conteneurs avec acc√®s au socket Docker:"
docker ps --format "table {{.Names}}\t{{.Image}}" | xargs -I {} docker inspect {} | grep -B 2 -A 2 "/var/run/docker.sock"

echo "3. Ports expos√©s publiquement:"
docker ps --format "table {{.Names}}\t{{.Ports}}"

echo "4. Volumes mont√©s depuis l'h√¥te:"
docker ps --format "table {{.Names}}\t{{.Image}}" | xargs -I {} docker inspect {} | grep -B 2 -A 2 '"Type": "bind"'

echo "5. Images sans tag (potentiellement non v√©rifi√©es):"
docker images | grep "<none>"

echo "=== Fin de l'audit ==="
```

### Hardening du daemon Docker

**Configuration s√©curis√©e du daemon :**
```json
{
  "storage-driver": "overlay2",
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m",
    "max-file": "5"
  },
  "live-restore": true,
  "userland-proxy": false,
  "no-new-privileges": true,
  "selinux-enabled": true,
  "userns-remap": "default",
  "disable-legacy-registry": true,
  "experimental": false
}
```

**Options importantes :**
- `userns-remap` : isolation des utilisateurs
- `no-new-privileges` : emp√™che l'escalade de privil√®ges
- `selinux-enabled` : active SELinux si disponible
- `disable-legacy-registry` : s√©curise les communications registry

**S√©curisation du socket Docker :**
```bash
# Acc√®s via TLS uniquement
sudo mkdir -p /etc/docker/certs.d/
sudo openssl genrsa -aes256 -out ca-key.pem 4096
sudo openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem

# Configuration dans daemon.json
{
  "hosts": ["tcp://0.0.0.0:2376"],
  "tls": true,
  "tlsverify": true,
  "tlscert": "/etc/docker/certs.d/server-cert.pem",
  "tlskey": "/etc/docker/certs.d/server-key.pem",
  "tlscacert": "/etc/docker/certs.d/ca.pem"
}
```

## R√©sum√© et bonnes pratiques de s√©curit√©

### Checklist de s√©curit√© Docker

**Images :**
- ‚úÖ Utiliser des images officielles ou v√©rifi√©es
- ‚úÖ Scanner les vuln√©rabilit√©s r√©guli√®rement
- ‚úÖ Utiliser des images minimales (alpine, distroless)
- ‚úÖ Mettre √† jour r√©guli√®rement les images de base
- ‚úÖ Ne jamais inclure de secrets dans les images

**Conteneurs :**
- ‚úÖ Ex√©cuter avec utilisateur non-root
- ‚úÖ Utiliser read-only filesystem quand possible
- ‚úÖ Limiter les capacit√©s Linux (--cap-drop=ALL)
- ‚úÖ Appliquer des profils de s√©curit√© (AppArmor/SELinux)
- ‚úÖ √âviter le mode privil√©gi√© (--privileged)

**R√©seau :**
- ‚úÖ Utiliser des r√©seaux personnalis√©s
- ‚úÖ Segmenter les applications (frontend/backend/db)
- ‚úÖ Exposer seulement les ports n√©cessaires
- ‚úÖ Utiliser un reverse proxy pour l'exposition

**Stockage :**
- ‚úÖ √âviter les bind mounts sensibles (/var/run/docker.sock)
- ‚úÖ Utiliser des volumes Docker plut√¥t que bind mounts
- ‚úÖ Chiffrer les donn√©es sensibles
- ‚úÖ Nettoyer r√©guli√®rement les volumes non utilis√©s

**Monitoring :**
- ‚úÖ Centraliser les logs
- ‚úÖ Surveiller les activit√©s suspectes
- ‚úÖ Mettre en place des alertes
- ‚úÖ Auditer r√©guli√®rement la configuration

### Outils recommand√©s

**Scanning de s√©curit√© :**
- **Trivy** : scanner de vuln√©rabilit√©s images/conteneurs
- **Clair** : scanner CoreOS pour registries
- **Anchore** : analyse statique de s√©curit√©
- **Docker Scout** : service officiel Docker

**Runtime Security :**
- **Falco** : d√©tection d'intrusion runtime
- **Sysdig** : monitoring et s√©curit√© conteneurs
- **Aqua Security** : plateforme s√©curit√© compl√®te

**Conformit√© :**
- **Docker Bench** : audit CIS benchmarks
- **Kube-score** : analyse configurations Kubernetes
- **Polaris** : validation bonnes pratiques

### Perspectives et √©volution

**Tendances s√©curit√© conteneurs :**
- **Zero Trust Architecture** : v√©rification continue
- **Rootless containers** : ex√©cution sans privil√®ges
- **Confidential computing** : chiffrement en m√©moire
- **Supply chain security** : s√©curisation de la cha√Æne de build

**Technologies √©mergentes :**
- **WebAssembly (WASM)** : isolation renforc√©e
- **Unikernels** : surface d'attaque minimale
- **eBPF** : monitoring kernel avanc√©

---

*La s√©curit√© des conteneurs est un processus continu qui n√©cessite une approche en couches. De la construction s√©curis√©e des images jusqu'au monitoring runtime, chaque √©tape doit √™tre prise en compte pour maintenir un environnement conteneuris√© robuste et s√©curis√©.*

**Points cl√©s √† retenir :**
- La s√©curit√© commence d√®s la construction des images
- L'isolation et la limitation des privil√®ges sont essentielles
- Le monitoring et l'audit doivent √™tre continus
- Les outils automatis√©s compl√®tent mais ne remplacent pas les bonnes pratiques
- La formation des √©quipes est cruciale pour maintenir la s√©curit√©

**Pr√©paration pour la suite :**
Cette ma√Ætrise de Docker et de sa s√©curisation constitue la base indispensable pour aborder les conteneurs syst√®me (LXC/LXD) et les alternatives comme Podman dans les sections suivantes du module.

‚è≠Ô∏è
