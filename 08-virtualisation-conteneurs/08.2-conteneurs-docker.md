🔝 Retour au [Sommaire](/SOMMAIRE.md)

# 8.2 Conteneurs Docker

## Introduction

Docker révolutionne le déploiement d'applications en utilisant la conteneurisation. Contrairement aux machines virtuelles qui virtualisent le matériel complet, Docker partage le noyau du système hôte tout en isolant les applications dans des conteneurs légers et portables.

**Avantages de Docker :**
- **Légèreté** : démarrage en secondes vs minutes pour les VMs
- **Portabilité** : "Build once, run anywhere"
- **Efficacité** : utilisation optimale des ressources système
- **Isolation** : applications séparées sans interférence
- **Scalabilité** : facilité de mise à l'échelle horizontale
- **DevOps** : intégration parfaite dans les pipelines CI/CD

**Concepts clés :**
- **Image** : modèle de conteneur (comme un ISO pour VM)
- **Conteneur** : instance d'exécution d'une image
- **Dockerfile** : recette pour construire une image
- **Registry** : dépôt d'images (Docker Hub, registries privés)

---

## 8.2.1 Installation et configuration

### Installation de Docker sur Debian

**Méthode 1 : Installation depuis les dépôts officiels Docker**

```bash
# Suppression des anciennes versions
sudo apt remove docker docker-engine docker.io containerd runc

# Mise à jour et installation des prérequis
sudo apt update
sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release

# Ajout de la clé GPG officielle Docker
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Ajout du dépôt Docker
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Installation de Docker Engine
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

**Méthode 2 : Installation depuis les dépôts Debian (plus simple)**

```bash
# Installation directe depuis les dépôts Debian
sudo apt update
sudo apt install docker.io docker-compose

# Cette méthode installe une version légèrement plus ancienne mais stable
```

### Configuration post-installation

**Ajouter l'utilisateur au groupe docker :**
```bash
# Ajouter votre utilisateur au groupe docker
sudo usermod -aG docker $USER

# Appliquer les changements (se déconnecter/reconnecter ou utiliser)
newgrp docker

# Vérifier que vous pouvez exécuter docker sans sudo
docker run hello-world
```

**Configuration du daemon Docker :**
```bash
# Démarrage automatique de Docker
sudo systemctl enable docker
sudo systemctl start docker

# Vérifier l'état du service
sudo systemctl status docker

# Voir les informations système Docker
docker info
```

### Configuration avancée du daemon

**Fichier de configuration `/etc/docker/daemon.json` :**
```json
{
  "storage-driver": "overlay2",
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m",
    "max-file": "5"
  },
  "default-address-pools": [
    {
      "base": "172.17.0.0/16",
      "size": 24
    }
  ]
}
```

**Options importantes :**
- `storage-driver` : pilote de stockage (overlay2 recommandé)
- `log-driver` : format des logs
- `log-opts` : rotation automatique des logs
- `default-address-pools` : plages IP pour les réseaux Docker

### Première utilisation

**Commandes de base pour vérifier l'installation :**
```bash
# Version de Docker installée
docker --version

# Informations détaillées du système Docker
docker info

# Test avec le conteneur hello-world
docker run hello-world

# Lister les conteneurs en cours d'exécution
docker ps

# Lister tous les conteneurs (y compris arrêtés)
docker ps -a

# Lister les images disponibles localement
docker images
```

---

## 8.2.2 Images et conteneurs avancés

### Comprendre les images Docker

**Qu'est-ce qu'une image Docker ?**
Une image Docker est un modèle en lecture seule contenant :
- Le système de fichiers de base (OS minimal)
- L'application et ses dépendances
- Les variables d'environnement
- Les métadonnées de configuration

**Architecture en couches :**
```
┌─────────────────────┐
│   Application       │ ← Couche application
├─────────────────────┤
│   Dépendances      │ ← Couche runtime
├─────────────────────┤
│   OS de base       │ ← Couche système
└─────────────────────┘
```

### Gestion des images

**Recherche et téléchargement d'images :**
```bash
# Rechercher une image sur Docker Hub
docker search nginx

# Télécharger une image
docker pull nginx
docker pull nginx:1.21-alpine  # version spécifique

# Lister les images locales
docker images

# Supprimer une image
docker rmi nginx:latest

# Nettoyer les images non utilisées
docker image prune
```

**Inspection d'images :**
```bash
# Informations détaillées sur une image
docker inspect nginx

# Historique des couches d'une image
docker history nginx

# Taille détaillée par couche
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
```

### Création de conteneurs avancée

**Commande docker run complète :**
```bash
# Syntaxe de base
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

# Exemples d'utilisation avancée
docker run -d \
  --name mon-nginx \
  -p 8080:80 \
  -e NGINX_HOST=example.com \
  -v /host/data:/usr/share/nginx/html:ro \
  --restart unless-stopped \
  nginx:alpine
```

**Options importantes :**
- `-d` : exécution en arrière-plan (daemon)
- `--name` : nom personnalisé du conteneur
- `-p host:container` : mappage de ports
- `-e` : variables d'environnement
- `-v` : montage de volumes
- `--restart` : politique de redémarrage
- `--rm` : suppression automatique à l'arrêt

### Gestion du cycle de vie des conteneurs

**États d'un conteneur :**
1. **Created** : conteneur créé mais pas démarré
2. **Running** : conteneur en cours d'exécution
3. **Paused** : conteneur suspendu
4. **Stopped** : conteneur arrêté
5. **Deleted** : conteneur supprimé

**Commandes de gestion :**
```bash
# Démarrer un conteneur arrêté
docker start nom-conteneur

# Arrêter un conteneur
docker stop nom-conteneur

# Redémarrer un conteneur
docker restart nom-conteneur

# Mettre en pause/reprendre
docker pause nom-conteneur
docker unpause nom-conteneur

# Supprimer un conteneur
docker rm nom-conteneur

# Forcer la suppression d'un conteneur en cours
docker rm -f nom-conteneur
```

### Construction d'images avec Dockerfile

**Structure d'un Dockerfile :**
```dockerfile
# Commentaire : Image de base
FROM debian:12-slim

# Maintainer de l'image
LABEL maintainer="votre-email@example.com"

# Installation de paquets
RUN apt-get update && \
    apt-get install -y nginx && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Copie de fichiers depuis l'hôte
COPY nginx.conf /etc/nginx/nginx.conf
COPY website/ /var/www/html/

# Variables d'environnement
ENV NGINX_HOST=localhost

# Port exposé
EXPOSE 80

# Répertoire de travail
WORKDIR /var/www/html

# Commande par défaut
CMD ["nginx", "-g", "daemon off;"]
```

**Instructions Dockerfile importantes :**
- `FROM` : image de base
- `RUN` : exécuter des commandes lors de la construction
- `COPY/ADD` : copier des fichiers dans l'image
- `ENV` : définir des variables d'environnement
- `EXPOSE` : documenter les ports utilisés
- `WORKDIR` : répertoire de travail
- `CMD` : commande par défaut
- `ENTRYPOINT` : point d'entrée non modifiable

**Construction d'une image :**
```bash
# Construire une image depuis un Dockerfile
docker build -t mon-app:v1.0 .

# Construction avec arguments
docker build --build-arg VERSION=1.2.3 -t mon-app:v1.2.3 .

# Construction sans cache
docker build --no-cache -t mon-app:latest .
```

### Optimisation des images

**Bonnes pratiques pour des images légères :**

1. **Utiliser des images de base minimales :**
```dockerfile
# Préférer les images alpine (très petites)
FROM alpine:3.18
FROM python:3.11-alpine
FROM node:18-alpine
```

2. **Multi-stage builds :**
```dockerfile
# Stage de construction
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Stage final
FROM alpine:3.18
RUN apk add --no-cache nodejs npm
COPY --from=builder /app/node_modules ./node_modules
COPY . .
CMD ["node", "server.js"]
```

3. **Optimiser les couches :**
```dockerfile
# Mauvais : plusieurs couches RUN
RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get clean

# Bon : une seule couche RUN
RUN apt-get update && \
    apt-get install -y nginx && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

---

## 8.2.3 Docker Compose et orchestration

### Introduction à Docker Compose

**Docker Compose** permet de définir et gérer des applications multi-conteneurs avec un fichier YAML. Il simplifie :
- La définition de services multiples
- La gestion des dépendances entre conteneurs
- La configuration des réseaux et volumes
- Le déploiement coordonné de l'application complète

### Installation de Docker Compose

```bash
# Vérifier si Docker Compose est déjà installé
docker compose version

# Si pas installé, installation via le gestionnaire de paquets
sudo apt install docker-compose-plugin

# Ou installation manuelle (version récente)
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
```

### Structure d'un fichier docker-compose.yml

**Exemple simple : Application web + base de données**
```yaml
version: '3.8'

services:
  # Service web
  web:
    build: .                    # Construire depuis Dockerfile local
    ports:
      - "8080:80"              # Port mapping
    depends_on:
      - db                     # Dépendance vers la base
    environment:
      - DB_HOST=db
      - DB_NAME=myapp
    volumes:
      - ./app:/var/www/html    # Montage de code source
    restart: unless-stopped

  # Service base de données
  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=secret
      - MYSQL_DATABASE=myapp
    volumes:
      - db_data:/var/lib/mysql # Volume persistant
    restart: unless-stopped

# Définition des volumes
volumes:
  db_data:
```

### Commandes Docker Compose

**Gestion du cycle de vie :**
```bash
# Démarrer tous les services
docker compose up

# Démarrer en arrière-plan
docker compose up -d

# Reconstruire les images avant démarrage
docker compose up --build

# Arrêter tous les services
docker compose down

# Arrêter et supprimer volumes
docker compose down -v

# Voir l'état des services
docker compose ps

# Voir les logs
docker compose logs
docker compose logs web  # logs d'un service spécifique
```

**Gestion individuelle des services :**
```bash
# Démarrer un service spécifique
docker compose start web

# Arrêter un service
docker compose stop db

# Redémarrer un service
docker compose restart web

# Reconstruire un service
docker compose build web

# Exécuter une commande dans un service
docker compose exec web bash
```

### Exemple avancé : Stack LAMP

```yaml
version: '3.8'

services:
  # Serveur web Apache + PHP
  web:
    image: php:8.1-apache
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./website:/var/www/html
      - ./apache-config:/etc/apache2/sites-available
    depends_on:
      - db
    environment:
      - APACHE_DOCUMENT_ROOT=/var/www/html
    networks:
      - lamp-network

  # Base de données MySQL
  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD}
      - MYSQL_DATABASE=${DB_NAME}
      - MYSQL_USER=${DB_USER}
      - MYSQL_PASSWORD=${DB_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
      - ./init-scripts:/docker-entrypoint-initdb.d
    networks:
      - lamp-network

  # phpMyAdmin pour administration
  phpmyadmin:
    image: phpmyadmin:latest
    ports:
      - "8080:80"
    depends_on:
      - db
    environment:
      - PMA_HOST=db
      - PMA_USER=root
      - PMA_PASSWORD=${DB_ROOT_PASSWORD}
    networks:
      - lamp-network

volumes:
  mysql_data:

networks:
  lamp-network:
    driver: bridge
```

**Fichier `.env` pour les variables :**
```env
DB_ROOT_PASSWORD=motdepasse_root_securise
DB_NAME=mon_application
DB_USER=app_user
DB_PASSWORD=motdepasse_user_securise
```

### Orchestration avancée

**Mise à l'échelle des services :**
```bash
# Lancer plusieurs instances d'un service
docker compose up --scale web=3

# Équilibrage de charge avec nginx
# (nécessite configuration nginx upstream)
```

**Profils pour différents environnements :**
```yaml
version: '3.8'

services:
  web:
    image: nginx
    profiles: ["production", "development"]

  web-dev:
    image: nginx:alpine
    profiles: ["development"]
    volumes:
      - ./src:/usr/share/nginx/html

  db:
    image: mysql:8.0
    profiles: ["production"]

  db-dev:
    image: mysql:8.0
    profiles: ["development"]
    environment:
      - MYSQL_ROOT_PASSWORD=dev123
```

```bash
# Utiliser un profil spécifique
docker compose --profile development up
docker compose --profile production up
```

---

## 8.2.4 Volumes et réseaux

### Gestion des volumes Docker

**Types de stockage Docker :**

1. **Volumes** : gérés par Docker, recommandés pour la persistance
2. **Bind mounts** : montage direct de dossiers hôte
3. **tmpfs mounts** : stockage temporaire en mémoire

**Volumes Docker :**
```bash
# Créer un volume
docker volume create mon-volume

# Lister les volumes
docker volume ls

# Inspecter un volume
docker volume inspect mon-volume

# Supprimer un volume
docker volume rm mon-volume

# Nettoyer les volumes non utilisés
docker volume prune
```

**Utilisation des volumes :**
```bash
# Volume nommé
docker run -d -v mon-volume:/data nginx

# Bind mount (dossier hôte)
docker run -d -v /host/path:/container/path nginx

# Volume temporaire en mémoire
docker run -d --tmpfs /tmp nginx
```

### Configuration avancée des volumes

**Dans docker-compose.yml :**
```yaml
version: '3.8'

services:
  app:
    image: nginx
    volumes:
      # Volume nommé pour données persistantes
      - app_data:/var/lib/app

      # Bind mount pour développement
      - ./src:/usr/share/nginx/html:ro

      # Sous-chemin spécifique
      - app_data:/var/lib/app/uploads:rw

      # Volume temporaire
      - type: tmpfs
        target: /tmp
        tmpfs:
          size: 100M

volumes:
  app_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /opt/app-data
```

### Gestion des réseaux Docker

**Types de réseaux Docker :**

1. **bridge** : réseau par défaut, isolation des conteneurs
2. **host** : utilise directement la pile réseau de l'hôte
3. **none** : pas de réseau, isolation complète
4. **custom** : réseaux personnalisés pour segmentation

**Gestion des réseaux :**
```bash
# Lister les réseaux
docker network ls

# Créer un réseau personnalisé
docker network create mon-reseau

# Inspecter un réseau
docker network inspect bridge

# Connecter un conteneur à un réseau
docker network connect mon-reseau mon-conteneur

# Déconnecter un conteneur
docker network disconnect mon-reseau mon-conteneur

# Supprimer un réseau
docker network rm mon-reseau
```

### Configuration réseau avancée

**Réseau personnalisé avec sous-réseau :**
```bash
# Créer un réseau avec configuration IP
docker network create \
  --driver bridge \
  --subnet=172.20.0.0/16 \
  --ip-range=172.20.240.0/20 \
  --gateway=172.20.0.1 \
  mon-reseau-custom
```

**Dans docker-compose.yml :**
```yaml
version: '3.8'

services:
  web:
    image: nginx
    networks:
      - frontend
      - backend
    ports:
      - "80:80"

  api:
    image: node:alpine
    networks:
      - backend
      - database

  db:
    image: mysql:8.0
    networks:
      - database

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
  database:
    driver: bridge
    internal: true  # Pas d'accès internet
```

### Communication entre conteneurs

**Résolution DNS automatique :**
```bash
# Les conteneurs sur le même réseau peuvent se joindre par nom
docker run -d --name web nginx
docker run -d --name db mysql
docker run -it --rm alpine ping web  # fonctionne automatiquement
```

**Variables d'environnement pour la configuration :**
```yaml
version: '3.8'

services:
  app:
    image: mon-app
    environment:
      - DB_HOST=database
      - DB_PORT=3306
      - REDIS_URL=redis://cache:6379
    networks:
      - app-network

  database:
    image: mysql:8.0
    networks:
      - app-network

  cache:
    image: redis:alpine
    networks:
      - app-network

networks:
  app-network:
```

---

## 8.2.5 Registry privé et distribution

### Comprendre les registries Docker

**Qu'est-ce qu'un registry ?**
Un registry Docker est un service de stockage et distribution d'images Docker. Il permet de :
- Stocker des images de manière centralisée
- Partager des images entre équipes/environnements
- Gérer les versions et tags d'images
- Contrôler l'accès aux images

**Types de registries :**
- **Docker Hub** : registry public officiel
- **Registries cloud** : AWS ECR, Google GCR, Azure ACR
- **Registries privés** : Harbor, GitLab Registry, Nexus
- **Registry Docker officiel** : solution simple auto-hébergée

### Installation d'un registry privé

**Registry Docker officiel :**
```bash
# Démarrage d'un registry simple
docker run -d \
  --name registry \
  --restart unless-stopped \
  -p 5000:5000 \
  registry:2

# Registry avec stockage persistant
docker run -d \
  --name registry \
  --restart unless-stopped \
  -p 5000:5000 \
  -v registry_data:/var/lib/registry \
  registry:2
```

**Registry avec authentification :**
```bash
# Créer un utilisateur/mot de passe
mkdir auth
docker run --rm \
  --entrypoint htpasswd \
  httpd:2 -Bbn testuser testpassword > auth/htpasswd

# Démarrer le registry avec authentification
docker run -d \
  --name registry \
  --restart unless-stopped \
  -p 5000:5000 \
  -v $(pwd)/auth:/auth \
  -v registry_data:/var/lib/registry \
  -e "REGISTRY_AUTH=htpasswd" \
  -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" \
  -e "REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd" \
  registry:2
```

### Configuration avancée avec Docker Compose

```yaml
version: '3.8'

services:
  registry:
    image: registry:2
    ports:
      - "5000:5000"
    environment:
      # Configuration du stockage
      REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY: /var/lib/registry

      # Configuration de l'authentification
      REGISTRY_AUTH: htpasswd
      REGISTRY_AUTH_HTPASSWD_REALM: "Registry Realm"
      REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd

      # Configuration HTTPS
      REGISTRY_HTTP_TLS_CERTIFICATE: /certs/domain.crt
      REGISTRY_HTTP_TLS_KEY: /certs/domain.key

      # Configuration des logs
      REGISTRY_LOG_LEVEL: info

    volumes:
      - registry_data:/var/lib/registry
      - ./auth:/auth
      - ./certs:/certs
    restart: unless-stopped

  # Interface web pour le registry
  registry-ui:
    image: joxit/docker-registry-ui:static
    ports:
      - "8080:80"
    environment:
      - REGISTRY_TITLE=Mon Registry Privé
      - REGISTRY_URL=http://registry:5000
      - DELETE_IMAGES=true
    depends_on:
      - registry

volumes:
  registry_data:
```

### Utilisation d'un registry privé

**Configuration du client Docker :**
```bash
# Pour un registry HTTP (non-sécurisé)
# Éditer /etc/docker/daemon.json
{
  "insecure-registries": ["192.168.1.100:5000"]
}

# Redémarrer Docker
sudo systemctl restart docker
```

**Authentification sur le registry :**
```bash
# Se connecter au registry privé
docker login localhost:5000
# ou
docker login 192.168.1.100:5000

# Vérifier la connexion
docker info | grep -A 5 "Registry"
```

**Pousser et récupérer des images :**
```bash
# Tagger une image pour le registry privé
docker tag mon-app:latest localhost:5000/mon-app:v1.0

# Pousser l'image
docker push localhost:5000/mon-app:v1.0

# Récupérer l'image
docker pull localhost:5000/mon-app:v1.0

# Lister les images du registry (via API)
curl -X GET http://localhost:5000/v2/_catalog
curl -X GET http://localhost:5000/v2/mon-app/tags/list
```

### Registry avec Harbor

**Harbor** est une solution de registry entreprise avec interface web complète :

```yaml
# docker-compose.yml pour Harbor
version: '3.8'

services:
  harbor-core:
    image: goharbor/harbor-core:v2.8.0
    depends_on:
      - registry
      - postgresql
      - redis
    volumes:
      - /data/harbor/common/config:/etc/core/app.conf
      - /data/harbor/ca_download/:/etc/core/ca/
    environment:
      - CORE_SECRET=your-secret-key

  registry:
    image: goharbor/registry-photon:v2.8.0
    volumes:
      - /data/harbor/registry:/storage

  postgresql:
    image: goharbor/harbor-db:v2.8.0
    environment:
      - POSTGRES_PASSWORD=root123
    volumes:
      - /data/harbor/database:/var/lib/postgresql/data

  redis:
    image: goharbor/redis-photon:v2.8.0
    volumes:
      - /data/harbor/redis:/var/lib/redis
```

### Stratégies de distribution

**Multi-registry pour haute disponibilité :**
```yaml
version: '3.8'

services:
  # Registry principal
  registry-primary:
    image: registry:2
    ports:
      - "5000:5000"
    volumes:
      - primary_data:/var/lib/registry

  # Registry miroir
  registry-mirror:
    image: registry:2
    ports:
      - "5001:5000"
    environment:
      REGISTRY_PROXY_REMOTEURL: http://registry-primary:5000
    volumes:
      - mirror_data:/var/lib/registry

volumes:
  primary_data:
  mirror_data:
```

---

## 8.2.6 Sécurité des conteneurs

### Principes de sécurité des conteneurs

**Défis spécifiques aux conteneurs :**
- **Partage du noyau** : vulnérabilité kernel = risque pour tous les conteneurs
- **Surface d'attaque élargie** : plus de composants à sécuriser
- **Images non vérifiées** : risque de malware dans les images
- **Privilèges élevés** : conteneurs root par défaut
- **Secrets management** : gestion des credentials

### Exécution de conteneurs non-privilégiés

**Utilisateur non-root dans les conteneurs :**
```dockerfile
# Dans le Dockerfile
FROM debian:12-slim

# Créer un utilisateur non-privilégié
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Installer l'application
COPY app /opt/app
RUN chown -R appuser:appuser /opt/app

# Basculer vers l'utilisateur non-root
USER appuser

CMD ["/opt/app/start.sh"]
```

**Exécution avec utilisateur spécifique :**
```bash
# Spécifier l'utilisateur lors de l'exécution
docker run --user 1000:1000 mon-image

# Ou dans docker-compose.yml
version: '3.8'
services:
  app:
    image: mon-app
    user: "1000:1000"
```

### Limitation des capacités et privilèges

**Retrait des capacités dangereuses :**
```bash
# Supprimer toutes les capacités puis ajouter seulement celles nécessaires
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx

# Exécution sans privilèges
docker run --security-opt=no-new-privileges nginx
```

**Configuration dans docker-compose.yml :**
```yaml
version: '3.8'

services:
  web:
    image: nginx
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
      - /var/cache/nginx
```

### Sécurisation des images

**Scanning des vulnérabilités :**
```bash
# Utiliser docker scan (nécessite Docker Desktop ou plugin)
docker scan mon-image:latest

# Utiliser Trivy (outil opensource)
# Installation
sudo apt install wget apt-transport-https gnupg
wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
echo "deb https://aquasecurity.github.io/trivy-repo/deb generic main" | sudo tee -a /etc/apt/sources.list
sudo apt update && sudo apt install trivy

# Scanner une image
trivy image nginx:latest
trivy image --severity HIGH,CRITICAL mon-app:latest
```

**Bonnes pratiques pour images sécurisées :**

1. **Images de base minimales :**
```dockerfile
# Préférer les images distroless ou alpine
FROM gcr.io/distroless/java:11
# ou
FROM alpine:3.18
```

2. **Mise à jour des paquets :**
```dockerfile
FROM debian:12-slim
RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y mon-package && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

3. **Vérification des signatures :**
```bash
# Vérifier la signature d'une image
docker trust inspect --pretty nginx:latest

# Activer la vérification des signatures
export DOCKER_CONTENT_TRUST=1
docker pull nginx:latest
```

### Gestion sécurisée des secrets

**Éviter les secrets dans les images :**
```dockerfile
# Mauvais : secret dans l'image
ENV API_KEY=secret123

# Bon : secret via variable d'environnement au runtime
ENV API_KEY=""
```

**Docker Secrets (Swarm mode) :**
```bash
# Créer un secret
echo "motdepasse_db" | docker secret create db_password -

# Utiliser le secret dans un service
docker service create \
  --name webapp \
  --secret db_password \
  mon-app:latest
```

# 8.2 Conteneurs Docker - Suite (Sécurité)

## Gestion sécurisée des secrets (suite)

**Gestion via fichiers externes :**
```yaml
version: '3.8'

services:
  app:
    image: mon-app
    environment:
      - DB_PASSWORD_FILE=/run/secrets/db_password
    secrets:
      - db_password
    volumes:
      - ./config:/app/config:ro

secrets:
  db_password:
    file: ./secrets/db_password.txt
```

**Utilisation de variables d'environnement sécurisées :**
```bash
# Fichier .env (ne jamais commiter en Git)
DB_PASSWORD=motdepasse_securise
API_KEY=cle_api_secrete

# Dans docker-compose.yml
version: '3.8'
services:
  app:
    image: mon-app
    environment:
      - DB_PASSWORD=${DB_PASSWORD}
      - API_KEY=${API_KEY}
```

**Outils externes pour secrets :**
```yaml
# Intégration avec HashiCorp Vault
version: '3.8'

services:
  app:
    image: mon-app
    environment:
      - VAULT_ADDR=https://vault.example.com
      - VAULT_TOKEN_FILE=/run/secrets/vault_token
    secrets:
      - vault_token

secrets:
  vault_token:
    external: true
```

### Isolation réseau et pare-feu

**Segmentation réseau :**
```yaml
version: '3.8'

services:
  # Frontend accessible depuis internet
  nginx:
    image: nginx
    ports:
      - "80:80"
      - "443:443"
    networks:
      - frontend

  # Backend accessible seulement depuis frontend
  api:
    image: mon-api
    networks:
      - frontend
      - backend
    # Pas de ports exposés vers l'hôte

  # Base de données isolée
  database:
    image: mysql:8.0
    networks:
      - backend
    environment:
      - MYSQL_ROOT_PASSWORD_FILE=/run/secrets/db_root_password
    secrets:
      - db_root_password

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true  # Pas d'accès internet

secrets:
  db_root_password:
    file: ./secrets/db_root_password.txt
```

**Configuration de pare-feu pour Docker :**
```bash
# Docker modifie automatiquement iptables
# Voir les règles Docker
sudo iptables -L DOCKER

# Bloquer l'accès externe à un port spécifique
sudo iptables -I DOCKER-USER -p tcp --dport 5432 -j DROP

# Autoriser seulement un sous-réseau spécifique
sudo iptables -I DOCKER-USER -s 192.168.1.0/24 -p tcp --dport 5432 -j ACCEPT
```

### Contrôle d'accès et authentification

**Authentification multi-facteur pour registry :**
```yaml
# docker-compose.yml avec authentification avancée
version: '3.8'

services:
  registry:
    image: registry:2
    environment:
      # Authentification LDAP
      REGISTRY_AUTH: ldap
      REGISTRY_AUTH_LDAP_ADDR: ldap://ldap.example.com:389
      REGISTRY_AUTH_LDAP_BASEDN: dc=example,dc=com
      REGISTRY_AUTH_LDAP_BINDDN: cn=admin,dc=example,dc=com
      REGISTRY_AUTH_LDAP_BINDPASSWORD_FILE: /run/secrets/ldap_password
    secrets:
      - ldap_password

secrets:
  ldap_password:
    file: ./secrets/ldap_password.txt
```

**Intégration avec systèmes d'authentification :**
```bash
# Authentification via token JWT
docker login -u oauth2accesstoken -p "$(gcloud auth print-access-token)" gcr.io

# Authentification via AWS ECR
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 123456789.dkr.ecr.us-east-1.amazonaws.com
```

### Monitoring et logging sécurisé

**Configuration des logs sécurisés :**
```yaml
version: '3.8'

services:
  app:
    image: mon-app
    logging:
      driver: "syslog"
      options:
        syslog-address: "tcp://log-server:514"
        syslog-facility: "local0"
        tag: "{{.Name}}/{{.ID}}"

  # Collecteur de logs centralisé
  logstash:
    image: logstash:8.7.0
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline:ro
      - ./logstash/config:/usr/share/logstash/config:ro
    ports:
      - "514:514/tcp"
      - "514:514/udp"
```

**Monitoring de sécurité avec Falco :**
```yaml
version: '3.8'

services:
  # Falco pour détection d'intrusion runtime
  falco:
    image: falcosecurity/falco:latest
    privileged: true
    volumes:
      - /var/run/docker.sock:/host/var/run/docker.sock
      - /dev:/host/dev
      - /proc:/host/proc:ro
      - /boot:/host/boot:ro
      - /lib/modules:/host/lib/modules:ro
      - /usr:/host/usr:ro
      - /etc:/host/etc:ro
    environment:
      - FALCO_GRPC_BIND_ADDRESS=0.0.0.0:5060
    ports:
      - "5060:5060"

  # Application surveillée
  app:
    image: mon-app
    security_opt:
      - apparmor:docker-default
    read_only: true
    tmpfs:
      - /tmp:noexec,nosuid
```

### AppArmor et SELinux

**Configuration AppArmor pour conteneurs :**
```bash
# Vérifier si AppArmor est actif
sudo aa-status

# Profil AppArmor pour Docker
sudo nano /etc/apparmor.d/docker-nginx

# Contenu du profil
profile docker-nginx flags=(attach_disconnected,mediate_deleted) {
  #include <abstractions/base>

  # Autoriser lecture seule du système de fichiers
  /usr/share/nginx/** r,
  /etc/nginx/** r,

  # Interdire l'accès au système
  deny /proc/sys/** w,
  deny /sys/** w,
}

# Charger le profil
sudo apparmor_parser -r /etc/apparmor.d/docker-nginx
```

**Utilisation dans Docker :**
```bash
# Appliquer un profil AppArmor
docker run --security-opt apparmor=docker-nginx nginx

# Dans docker-compose.yml
version: '3.8'
services:
  web:
    image: nginx
    security_opt:
      - apparmor:docker-nginx
```

### Outils d'audit et conformité

**Docker Bench Security :**
```bash
# Installation et exécution
git clone https://github.com/docker/docker-bench-security.git
cd docker-bench-security
sudo ./docker-bench-security.sh

# Génération d'un rapport
sudo ./docker-bench-security.sh -l /tmp/docker-bench-report.log
```

**Audit avec Lynis :**
```bash
# Installation de Lynis
sudo apt install lynis

# Audit spécifique aux conteneurs
sudo lynis audit system --tests-from-group containers

# Rapport détaillé
sudo lynis audit system --no-colors --quiet --report-file /tmp/lynis-report.dat
```

**CIS Benchmarks pour Docker :**
```bash
# Vérifications automatiques selon les standards CIS
# Exemple de vérifications importantes :

# 1. Utilisateur non-root dans les conteneurs
docker inspect mon-conteneur | grep -i user

# 2. Vérification des capacités
docker inspect mon-conteneur | grep -i cap

# 3. Vérification des montages sensibles
docker inspect mon-conteneur | grep -A 10 -i mounts

# 4. Vérification de la configuration réseau
docker network ls
docker network inspect bridge
```

### Réponse aux incidents de sécurité

**Procédures d'urgence :**
```bash
# Arrêt d'urgence de tous les conteneurs
docker stop $(docker ps -q)

# Isolation d'un conteneur suspect
docker network disconnect bridge conteneur-suspect

# Collecte d'informations forensiques
docker logs conteneur-suspect > /tmp/incident-logs.txt
docker exec conteneur-suspect ps aux > /tmp/incident-processes.txt

# Sauvegarde de l'état du conteneur
docker commit conteneur-suspect evidence:$(date +%Y%m%d-%H%M%S)
```

**Script d'audit automatique :**
```bash
#!/bin/bash
# audit-docker-security.sh

echo "=== Audit de sécurité Docker ==="
echo "Date: $(date)"

echo "1. Conteneurs en cours d'exécution avec privilèges root:"
docker ps --format "table {{.Names}}\t{{.Image}}" | xargs -I {} docker inspect {} | grep -B 5 -A 5 '"User": ""'

echo "2. Conteneurs avec accès au socket Docker:"
docker ps --format "table {{.Names}}\t{{.Image}}" | xargs -I {} docker inspect {} | grep -B 2 -A 2 "/var/run/docker.sock"

echo "3. Ports exposés publiquement:"
docker ps --format "table {{.Names}}\t{{.Ports}}"

echo "4. Volumes montés depuis l'hôte:"
docker ps --format "table {{.Names}}\t{{.Image}}" | xargs -I {} docker inspect {} | grep -B 2 -A 2 '"Type": "bind"'

echo "5. Images sans tag (potentiellement non vérifiées):"
docker images | grep "<none>"

echo "=== Fin de l'audit ==="
```

### Hardening du daemon Docker

**Configuration sécurisée du daemon :**
```json
{
  "storage-driver": "overlay2",
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m",
    "max-file": "5"
  },
  "live-restore": true,
  "userland-proxy": false,
  "no-new-privileges": true,
  "selinux-enabled": true,
  "userns-remap": "default",
  "disable-legacy-registry": true,
  "experimental": false
}
```

**Options importantes :**
- `userns-remap` : isolation des utilisateurs
- `no-new-privileges` : empêche l'escalade de privilèges
- `selinux-enabled` : active SELinux si disponible
- `disable-legacy-registry` : sécurise les communications registry

**Sécurisation du socket Docker :**
```bash
# Accès via TLS uniquement
sudo mkdir -p /etc/docker/certs.d/
sudo openssl genrsa -aes256 -out ca-key.pem 4096
sudo openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem

# Configuration dans daemon.json
{
  "hosts": ["tcp://0.0.0.0:2376"],
  "tls": true,
  "tlsverify": true,
  "tlscert": "/etc/docker/certs.d/server-cert.pem",
  "tlskey": "/etc/docker/certs.d/server-key.pem",
  "tlscacert": "/etc/docker/certs.d/ca.pem"
}
```

## Résumé et bonnes pratiques de sécurité

### Checklist de sécurité Docker

**Images :**
- ✅ Utiliser des images officielles ou vérifiées
- ✅ Scanner les vulnérabilités régulièrement
- ✅ Utiliser des images minimales (alpine, distroless)
- ✅ Mettre à jour régulièrement les images de base
- ✅ Ne jamais inclure de secrets dans les images

**Conteneurs :**
- ✅ Exécuter avec utilisateur non-root
- ✅ Utiliser read-only filesystem quand possible
- ✅ Limiter les capacités Linux (--cap-drop=ALL)
- ✅ Appliquer des profils de sécurité (AppArmor/SELinux)
- ✅ Éviter le mode privilégié (--privileged)

**Réseau :**
- ✅ Utiliser des réseaux personnalisés
- ✅ Segmenter les applications (frontend/backend/db)
- ✅ Exposer seulement les ports nécessaires
- ✅ Utiliser un reverse proxy pour l'exposition

**Stockage :**
- ✅ Éviter les bind mounts sensibles (/var/run/docker.sock)
- ✅ Utiliser des volumes Docker plutôt que bind mounts
- ✅ Chiffrer les données sensibles
- ✅ Nettoyer régulièrement les volumes non utilisés

**Monitoring :**
- ✅ Centraliser les logs
- ✅ Surveiller les activités suspectes
- ✅ Mettre en place des alertes
- ✅ Auditer régulièrement la configuration

### Outils recommandés

**Scanning de sécurité :**
- **Trivy** : scanner de vulnérabilités images/conteneurs
- **Clair** : scanner CoreOS pour registries
- **Anchore** : analyse statique de sécurité
- **Docker Scout** : service officiel Docker

**Runtime Security :**
- **Falco** : détection d'intrusion runtime
- **Sysdig** : monitoring et sécurité conteneurs
- **Aqua Security** : plateforme sécurité complète

**Conformité :**
- **Docker Bench** : audit CIS benchmarks
- **Kube-score** : analyse configurations Kubernetes
- **Polaris** : validation bonnes pratiques

### Perspectives et évolution

**Tendances sécurité conteneurs :**
- **Zero Trust Architecture** : vérification continue
- **Rootless containers** : exécution sans privilèges
- **Confidential computing** : chiffrement en mémoire
- **Supply chain security** : sécurisation de la chaîne de build

**Technologies émergentes :**
- **WebAssembly (WASM)** : isolation renforcée
- **Unikernels** : surface d'attaque minimale
- **eBPF** : monitoring kernel avancé

---

*La sécurité des conteneurs est un processus continu qui nécessite une approche en couches. De la construction sécurisée des images jusqu'au monitoring runtime, chaque étape doit être prise en compte pour maintenir un environnement conteneurisé robuste et sécurisé.*

**Points clés à retenir :**
- La sécurité commence dès la construction des images
- L'isolation et la limitation des privilèges sont essentielles
- Le monitoring et l'audit doivent être continus
- Les outils automatisés complètent mais ne remplacent pas les bonnes pratiques
- La formation des équipes est cruciale pour maintenir la sécurité

**Préparation pour la suite :**
Cette maîtrise de Docker et de sa sécurisation constitue la base indispensable pour aborder les conteneurs système (LXC/LXD) et les alternatives comme Podman dans les sections suivantes du module.

⏭️
