üîù Retour au [Sommaire](/SOMMAIRE.md)

# 9.1 Introduction √† Kubernetes

*Module 9 - Kubernetes et orchestration | Niveau : Avanc√©*

## Vue d'ensemble

Kubernetes (souvent abr√©g√© "K8s") est une plateforme d'orchestration de conteneurs open-source qui automatise le d√©ploiement, la mise √† l'√©chelle et la gestion des applications conteneuris√©es. D√©velopp√© par Google et maintenu par la Cloud Native Computing Foundation (CNCF), Kubernetes est devenu le standard de facto pour l'orchestration de conteneurs.

**Pourquoi Kubernetes ?**
- Automatisation du d√©ploiement et de la gestion des conteneurs
- Haute disponibilit√© et r√©silience des applications
- Mise √† l'√©chelle automatique selon la charge
- Gestion centralis√©e des configurations et secrets
- √âcosyst√®me riche d'outils et d'extensions

---

## 9.1.1 Architecture et concepts fondamentaux

### Architecture g√©n√©rale

Kubernetes suit une architecture ma√Ætre-n≈ìud (control plane/worker nodes) :

#### Control Plane (Plan de contr√¥le)
Le control plane g√®re l'√©tat global du cluster et prend les d√©cisions de planification.

**Composants principaux :**

- **API Server** (`kube-apiserver`)
  - Point d'entr√©e unique pour toutes les requ√™tes REST
  - Interface entre les utilisateurs, les outils et les composants internes
  - Valide et traite les requ√™tes API
  - Stocke l'√©tat dans etcd

- **etcd**
  - Base de donn√©es distribu√©e cl√©-valeur
  - Stocke toute la configuration et l'√©tat du cluster
  - Source de v√©rit√© unique pour Kubernetes
  - Hautement disponible et coh√©rent

- **Scheduler** (`kube-scheduler`)
  - Assigne les pods aux n≈ìuds disponibles
  - Prend en compte les ressources, contraintes et politiques
  - Optimise la r√©partition des charges de travail

- **Controller Manager** (`kube-controller-manager`)
  - Ex√©cute les contr√¥leurs qui r√©gulent l'√©tat du cluster
  - Surveille l'√©tat d√©sir√© vs l'√©tat actuel
  - Exemples : ReplicaSet Controller, Node Controller, Service Controller

#### Worker Nodes (N≈ìuds de travail)
Les worker nodes ex√©cutent les applications conteneuris√©es.

**Composants principaux :**

- **kubelet**
  - Agent qui s'ex√©cute sur chaque n≈ìud
  - Communique avec l'API Server
  - G√®re le cycle de vie des pods
  - Surveille la sant√© des conteneurs

- **kube-proxy**
  - Proxy r√©seau qui maintient les r√®gles r√©seau
  - Impl√©mente les Services Kubernetes
  - G√®re le load balancing entre les pods

- **Container Runtime**
  - Ex√©cute les conteneurs (Docker, containerd, CRI-O)
  - Interface avec kubelet via CRI (Container Runtime Interface)

### Concepts fondamentaux

#### Objets Kubernetes
Kubernetes utilise des objets pour repr√©senter l'√©tat de votre cluster :

- **Objets de base** : Pod, Service, Volume, Namespace
- **Contr√¥leurs** : ReplicaSet, Deployment, StatefulSet, DaemonSet
- **Configuration** : ConfigMap, Secret
- **Acc√®s** : ServiceAccount, Role, RoleBinding

#### √âtat d√©sir√© vs √âtat actuel
- Vous d√©clarez l'√©tat d√©sir√© via des manifestes YAML/JSON
- Kubernetes travaille continuellement pour maintenir cet √©tat
- Les contr√¥leurs surveillent et corrigent les √©carts

#### Labels et Selectors
- **Labels** : paires cl√©-valeur attach√©es aux objets
- **Selectors** : queries pour s√©lectionner des objets par leurs labels
- M√©canisme fondamental pour organiser et s√©lectionner les ressources

---

## 9.1.2 Pods, Services, Deployments

### Pods

Le **Pod** est l'unit√© de d√©ploiement la plus petite dans Kubernetes.

#### Caract√©ristiques des Pods :
- Contient un ou plusieurs conteneurs (g√©n√©ralement un seul)
- Les conteneurs d'un pod partagent :
  - La m√™me adresse IP
  - Le m√™me stockage (volumes)
  - Le m√™me cycle de vie
- √âph√©m√®re par nature (peuvent √™tre cr√©√©s/d√©truits)

#### Exemple de Pod simple :
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mon-pod
  labels:
    app: web
spec:
  containers:
  - name: nginx
    image: nginx:1.20
    ports:
    - containerPort: 80
```

#### Bonnes pratiques :
- Un conteneur principal par pod
- Utiliser des contr√¥leurs plut√¥t que des pods nus
- D√©finir des limites de ressources
- Configurer des health checks

### Services

Les **Services** exposent les applications et g√®rent la connectivit√© r√©seau.

#### Types de Services :

**ClusterIP (par d√©faut)**
- Accessible uniquement depuis l'int√©rieur du cluster
- Fournit un point d'acc√®s stable pour les pods

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mon-service
spec:
  selector:
    app: web
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
```

**NodePort**
- Expose le service sur un port de chaque n≈ìud
- Accessible depuis l'ext√©rieur du cluster

```yaml
apiVersion: v1
kind: Service
metadata:
  name: mon-service-nodeport
spec:
  selector:
    app: web
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30080
  type: NodePort
```

**LoadBalancer**
- Cr√©e un load balancer externe (cloud provider)
- Assigne une IP externe au service

**ExternalName**
- Mappe un service √† un nom DNS externe

### Deployments

Les **Deployments** g√®rent le d√©ploiement et la mise √† jour des applications.

#### Fonctionnalit√©s cl√©s :
- Gestion d√©clarative des ReplicaSets
- Mises √† jour progressives (rolling updates)
- Rollback automatique en cas d'√©chec
- Mise √† l'√©chelle des applications

#### Exemple de Deployment :
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.20
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
```

#### Strat√©gies de d√©ploiement :
- **RollingUpdate** : met √† jour progressivement les pods
- **Recreate** : supprime tous les pods avant de cr√©er les nouveaux

---

## 9.1.3 Namespaces et RBAC

### Namespaces

Les **Namespaces** permettent de diviser logiquement un cluster Kubernetes.

#### Utilit√© des Namespaces :
- Isolation des ressources entre √©quipes/projets
- S√©paration des environnements (dev, staging, prod)
- Application de quotas de ressources
- Organisation et gouvernance

#### Namespaces par d√©faut :
- **default** : namespace par d√©faut pour les objets sans namespace sp√©cifi√©
- **kube-system** : objets cr√©√©s par le syst√®me Kubernetes
- **kube-public** : ressources publiques, lisibles par tous
- **kube-node-lease** : objets lease des n≈ìuds (heartbeat)

#### Cr√©ation d'un Namespace :
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: mon-namespace
  labels:
    environment: production
```

#### Utilisation :
```bash
# Lister les namespaces
kubectl get namespaces

# Cr√©er des ressources dans un namespace
kubectl apply -f mon-deployment.yaml -n mon-namespace

# Configurer le namespace par d√©faut
kubectl config set-context --current --namespace=mon-namespace
```

### RBAC (Role-Based Access Control)

Le **RBAC** contr√¥le qui peut faire quoi dans le cluster Kubernetes.

#### Composants RBAC :

**Subjects (Sujets)**
- **User** : utilisateurs humains
- **Group** : groupes d'utilisateurs
- **ServiceAccount** : comptes pour les applications

**Resources (Ressources)**
- Objets Kubernetes (pods, services, deployments...)
- Group√©s par API groups

**Verbs (Verbes)**
- Actions possibles : get, list, create, update, patch, delete, watch

#### Roles et ClusterRoles

**Role** : permissions dans un namespace sp√©cifique
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: mon-namespace
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

**ClusterRole** : permissions au niveau du cluster
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cluster-reader
rules:
- apiGroups: [""]
  resources: ["nodes", "persistentvolumes"]
  verbs: ["get", "list"]
```

#### RoleBindings et ClusterRoleBindings

**RoleBinding** : lie un Role/ClusterRole √† des sujets dans un namespace
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: mon-namespace
subjects:
- kind: User
  name: alice
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

**ClusterRoleBinding** : lie un ClusterRole √† des sujets au niveau cluster

#### ServiceAccounts
```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: mon-service-account
  namespace: mon-namespace
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: mon-service-account-binding
  namespace: mon-namespace
subjects:
- kind: ServiceAccount
  name: mon-service-account
  namespace: mon-namespace
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

---

## 9.1.4 Installation sur Debian (kubeadm)

### Pr√©requis syst√®me

Avant d'installer Kubernetes, assurez-vous que votre syst√®me Debian r√©pond aux exigences :

#### Configuration minimale :
- **RAM** : 2 GB minimum (4 GB recommand√©s pour le control plane)
- **CPU** : 2 c≈ìurs minimum
- **Stockage** : 20 GB d'espace libre
- **R√©seau** : Connexion entre tous les n≈ìuds

#### Pr√©paration du syst√®me :
```bash
# Mettre √† jour le syst√®me
sudo apt update && sudo apt upgrade -y

# Installer les paquets n√©cessaires
sudo apt install -y apt-transport-https ca-certificates curl gnupg lsb-release

# D√©sactiver le swap (requis par Kubernetes)
sudo swapoff -a
sudo sed -i '/swap/d' /etc/fstab

# Configurer les modules kernel
cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

# Configurer les param√®tres syst√®me
cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

sudo sysctl --system
```

### Installation du container runtime

Kubernetes n√©cessite un container runtime. Nous utiliserons containerd :

```bash
# Installer containerd
sudo apt install -y containerd

# Cr√©er la configuration par d√©faut
sudo mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml

# Configurer systemd cgroup driver
sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

# Red√©marrer containerd
sudo systemctl restart containerd
sudo systemctl enable containerd
```

### Installation de kubeadm, kubelet et kubectl

```bash
# Ajouter la cl√© GPG de Kubernetes
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

# Ajouter le d√©p√¥t Kubernetes
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

# Mettre √† jour la liste des paquets
sudo apt update

# Installer kubeadm, kubelet et kubectl
sudo apt install -y kubelet kubeadm kubectl

# Emp√™cher la mise √† jour automatique
sudo apt-mark hold kubelet kubeadm kubectl

# Activer kubelet
sudo systemctl enable --now kubelet
```

### Initialisation du cluster

#### Sur le n≈ìud master :
```bash
# Initialiser le cluster
sudo kubeadm init --pod-network-cidr=192.168.0.0/16

# Configurer kubectl pour l'utilisateur normal
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config

# V√©rifier l'√©tat du cluster
kubectl get nodes
kubectl get pods -A
```

#### Installation d'un plugin r√©seau (CNI)

Kubernetes n√©cessite un plugin r√©seau pour la communication entre pods. Calico est un choix populaire :

```bash
# Installer Calico
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/tigera-operator.yaml
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/custom-resources.yaml

# Attendre que tous les pods soient pr√™ts
kubectl get pods -n calico-system --watch
```

### Ajout de n≈ìuds worker

Pour ajouter des n≈ìuds worker au cluster :

#### Sur les n≈ìuds worker :
```bash
# Utiliser la commande fournie lors de l'init du master
sudo kubeadm join <MASTER-IP>:6443 --token <TOKEN> --discovery-token-ca-cert-hash sha256:<HASH>
```

#### Si vous avez perdu la commande de join :
```bash
# Sur le master, recr√©er le token
kubeadm token create --print-join-command
```

### V√©rification de l'installation

```bash
# V√©rifier les n≈ìuds
kubectl get nodes

# V√©rifier les composants syst√®me
kubectl get pods -n kube-system

# V√©rifier la sant√© du cluster
kubectl cluster-info

# Tester avec un pod simple
kubectl run test-pod --image=nginx
kubectl get pods
kubectl delete pod test-pod
```

### Configuration suppl√©mentaire

#### Permettre la planification sur le master (optionnel pour dev) :
```bash
kubectl taint nodes --all node-role.kubernetes.io/control-plane-
```

#### Configuration de bash completion :
```bash
# Installer bash completion
sudo apt install -y bash-completion

# Ajouter √† ~/.bashrc
echo 'source <(kubectl completion bash)' >> ~/.bashrc
echo 'alias k=kubectl' >> ~/.bashrc
echo 'complete -o default -F __start_kubectl k' >> ~/.bashrc

# Recharger la configuration
source ~/.bashrc
```

### D√©pannage courant

#### Probl√®mes fr√©quents et solutions :

**1. Les pods restent en √©tat "Pending"**
```bash
# V√©rifier les √©v√©nements
kubectl describe pod <pod-name>
kubectl get events --sort-by=.metadata.creationTimestamp
```

**2. Probl√®mes r√©seau entre pods**
```bash
# V√©rifier le plugin CNI
kubectl get pods -n kube-system | grep calico
kubectl logs -n kube-system <calico-pod-name>
```

**3. kubelet ne d√©marre pas**
```bash
# V√©rifier les logs
sudo journalctl -xeu kubelet
sudo systemctl status kubelet
```

**4. Probl√®mes de certificats**
```bash
# V√©rifier les certificats
sudo kubeadm certs check-expiration
```

### Maintenance et mise √† jour

#### Sauvegarde d'etcd :
```bash
sudo ETCDCTL_API=3 etcdctl snapshot save snapshot.db \
  --endpoints=https://127.0.0.1:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key
```

#### Mise √† jour du cluster :
```bash
# Mise √† jour de kubeadm
sudo apt update
sudo apt-mark unhold kubeadm
sudo apt install -y kubeadm=1.28.x-00
sudo apt-mark hold kubeadm

# Planifier la mise √† jour
sudo kubeadm upgrade plan
sudo kubeadm upgrade apply v1.28.x

# Mettre √† jour kubelet et kubectl
sudo apt-mark unhold kubelet kubectl
sudo apt install -y kubelet=1.28.x-00 kubectl=1.28.x-00
sudo apt-mark hold kubelet kubectl
sudo systemctl daemon-reload
sudo systemctl restart kubelet
```

---

## Conclusion

Cette introduction vous a pr√©sent√© les concepts fondamentaux de Kubernetes et la proc√©dure d'installation sur Debian. Kubernetes est un outil puissant mais complexe qui n√©cessite de la pratique pour √™tre ma√Ætris√©.

**Points cl√©s √† retenir :**
- Architecture distribu√©e avec control plane et worker nodes
- Objets fondamentaux : Pods, Services, Deployments
- Isolation et s√©curit√© via Namespaces et RBAC
- Installation pas √† pas avec kubeadm sur Debian

**Prochaines √©tapes :**
- Explorer les workloads plus avanc√©s (StatefulSets, DaemonSets)
- Approfondir la configuration r√©seau et du stockage
- √âtudier les outils de l'√©cosyst√®me (Helm, Ingress Controllers)
- Pratiquer avec des applications r√©elles

Kubernetes ouvre la voie vers une infrastructure moderne, scalable et r√©siliente. La courbe d'apprentissage peut √™tre raide, mais les b√©n√©fices en termes d'automatisation et de fiabilit√© sont consid√©rables.

‚è≠Ô∏è
