üîù Retour au [Sommaire](/SOMMAIRE.md)

# 10.1 Terraform - Guide complet pour d√©butants

## Introduction √† Terraform

Terraform est un outil d'Infrastructure as Code d√©velopp√© par HashiCorp qui vous permet de d√©finir, d√©ployer et g√©rer votre infrastructure √† travers des fichiers de configuration. Contrairement aux scripts traditionnels, Terraform utilise une approche d√©clarative : vous d√©crivez l'√©tat final souhait√© de votre infrastructure, et Terraform se charge de d√©terminer et d'ex√©cuter les actions n√©cessaires pour l'atteindre.

### Pourquoi Terraform ?

**Multi-cloud :** Terraform peut g√©rer des ressources sur AWS, Azure, Google Cloud, VMware, et des centaines d'autres providers, y compris des services on-premise.

**√âtat g√©r√© :** Terraform maintient un fichier d'√©tat qui lui permet de savoir quelles ressources il g√®re et de d√©tecter les changements.

**Plan avant application :** Vous pouvez toujours voir ce que Terraform va faire avant qu'il ne le fasse r√©ellement.

**√âcosyst√®me riche :** Des milliers de providers et modules disponibles dans le Terraform Registry.

## 10.1.1 Installation sur Debian

### Installation via le repository officiel HashiCorp

Cette m√©thode est recommand√©e car elle vous permet de recevoir les mises √† jour automatiquement.

```bash
# Mise √† jour des paquets
sudo apt update

# Installation des d√©pendances
sudo apt install -y gnupg software-properties-common

# Ajout de la cl√© GPG HashiCorp
wget -O- https://apt.releases.hashicorp.com/gpg | \
    gpg --dearmor | \
    sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg

# V√©rification de l'empreinte de la cl√©
gpg --no-default-keyring \
    --keyring /usr/share/keyrings/hashicorp-archive-keyring.gpg \
    --fingerprint

# Ajout du repository HashiCorp
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] \
    https://apt.releases.hashicorp.com $(lsb_release -cs) main" | \
    sudo tee /etc/apt/sources.list.d/hashicorp.list

# Mise √† jour et installation de Terraform
sudo apt update
sudo apt install terraform
```

### Installation manuelle (alternative)

Si vous pr√©f√©rez installer manuellement ou si vous avez besoin d'une version sp√©cifique :

```bash
# Cr√©ation du r√©pertoire pour les binaires locaux
mkdir -p ~/bin

# T√©l√©chargement de la derni√®re version (remplacez VERSION par la version souhait√©e)
VERSION="1.6.6"
wget https://releases.hashicorp.com/terraform/${VERSION}/terraform_${VERSION}_linux_amd64.zip

# Installation d'unzip si n√©cessaire
sudo apt install unzip

# Extraction et installation
unzip terraform_${VERSION}_linux_amd64.zip
mv terraform ~/bin/

# Ajout au PATH (ajoutez cette ligne √† votre ~/.bashrc)
export PATH="$HOME/bin:$PATH"

# Rechargement du shell
source ~/.bashrc
```

### V√©rification de l'installation

```bash
# V√©rification de la version install√©e
terraform version

# Affichage de l'aide
terraform --help
```

### Configuration de l'autocompl√©tion

L'autocompl√©tion facilite grandement l'utilisation de Terraform :

```bash
# Installation de l'autocompl√©tion pour bash
terraform -install-autocomplete

# Rechargement du shell
source ~/.bashrc
```

## 10.1.2 Providers et ressources

### Comprendre les providers

Un **provider** dans Terraform est un plugin qui permet d'interagir avec une API sp√©cifique (AWS, Azure, Docker, Kubernetes, etc.). Chaque provider expose des **ressources** et des **sources de donn√©es**.

### Structure d'un fichier Terraform

Les fichiers Terraform utilisent l'extension `.tf` et sont √©crits en HCL (HashiCorp Configuration Language).

#### Exemple basique : Provider Docker

Cr√©ons un exemple simple avec Docker pour comprendre les concepts :

```hcl
# main.tf

# Configuration du provider Terraform
terraform {
  required_version = ">= 1.0"
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0"
    }
  }
}

# Configuration du provider Docker
provider "docker" {
  host = "unix:///var/run/docker.sock"
}

# Ressource : Image Docker
resource "docker_image" "nginx" {
  name         = "nginx:latest"
  keep_locally = false
}

# Ressource : Conteneur Docker
resource "docker_container" "web" {
  image = docker_image.nginx.image_id
  name  = "tutorial-nginx"

  ports {
    internal = 80
    external = 8080
  }
}
```

### Anatomie d'une ressource

```hcl
resource "TYPE" "NAME" {
  argument1 = "value1"
  argument2 = "value2"

  nested_block {
    nested_argument = "value"
  }
}
```

- **TYPE** : Le type de ressource (ex: `docker_container`, `aws_instance`)
- **NAME** : Un nom unique dans votre configuration
- **Arguments** : Les param√®tres de configuration de la ressource

### Variables et outputs

#### Variables d'entr√©e

Les variables permettent de param√©trer vos configurations :

```hcl
# variables.tf

variable "container_name" {
  description = "Nom du conteneur Docker"
  type        = string
  default     = "my-nginx"
}

variable "external_port" {
  description = "Port externe expos√©"
  type        = number
  default     = 8080

  validation {
    condition     = var.external_port > 1024 && var.external_port < 65536
    error_message = "Le port doit √™tre entre 1024 et 65535."
  }
}

variable "environment" {
  description = "Environnement de d√©ploiement"
  type        = string

  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "L'environnement doit √™tre dev, staging ou prod."
  }
}
```

#### Utilisation des variables

```hcl
# main.tf

resource "docker_container" "web" {
  image = docker_image.nginx.image_id
  name  = "${var.environment}-${var.container_name}"

  ports {
    internal = 80
    external = var.external_port
  }

  labels {
    environment = var.environment
    managed_by  = "terraform"
  }
}
```

#### Variables d'environnement

Vous pouvez d√©finir les valeurs des variables de plusieurs fa√ßons :

```bash
# Via des variables d'environnement
export TF_VAR_environment="dev"
export TF_VAR_container_name="web-server"

# Via un fichier terraform.tfvars
echo 'environment = "dev"' > terraform.tfvars
echo 'container_name = "web-server"' >> terraform.tfvars
echo 'external_port = 9090' >> terraform.tfvars

# Via la ligne de commande
terraform apply -var="environment=dev" -var="external_port=9090"
```

#### Outputs

Les outputs permettent d'exposer des informations sur les ressources cr√©√©es :

```hcl
# outputs.tf

output "container_id" {
  description = "ID du conteneur Docker cr√©√©"
  value       = docker_container.web.id
}

output "container_name" {
  description = "Nom complet du conteneur"
  value       = docker_container.web.name
}

output "access_url" {
  description = "URL d'acc√®s au conteneur"
  value       = "http://localhost:${var.external_port}"
}
```

### Sources de donn√©es (Data Sources)

Les sources de donn√©es permettent de r√©cup√©rer des informations sur des ressources existantes :

```hcl
# R√©cup√©ration d'informations sur une image Docker existante
data "docker_image" "ubuntu" {
  name = "ubuntu:22.04"
}

# Utilisation dans une ressource
resource "docker_container" "app" {
  image = data.docker_image.ubuntu.image_id
  name  = "ubuntu-container"

  # La ressource sera recr√©√©e si l'image change
  command = ["sleep", "infinity"]
}
```

### Providers cloud populaires

#### AWS Provider

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "eu-west-1"
}

resource "aws_instance" "web" {
  ami           = "ami-0abcdef1234567890"
  instance_type = "t3.micro"

  tags = {
    Name = "WebServer"
  }
}
```

#### Azure Provider

```hcl
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {}
}

resource "azurerm_resource_group" "main" {
  name     = "rg-terraform-demo"
  location = "West Europe"
}
```

## 10.1.3 √âtat et backend S3/Consul

### Comprendre l'√©tat Terraform

L'**√©tat** (state) est un fichier JSON que Terraform utilise pour mapper les ressources de votre configuration aux ressources r√©elles. Par d√©faut, ce fichier (`terraform.tfstate`) est stock√© localement.

#### Pourquoi l'√©tat est-il important ?

1. **Mapping** : Associe les ressources de la configuration aux ressources r√©elles
2. **M√©tadonn√©es** : Stocke les informations n√©cessaires pour g√©rer les ressources
3. **Performance** : √âvite d'interroger tous les providers √† chaque fois
4. **Collaboration** : Permet √† plusieurs personnes de travailler sur la m√™me infrastructure

### Probl√®mes de l'√©tat local

**Collaboration difficile :** Chaque d√©veloppeur a son propre fichier d'√©tat local.

**Risque de perte :** Si le fichier local est supprim√©, Terraform perd la trace des ressources.

**Conflits :** Plusieurs personnes peuvent modifier l'infrastructure simultan√©ment.

**Pas de versioning :** Difficile de revenir en arri√®re en cas de probl√®me.

### Backends distants

Un **backend** d√©finit o√π et comment l'√©tat est stock√© et comment les op√©rations sont ex√©cut√©es.

#### Backend S3 (Amazon Web Services)

Le backend S3 est l'un des plus populaires pour stocker l'√©tat Terraform.

##### Pr√©paration de l'infrastructure S3

```hcl
# backend-setup.tf (√† ex√©cuter une seule fois)

# Bucket S3 pour stocker l'√©tat
resource "aws_s3_bucket" "terraform_state" {
  bucket = "my-company-terraform-state-bucket"
}

# Versioning du bucket
resource "aws_s3_bucket_versioning" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id
  versioning_configuration {
    status = "Enabled"
  }
}

# Chiffrement du bucket
resource "aws_s3_bucket_server_side_encryption_configuration" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Blocage de l'acc√®s public
resource "aws_s3_bucket_public_access_block" "terraform_state" {
  bucket = aws_s3_bucket.terraform_state.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# Table DynamoDB pour le verrouillage de l'√©tat
resource "aws_dynamodb_table" "terraform_state_lock" {
  name           = "terraform-state-lock"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "LockID"

  attribute {
    name = "LockID"
    type = "S"
  }

  tags = {
    Name = "Terraform State Lock Table"
  }
}
```

##### Configuration du backend S3

```hcl
# main.tf

terraform {
  backend "s3" {
    bucket         = "my-company-terraform-state-bucket"
    key            = "prod/infrastructure.tfstate"
    region         = "eu-west-1"
    dynamodb_table = "terraform-state-lock"
    encrypt        = true
  }

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
```

##### Initialisation avec le backend

```bash
# Initialisation du backend (premi√®re fois)
terraform init

# Migration d'un √©tat local vers S3
terraform init -migrate-state
```

#### Backend Consul

Consul est une solution de HashiCorp pour la d√©couverte de services et le stockage de configuration.

##### Installation de Consul sur Debian

```bash
# Ajout du repository HashiCorp (si pas d√©j√† fait)
curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"

# Installation de Consul
sudo apt update
sudo apt install consul
```

##### Configuration basique de Consul

```bash
# Cr√©ation du r√©pertoire de configuration
sudo mkdir -p /etc/consul.d

# Configuration de base
sudo tee /etc/consul.d/consul.hcl > /dev/null <<EOF
datacenter = "dc1"
data_dir = "/opt/consul"
log_level = "INFO"
server = true
bootstrap_expect = 1
bind_addr = "127.0.0.1"
client_addr = "127.0.0.1"
retry_join = ["127.0.0.1"]
ui_config {
  enabled = true
}
connect {
  enabled = true
}
EOF

# D√©marrage de Consul
sudo systemctl enable consul
sudo systemctl start consul
sudo systemctl status consul
```

##### Configuration du backend Consul

```hcl
# main.tf

terraform {
  backend "consul" {
    address = "127.0.0.1:8500"
    scheme  = "http"
    path    = "terraform/myproject"
  }

  required_providers {
    # vos providers ici
  }
}
```

### Gestion avanc√©e de l'√©tat

#### Commandes utiles pour l'√©tat

```bash
# Affichage de l'√©tat actuel
terraform show

# Liste des ressources dans l'√©tat
terraform state list

# Affichage d'une ressource sp√©cifique
terraform state show docker_container.web

# Import d'une ressource existante
terraform import docker_container.web container_id

# Suppression d'une ressource de l'√©tat (sans la d√©truire)
terraform state rm docker_container.web

# Renommage d'une ressource dans l'√©tat
terraform state mv docker_container.web docker_container.nginx

# Actualisation de l'√©tat
terraform refresh
```

#### Verrouillage de l'√©tat (State Locking)

Le verrouillage emp√™che plusieurs op√©rations Terraform de s'ex√©cuter simultan√©ment :

```bash
# Terraform verrouille automatiquement lors des op√©rations
terraform apply

# Forcer le d√©verrouillage si n√©cessaire (ATTENTION !)
terraform force-unlock LOCK_ID
```

#### Sauvegarde et r√©cup√©ration

```bash
# Sauvegarde de l'√©tat actuel
terraform state pull > backup.tfstate

# Restauration depuis une sauvegarde
terraform state push backup.tfstate
```

## 10.1.4 Modules et bonnes pratiques

### Comprendre les modules Terraform

Un **module** est un ensemble de fichiers Terraform dans un r√©pertoire. Chaque configuration Terraform comporte au moins un module, appel√© module racine, constitu√© des fichiers `.tf` dans le r√©pertoire de travail principal.

### Pourquoi utiliser des modules ?

**R√©utilisabilit√© :** √âviter la duplication de code entre projets.

**Organisation :** Structurer le code de mani√®re logique et maintenable.

**Abstraction :** Masquer la complexit√© derri√®re une interface simple.

**Tests :** Faciliter les tests unitaires de composants d'infrastructure.

**Collaboration :** Permettre aux √©quipes de partager des composants standards.

### Structure d'un module

```
modules/
‚îî‚îÄ‚îÄ vpc/
    ‚îú‚îÄ‚îÄ main.tf          # Ressources principales
    ‚îú‚îÄ‚îÄ variables.tf     # Variables d'entr√©e
    ‚îú‚îÄ‚îÄ outputs.tf       # Variables de sortie
    ‚îú‚îÄ‚îÄ versions.tf      # Versions des providers
    ‚îî‚îÄ‚îÄ README.md        # Documentation
```

#### Exemple : Module VPC AWS

```hcl
# modules/vpc/variables.tf

variable "vpc_cidr" {
  description = "CIDR block pour le VPC"
  type        = string
  default     = "10.0.0.0/16"
}

variable "environment" {
  description = "Nom de l'environnement"
  type        = string
}

variable "availability_zones" {
  description = "Liste des zones de disponibilit√©"
  type        = list(string)
}

variable "private_subnet_cidrs" {
  description = "CIDR blocks pour les sous-r√©seaux priv√©s"
  type        = list(string)
}

variable "public_subnet_cidrs" {
  description = "CIDR blocks pour les sous-r√©seaux publics"
  type        = list(string)
}

variable "enable_nat_gateway" {
  description = "Activer NAT Gateway pour les sous-r√©seaux priv√©s"
  type        = bool
  default     = true
}

variable "tags" {
  description = "Tags √† appliquer aux ressources"
  type        = map(string)
  default     = {}
}
```

```hcl
# modules/vpc/main.tf

# VPC principal
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = merge(var.tags, {
    Name        = "${var.environment}-vpc"
    Environment = var.environment
  })
}

# Internet Gateway
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = merge(var.tags, {
    Name        = "${var.environment}-igw"
    Environment = var.environment
  })
}

# Sous-r√©seaux publics
resource "aws_subnet" "public" {
  count = length(var.public_subnet_cidrs)

  vpc_id                  = aws_vpc.main.id
  cidr_block              = var.public_subnet_cidrs[count.index]
  availability_zone       = var.availability_zones[count.index]
  map_public_ip_on_launch = true

  tags = merge(var.tags, {
    Name        = "${var.environment}-public-subnet-${count.index + 1}"
    Environment = var.environment
    Type        = "public"
  })
}

# Sous-r√©seaux priv√©s
resource "aws_subnet" "private" {
  count = length(var.private_subnet_cidrs)

  vpc_id            = aws_vpc.main.id
  cidr_block        = var.private_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]

  tags = merge(var.tags, {
    Name        = "${var.environment}-private-subnet-${count.index + 1}"
    Environment = var.environment
    Type        = "private"
  })
}

# Elastic IP pour NAT Gateway
resource "aws_eip" "nat" {
  count = var.enable_nat_gateway ? length(var.public_subnet_cidrs) : 0

  domain = "vpc"
  depends_on = [aws_internet_gateway.main]

  tags = merge(var.tags, {
    Name        = "${var.environment}-nat-eip-${count.index + 1}"
    Environment = var.environment
  })
}

# NAT Gateway
resource "aws_nat_gateway" "main" {
  count = var.enable_nat_gateway ? length(var.public_subnet_cidrs) : 0

  allocation_id = aws_eip.nat[count.index].id
  subnet_id     = aws_subnet.public[count.index].id

  tags = merge(var.tags, {
    Name        = "${var.environment}-nat-gateway-${count.index + 1}"
    Environment = var.environment
  })

  depends_on = [aws_internet_gateway.main]
}

# Table de routage pour les sous-r√©seaux publics
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = merge(var.tags, {
    Name        = "${var.environment}-public-rt"
    Environment = var.environment
  })
}

# Tables de routage pour les sous-r√©seaux priv√©s
resource "aws_route_table" "private" {
  count = length(var.private_subnet_cidrs)

  vpc_id = aws_vpc.main.id

  dynamic "route" {
    for_each = var.enable_nat_gateway ? [1] : []
    content {
      cidr_block     = "0.0.0.0/0"
      nat_gateway_id = aws_nat_gateway.main[count.index].id
    }
  }

  tags = merge(var.tags, {
    Name        = "${var.environment}-private-rt-${count.index + 1}"
    Environment = var.environment
  })
}

# Associations des tables de routage publiques
resource "aws_route_table_association" "public" {
  count = length(var.public_subnet_cidrs)

  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

# Associations des tables de routage priv√©es
resource "aws_route_table_association" "private" {
  count = length(var.private_subnet_cidrs)

  subnet_id      = aws_subnet.private[count.index].id
  route_table_id = aws_route_table.private[count.index].id
}
```

```hcl
# modules/vpc/outputs.tf

output "vpc_id" {
  description = "ID du VPC cr√©√©"
  value       = aws_vpc.main.id
}

output "vpc_cidr" {
  description = "CIDR block du VPC"
  value       = aws_vpc.main.cidr_block
}

output "public_subnet_ids" {
  description = "IDs des sous-r√©seaux publics"
  value       = aws_subnet.public[*].id
}

output "private_subnet_ids" {
  description = "IDs des sous-r√©seaux priv√©s"
  value       = aws_subnet.private[*].id
}

output "internet_gateway_id" {
  description = "ID de l'Internet Gateway"
  value       = aws_internet_gateway.main.id
}

output "nat_gateway_ids" {
  description = "IDs des NAT Gateways"
  value       = aws_nat_gateway.main[*].id
}

output "public_route_table_id" {
  description = "ID de la table de routage publique"
  value       = aws_route_table.public.id
}

output "private_route_table_ids" {
  description = "IDs des tables de routage priv√©es"
  value       = aws_route_table.private[*].id
}
```

### Utilisation du module

```hcl
# main.tf (module racine)

module "vpc" {
  source = "./modules/vpc"

  vpc_cidr             = "10.0.0.0/16"
  environment          = "production"
  availability_zones   = ["eu-west-1a", "eu-west-1b", "eu-west-1c"]
  public_subnet_cidrs  = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  private_subnet_cidrs = ["10.0.11.0/24", "10.0.12.0/24", "10.0.13.0/24"]
  enable_nat_gateway   = true

  tags = {
    Project = "MyApp"
    Owner   = "DevOps Team"
  }
}

# Utilisation des outputs du module
resource "aws_security_group" "web" {
  name_prefix = "web-"
  vpc_id      = module.vpc.vpc_id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "web-security-group"
  }
}
```

### Modules du Terraform Registry

Le [Terraform Registry](https://registry.terraform.io/) contient des milliers de modules pr√™ts √† utiliser.

#### Utilisation d'un module public

```hcl
# Utilisation du module VPC officiel AWS
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  name = "my-vpc"
  cidr = "10.0.0.0/16"

  azs             = ["eu-west-1a", "eu-west-1b", "eu-west-1c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]

  enable_nat_gateway = true
  enable_vpn_gateway = true

  tags = {
    Terraform = "true"
    Environment = "dev"
  }
}
```

### Bonnes pratiques pour les modules

#### Structure et organisation

**Un module, une responsabilit√© :** Chaque module doit avoir un objectif clair et d√©fini.

**Documentation compl√®te :** README.md avec examples, inputs, outputs.

**Versioning s√©mantique :** Utilisez des tags Git pour versionner vos modules.

**Tests automatis√©s :** Utilisez des outils comme Terratest pour tester vos modules.

#### Conception des interfaces

```hcl
# Bonnes pratiques pour les variables

variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string

  validation {
    condition = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}

variable "tags" {
  description = "A map of tags to assign to the resource"
  type        = map(string)
  default     = {}
}

variable "enable_monitoring" {
  description = "Enable monitoring for the resources"
  type        = bool
  default     = false
}
```

#### Gestion des versions

```hcl
# versions.tf dans chaque module

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.0"
    }
  }
}
```

### Bonnes pratiques g√©n√©rales Terraform

#### Organisation des fichiers

```
project/
‚îú‚îÄ‚îÄ environments/
‚îÇ   ‚îú‚îÄ‚îÄ dev/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ terraform.tfvars
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ outputs.tf
‚îÇ   ‚îú‚îÄ‚îÄ staging/
‚îÇ   ‚îî‚îÄ‚îÄ prod/
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ vpc/
‚îÇ   ‚îú‚îÄ‚îÄ ec2/
‚îÇ   ‚îî‚îÄ‚îÄ rds/
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ README.md
```

#### Nommage des ressources

```hcl
# Utilisez un naming pattern coh√©rent
resource "aws_instance" "web" {
  # Format recommand√© : environment-application-component-index
  tags = {
    Name = "${var.environment}-web-server-${count.index + 1}"
  }
}
```

#### Gestion des secrets

```hcl
# NE JAMAIS stocker de secrets dans le code
variable "database_password" {
  description = "Password for the database"
  type        = string
  sensitive   = true
}

# Utiliser des sources externes pour les secrets
data "aws_secretsmanager_secret_version" "db_password" {
  secret_id = "database-password"
}
```

#### Utilisation des locals

```hcl
# Utilisez locals pour les calculs et transformations
locals {
  common_tags = {
    Environment = var.environment
    Project     = var.project_name
    ManagedBy   = "terraform"
  }

  instance_count = var.environment == "prod" ? 3 : 1

  subnet_cidrs = [
    for i in range(var.subnet_count) :
    cidrsubnet(var.vpc_cidr, 8, i)
  ]
}
```

#### Formatage et validation

```bash
# Formatage automatique du code
terraform fmt -recursive

# Validation de la syntaxe
terraform validate

# V√©rification de s√©curit√© avec tfsec
tfsec .

# Analyse statique avec checkov
checkov -d .
```

#### Pipeline CI/CD

##### Exemple GitLab CI complet

```yaml
# .gitlab-ci.yml

stages:
  - validate
  - security
  - plan
  - apply
  - destroy

variables:
  TF_ROOT: ${CI_PROJECT_DIR}/environments/${ENVIRONMENT}
  TF_VERSION: "1.6.6"
  TF_IMAGE: hashicorp/terraform:${TF_VERSION}

# Template de base pour les jobs Terraform
.terraform_template: &terraform_template
  image: ${TF_IMAGE}
  before_script:
    - cd $TF_ROOT
    - terraform --version
    - terraform init

# Validation de la syntaxe et du formatage
validate:
  <<: *terraform_template
  stage: validate
  script:
    - terraform validate
    - terraform fmt -check -recursive
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Analyse de s√©curit√©
security_scan:
  image: aquasec/tfsec:latest
  stage: security
  script:
    - tfsec $TF_ROOT --format json --out tfsec-report.json
    - tfsec $TF_ROOT
  artifacts:
    reports:
      junit: tfsec-report.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Compliance check avec Checkov
compliance_check:
  image: bridgecrew/checkov:latest
  stage: security
  script:
    - checkov -d $TF_ROOT --framework terraform --output cli --output junitxml --output-file-path console,checkov-report.xml
  artifacts:
    reports:
      junit: checkov-report.xml
    expire_in: 1 week
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Plan pour les merge requests
plan_mr:
  <<: *terraform_template
  stage: plan
  script:
    - terraform plan -no-color -out=plan.tfplan
    - terraform show -no-color plan.tfplan > plan.txt
  artifacts:
    paths:
      - $TF_ROOT/plan.tfplan
      - $TF_ROOT/plan.txt
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Plan pour la branche principale
plan_main:
  <<: *terraform_template
  stage: plan
  script:
    - terraform plan -no-color -out=plan.tfplan
    - terraform show -no-color plan.tfplan
  artifacts:
    paths:
      - $TF_ROOT/plan.tfplan
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Application des changements (manuel pour prod)
apply_dev:
  <<: *terraform_template
  stage: apply
  script:
    - terraform apply -auto-approve plan.tfplan
  dependencies:
    - plan_main
  environment:
    name: development
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $ENVIRONMENT == "dev"
      when: on_success

apply_prod:
  <<: *terraform_template
  stage: apply
  script:
    - terraform apply -auto-approve plan.tfplan
  dependencies:
    - plan_main
  environment:
    name: production
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $ENVIRONMENT == "prod"
      when: manual

# Destruction d'environnement (manuel uniquement)
destroy:
  <<: *terraform_template
  stage: destroy
  script:
    - terraform destroy -auto-approve
  environment:
    name: ${ENVIRONMENT}
    action: stop
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: false
```

##### Exemple GitHub Actions

```yaml
# .github/workflows/terraform.yml

name: 'Terraform CI/CD'

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  TF_VERSION: '1.6.6'
  AWS_REGION: 'eu-west-1'

jobs:
  terraform-check:
    name: 'Terraform Check'
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Format Check
      run: terraform fmt -check -recursive

    - name: Terraform Init
      run: terraform init -backend=false

    - name: Terraform Validate
      run: terraform validate

  security-scan:
    name: 'Security Scan'
    runs-on: ubuntu-latest
    needs: terraform-check

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Run tfsec
      uses: aquasecurity/tfsec-action@v1.0.3
      with:
        soft_fail: true
        format: sarif
        output: tfsec.sarif

    - name: Upload SARIF file
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: tfsec.sarif

  terraform-plan:
    name: 'Terraform Plan'
    runs-on: ubuntu-latest
    needs: [terraform-check, security-scan]
    strategy:
      matrix:
        environment: [dev, staging, prod]

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Terraform Init
      working-directory: ./environments/${{ matrix.environment }}
      run: terraform init

    - name: Terraform Plan
      working-directory: ./environments/${{ matrix.environment }}
      run: |
        terraform plan -no-color -out=tfplan
        terraform show -no-color tfplan > plan.txt

    - name: Upload Plan
      uses: actions/upload-artifact@v3
      with:
        name: tfplan-${{ matrix.environment }}
        path: |
          ./environments/${{ matrix.environment }}/tfplan
          ./environments/${{ matrix.environment }}/plan.txt

  terraform-apply:
    name: 'Terraform Apply'
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: github.ref == 'refs/heads/main'
    strategy:
      matrix:
        environment: [dev]
        include:
          - environment: staging
            manual: true
          - environment: prod
            manual: true

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download Plan
      uses: actions/download-artifact@v3
      with:
        name: tfplan-${{ matrix.environment }}
        path: ./environments/${{ matrix.environment }}

    - name: Terraform Init
      working-directory: ./environments/${{ matrix.environment }}
      run: terraform init

    - name: Terraform Apply
      working-directory: ./environments/${{ matrix.environment }}
      run: terraform apply -auto-approve tfplan
```

#### Gestion des environnements multiples

##### Structure recommand√©e pour les environnements

```
terraform-infrastructure/
‚îú‚îÄ‚îÄ environments/
‚îÇ   ‚îú‚îÄ‚îÄ dev/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ terraform.tfvars
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ backend.tf
‚îÇ   ‚îú‚îÄ‚îÄ staging/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ terraform.tfvars
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ backend.tf
‚îÇ   ‚îî‚îÄ‚îÄ prod/
‚îÇ       ‚îú‚îÄ‚îÄ main.tf
‚îÇ       ‚îú‚îÄ‚îÄ variables.tf
‚îÇ       ‚îú‚îÄ‚îÄ outputs.tf
‚îÇ       ‚îú‚îÄ‚îÄ terraform.tfvars
‚îÇ       ‚îî‚îÄ‚îÄ backend.tf
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ vpc/
‚îÇ   ‚îú‚îÄ‚îÄ eks/
‚îÇ   ‚îú‚îÄ‚îÄ rds/
‚îÇ   ‚îî‚îÄ‚îÄ monitoring/
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îú‚îÄ‚îÄ variables.tf
‚îÇ   ‚îî‚îÄ‚îÄ locals.tf
‚îî‚îÄ‚îÄ scripts/
    ‚îú‚îÄ‚îÄ deploy.sh
    ‚îî‚îÄ‚îÄ destroy.sh
```

##### Configuration par environnement

###### Environnement de d√©veloppement

```hcl
# environments/dev/terraform.tfvars

environment = "dev"
region      = "eu-west-1"

# VPC Configuration
vpc_cidr = "10.10.0.0/16"
availability_zones = ["eu-west-1a", "eu-west-1b"]

# Instance sizing for development
instance_type = "t3.micro"
min_size     = 1
max_size     = 2
desired_size = 1

# Database configuration
db_instance_class    = "db.t3.micro"
db_allocated_storage = 20
db_backup_retention  = 1

# Monitoring
enable_detailed_monitoring = false
log_retention_days        = 7

# Cost optimization
enable_nat_gateway = false
enable_flow_logs   = false
```

###### Environnement de production

```hcl
# environments/prod/terraform.tfvars

environment = "prod"
region      = "eu-west-1"

# VPC Configuration
vpc_cidr = "10.0.0.0/16"
availability_zones = ["eu-west-1a", "eu-west-1b", "eu-west-1c"]

# Instance sizing for production
instance_type = "t3.medium"
min_size     = 3
max_size     = 10
desired_size = 3

# Database configuration
db_instance_class    = "db.t3.medium"
db_allocated_storage = 100
db_backup_retention  = 30
db_multi_az         = true

# Monitoring
enable_detailed_monitoring = true
log_retention_days        = 30

# High availability
enable_nat_gateway = true
enable_flow_logs   = true
```

##### Scripts d'automatisation

###### Script de d√©ploiement

```bash
#!/bin/bash
# scripts/deploy.sh

set -e

# Configuration
ENVIRONMENT=${1:-dev}
ACTION=${2:-plan}
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ENV_DIR="$PROJECT_ROOT/environments/$ENVIRONMENT"

# Validation des param√®tres
if [[ ! -d "$ENV_DIR" ]]; then
    echo "‚ùå Environnement '$ENVIRONMENT' n'existe pas"
    echo "Environnements disponibles:"
    ls -1 "$PROJECT_ROOT/environments/"
    exit 1
fi

if [[ ! "$ACTION" =~ ^(plan|apply|destroy)$ ]]; then
    echo "‚ùå Action invalide: $ACTION"
    echo "Actions disponibles: plan, apply, destroy"
    exit 1
fi

# Functions
log() {
    echo "üîß $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error() {
    echo "‚ùå $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
    exit 1
}

success() {
    echo "‚úÖ $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

# V√©rification des pr√©requis
check_prerequisites() {
    log "V√©rification des pr√©requis..."

    if ! command -v terraform &> /dev/null; then
        error "Terraform n'est pas install√©"
    fi

    if ! command -v aws &> /dev/null; then
        error "AWS CLI n'est pas install√©"
    fi

    # V√©rification des credentials AWS
    if ! aws sts get-caller-identity &> /dev/null; then
        error "Credentials AWS non configur√©s"
    fi

    success "Pr√©requis valid√©s"
}

# Initialisation Terraform
terraform_init() {
    log "Initialisation de Terraform pour l'environnement: $ENVIRONMENT"
    cd "$ENV_DIR"

    terraform init \
        -reconfigure \
        -upgrade=true

    success "Terraform initialis√©"
}

# Validation de la configuration
terraform_validate() {
    log "Validation de la configuration Terraform..."
    cd "$ENV_DIR"

    terraform fmt -check -recursive || {
        log "Formatage automatique des fichiers..."
        terraform fmt -recursive
    }

    terraform validate
    success "Configuration valid√©e"
}

# Plan Terraform
terraform_plan() {
    log "G√©n√©ration du plan Terraform..."
    cd "$ENV_DIR"

    terraform plan \
        -var-file="terraform.tfvars" \
        -out="terraform.tfplan" \
        -detailed-exitcode

    local exit_code=$?

    case $exit_code in
        0)
            success "Aucun changement d√©tect√©"
            ;;
        1)
            error "Erreur lors de la g√©n√©ration du plan"
            ;;
        2)
            success "Plan g√©n√©r√© avec succ√®s - Changements d√©tect√©s"
            ;;
    esac
}

# Application du plan
terraform_apply() {
    log "Application du plan Terraform..."
    cd "$ENV_DIR"

    if [[ ! -f "terraform.tfplan" ]]; then
        error "Aucun plan trouv√©. Ex√©cutez d'abord: $0 $ENVIRONMENT plan"
    fi

    # Confirmation pour la production
    if [[ "$ENVIRONMENT" == "prod" ]]; then
        echo "‚ö†Ô∏è  Vous √™tes sur le point de modifier l'environnement de PRODUCTION"
        read -p "√ätes-vous s√ªr ? (oui/non): " confirm
        if [[ ! "$confirm" =~ ^(oui|yes|y)$ ]]; then
            log "Op√©ration annul√©e"
            exit 0
        fi
    fi

    terraform apply terraform.tfplan
    success "Infrastructure d√©ploy√©e avec succ√®s"
}

# Destruction de l'infrastructure
terraform_destroy() {
    log "Destruction de l'infrastructure..."
    cd "$ENV_DIR"

    echo "‚ö†Ô∏è  ATTENTION: Vous allez d√©truire l'infrastructure de l'environnement: $ENVIRONMENT"
    echo "Cette action est IRR√âVERSIBLE"
    read -p "Tapez 'destroy' pour confirmer: " confirm

    if [[ "$confirm" != "destroy" ]]; then
        log "Op√©ration annul√©e"
        exit 0
    fi

    terraform destroy \
        -var-file="terraform.tfvars" \
        -auto-approve

    success "Infrastructure d√©truite"
}

# Main execution
main() {
    log "D√©marrage du d√©ploiement: $ENVIRONMENT ($ACTION)"

    check_prerequisites
    terraform_init
    terraform_validate

    case "$ACTION" in
        plan)
            terraform_plan
            ;;
        apply)
            terraform_plan
            terraform_apply
            ;;
        destroy)
            terraform_destroy
            ;;
    esac

    success "Op√©ration termin√©e avec succ√®s"
}

# Help function
show_help() {
    cat << EOF
Usage: $0 <environment> <action>

Environments:
  dev      - Environnement de d√©veloppement
  staging  - Environnement de test
  prod     - Environnement de production

Actions:
  plan     - G√©n√®re et affiche le plan d'ex√©cution
  apply    - Applique les changements (inclut plan)
  destroy  - D√©truit l'infrastructure

Examples:
  $0 dev plan          # Plan pour l'environnement dev
  $0 prod apply        # D√©ploiement en production
  $0 staging destroy   # Destruction de l'environnement staging

EOF
}

# Arguments validation
if [[ $# -eq 0 ]] || [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    show_help
    exit 0
fi

# Execute main function
main "$@"
```

#### S√©curit√© et compliance

##### Analyse de s√©curit√© avec tfsec

###### Installation de tfsec

```bash
# Installation via curl
curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash

# Ou via apt (apr√®s ajout du repository)
curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_apt.sh | bash
```

###### Configuration tfsec

```yaml
# .tfsec/config.yml

minimum_severity: MEDIUM

exclude:
  - AWS002  # Exemple: exclusion d'une r√®gle sp√©cifique
  - AWS003

include_passed: false
include_ignored: false

severity_overrides:
  AWS001: ERROR
  AWS017: HIGH
```

###### Ex√©cution et rapports

```bash
# Scan basique
tfsec .

# Scan avec format JSON
tfsec . --format json --out tfsec-report.json

# Scan avec exclusions
tfsec . --exclude AWS002,AWS003

# Scan avec niveau de s√©v√©rit√© minimum
tfsec . --minimum-severity HIGH
```

##### Compliance avec Checkov

###### Installation de Checkov

```bash
# Installation via pip
pip3 install checkov

# Ou via Docker
docker pull bridgecrew/checkov
```

###### Configuration Checkov

```yaml
# .checkov.yml

framework:
  - terraform
  - dockerfile
  - kubernetes

skip-check:
  - CKV_AWS_20  # Exemple: skip S3 bucket logging
  - CKV_AWS_21  # Exemple: skip S3 versioning

quiet: true
compact: true
```

###### Ex√©cution Checkov

```bash
# Scan complet
checkov -d .

# Scan avec framework sp√©cifique
checkov -d . --framework terraform

# Scan avec exclusions
checkov -d . --skip-check CKV_AWS_20,CKV_AWS_21

# Rapport en format JSON
checkov -d . --output json --output-file-path console,checkov-report.json
```

##### Gestion des secrets

###### Utilisation d'AWS Secrets Manager

```hcl
# R√©cup√©ration de secrets depuis AWS Secrets Manager
data "aws_secretsmanager_secret" "db_password" {
  name = "myapp/${var.environment}/database/password"
}

data "aws_secretsmanager_secret_version" "db_password" {
  secret_id = data.aws_secretsmanager_secret.db_password.id
}

# Utilisation du secret
resource "aws_db_instance" "main" {
  # ... autres configurations
  password = data.aws_secretsmanager_secret_version.db_password.secret_string
}
```

###### Utilisation de HashiCorp Vault

```hcl
# Configuration du provider Vault
terraform {
  required_providers {
    vault = {
      source  = "hashicorp/vault"
      version = "~> 3.0"
    }
  }
}

provider "vault" {
  address = var.vault_addr
  token   = var.vault_token
}

# R√©cup√©ration de secrets
data "vault_generic_secret" "database" {
  path = "secret/myapp/${var.environment}/database"
}

# Utilisation
locals {
  db_username = data.vault_generic_secret.database.data["username"]
  db_password = data.vault_generic_secret.database.data["password"]
}
```

##### Variables sensibles

```hcl
# Marquage des variables comme sensibles
variable "database_password" {
  description = "Password for the database"
  type        = string
  sensitive   = true
}

# Outputs sensibles
output "database_endpoint" {
  description = "Database endpoint"
  value       = aws_db_instance.main.endpoint
  sensitive   = true
}
```

#### Monitoring et observabilit√©

##### Int√©gration avec des outils de monitoring

###### Terraform avec Prometheus

```hcl
# Exemple d'int√©gration avec Prometheus pour surveiller l'infrastructure

resource "aws_cloudwatch_metric_alarm" "high_cpu" {
  for_each = toset(var.instance_ids)

  alarm_name          = "high-cpu-${each.key}"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/EC2"
  period              = "300"
  statistic           = "Average"
  threshold           = "80"
  alarm_description   = "This metric monitors ec2 cpu utilization"

  alarm_actions = [aws_sns_topic.alerts.arn]

  dimensions = {
    InstanceId = each.key
  }

  tags = {
    Environment = var.environment
    ManagedBy   = "terraform"
  }
}

# Export des m√©triques vers Prometheus
resource "aws_cloudwatch_log_group" "prometheus_metrics" {
  name              = "/aws/prometheus/${var.environment}"
  retention_in_days = var.log_retention_days

  tags = local.common_tags
}
```

##### Logging et audit

###### Configuration du logging Terraform

```bash
# Variables d'environnement pour le debugging
export TF_LOG=INFO
export TF_LOG_PATH=./terraform.log

# Niveaux de log disponibles: TRACE, DEBUG, INFO, WARN, ERROR
export TF_LOG=DEBUG
```

###### Audit trail des changements

```hcl
# CloudTrail pour auditer les changements AWS
resource "aws_cloudtrail" "main" {
  name                         = "${var.environment}-terraform-audit"
  s3_bucket_name              = aws_s3_bucket.cloudtrail.bucket
  s3_key_prefix               = "terraform/"
  include_global_service_events = true
  is_multi_region_trail        = true
  enable_logging               = true

  event_selector {
    read_write_type                 = "All"
    include_management_events       = true

    data_resource {
      type   = "AWS::S3::Object"
      values = ["${aws_s3_bucket.terraform_state.arn}/*"]
    }
  }

  tags = local.common_tags
}
```

#### D√©pannage et maintenance

##### Commandes de diagnostic essentielles

```bash
# V√©rification de l'√©tat actuel
terraform show

# Comparaison avec la configuration
terraform plan -refresh-only

# Actualisation de l'√©tat
terraform refresh

# Validation de l'√©tat
terraform validate

# Import de ressources existantes
terraform import aws_instance.example i-1234567890abcdef0

# Nettoyage des providers non utilis√©s
terraform providers lock -platform=linux_amd64
```

##### R√©solution des probl√®mes courants

###### √âtat corrompu ou verrouill√©

```bash
# D√©verrouillage forc√© (ATTENTION !)
terraform force-unlock LOCK_ID

# Sauvegarde avant manipulation
terraform state pull > backup-$(date +%Y%m%d-%H%M%S).tfstate

# Restauration depuis une sauvegarde
terraform state push backup-20231201-143000.tfstate
```

###### Drift detection et correction

```bash
# D√©tection des changements manuels
terraform plan -refresh-only

# Script de d√©tection automatique
#!/bin/bash
# drift-detection.sh

ENVIRONMENT=${1:-dev}
cd "environments/$ENVIRONMENT"

echo "üîç D√©tection de drift pour l'environnement: $ENVIRONMENT"

# G√©n√©ration d'un plan refresh-only
terraform plan -refresh-only -detailed-exitcode -out=drift.tfplan

case $? in
    0)
        echo "‚úÖ Aucun drift d√©tect√©"
        ;;
    1)
        echo "‚ùå Erreur lors de la d√©tection"
        exit 1
        ;;
    2)
        echo "‚ö†Ô∏è  Drift d√©tect√©!"
        terraform show drift.tfplan

        # Optionnel: correction automatique
        read -p "Corriger automatiquement ? (o/n): " fix
        if [[ "$fix" =~ ^[Oo]$ ]]; then
            terraform apply -auto-approve drift.tfplan
        fi
        ;;
esac
```

##### Maintenance pr√©ventive

###### Script de v√©rification p√©riodique

```bash
#!/bin/bash
# maintenance.sh

set -e

ENVIRONMENTS=("dev" "staging" "prod")
REPORT_FILE="maintenance-report-$(date +%Y%m%d).txt"

{
    echo "=== RAPPORT DE MAINTENANCE TERRAFORM ==="
    echo "Date: $(date)"
    echo "========================================="
    echo

    for env in "${ENVIRONMENTS[@]}"; do
        echo "Environment: $env"
        echo "-------------------"

        cd "environments/$env"

        # Version Terraform
        echo "Terraform version: $(terraform version -json | jq -r '.terraform_version')"

        # √âtat du backend
        echo "Backend status: $(terraform init -backend=false &>/dev/null && echo "OK" || echo "ERROR")"

        # Nombre de ressources
        resource_count=$(terraform state list 2>/dev/null | wc -l)
        echo "Resources managed: $resource_count"

        # Derni√®re modification
        if [[ -f ".terraform/terraform.tfstate" ]]; then
            last_modified=$(stat -c %y .terraform/terraform.tfstate 2>/dev/null || echo "Unknown")
            echo "Last state update: $last_modified"
        fi

        # V√©rification des providers
        echo "Provider status:"
        terraform providers 2>/dev/null | grep -E "provider\[" | sed 's/^/  /'

        echo
        cd - > /dev/null
    done

    echo "========================================="
    echo "Rapport g√©n√©r√© le: $(date)"

} > "$REPORT_FILE"

echo "üìã Rapport de maintenance g√©n√©r√©: $REPORT_FILE"
```

###### Mise √† jour des providers

```bash
#!/bin/bash
# update-providers.sh

echo "üîÑ Mise √† jour des providers Terraform"

for env_dir in environments/*/; do
    if [[ -d "$env_dir" ]]; then
        env_name=$(basename "$env_dir")
        echo "Mise √† jour de l'environnement: $env_name"

        cd "$env_dir"

        # Sauvegarde des versions actuelles
        cp .terraform.lock.hcl ".terraform.lock.hcl.backup-$(date +%Y%m%d)"

        # Mise √† jour
        terraform init -upgrade

        # V√©rification
        terraform validate

        echo "‚úÖ $env_name mis √† jour"
        cd - > /dev/null
        echo
    fi
done

echo "üéâ Mise √† jour termin√©e pour tous les environnements"
```

Cette section compl√®te le tutoriel Terraform en couvrant les aspects op√©rationnels essentiels : CI/CD, s√©curit√©, monitoring, et maintenance. Ces pratiques sont cruciales pour une utilisation professionnelle de Terraform en production.

‚è≠Ô∏è
