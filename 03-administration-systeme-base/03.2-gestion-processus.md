üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.2 Gestion des processus

La gestion des processus est l'une des comp√©tences fondamentales de l'administration syst√®me. Un processus est simplement un programme en cours d'ex√©cution sur votre syst√®me. Comprendre comment les surveiller, les contr√¥ler et les g√©rer vous permettra de maintenir un syst√®me stable et performant.

## Qu'est-ce qu'un processus ?

Imaginez votre ordinateur comme un bureau o√π plusieurs personnes travaillent simultan√©ment. Chaque personne repr√©sente un processus : certaines tapent des documents (√©diteur de texte), d'autres naviguent sur internet (navigateur web), d'autres encore g√®rent les fichiers (gestionnaire de fichiers). Le syst√®me d'exploitation agit comme un chef d'√©quipe qui coordonne tout ce monde.

### Caract√©ristiques importantes d'un processus :

- **PID** (Process ID) : Num√©ro d'identification unique
- **PPID** (Parent Process ID) : PID du processus qui l'a cr√©√©
- **Utilisateur** : Qui a lanc√© le processus
- **√âtat** : En cours, endormi, zombie, etc.
- **Priorit√©** : Importance accord√©e par le syst√®me
- **Ressources** : M√©moire et CPU utilis√©s

## 3.2.1 Commandes ps, top, htop

### La commande ps (Process Status)

La commande `ps` vous donne un instantan√© des processus en cours d'ex√©cution.

#### Utilisation de base

```bash
# Afficher vos processus actuels
ps

# Exemple de sortie :
#   PID TTY          TIME CMD
#  1234 pts/0    00:00:01 bash
#  5678 pts/0    00:00:00 ps
```

#### Options utiles de ps

```bash
# Afficher tous les processus de tous les utilisateurs
ps aux

# Afficher sous forme d'arbre (relations parent/enfant)
ps auxf

# Afficher seulement les processus d'un utilisateur
ps -u marie

# Format personnalis√© avec colonnes sp√©cifiques
ps -eo pid,ppid,user,comm,%cpu,%mem

# Rechercher un processus sp√©cifique
ps aux | grep firefox
```

#### Comprendre la sortie de ps aux

```bash
# Exemple de sortie :
# USER    PID %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
# marie  1234  2.1  5.3 123456 54321 ?     Sl   10:30   0:05 firefox
# root    567  0.0  0.1   4567  1234 ?     S    10:25   0:00 systemd
```

**Explication des colonnes :**
- **USER** : Utilisateur qui a lanc√© le processus
- **PID** : Num√©ro d'identification du processus
- **%CPU** : Pourcentage d'utilisation CPU
- **%MEM** : Pourcentage d'utilisation m√©moire
- **VSZ** : Taille virtuelle en Ko (m√©moire virtuelle)
- **RSS** : Taille r√©sidente en Ko (m√©moire physique r√©ellement utilis√©e)
- **TTY** : Terminal associ√© (? = pas de terminal)
- **STAT** : √âtat du processus
- **START** : Heure de d√©marrage
- **TIME** : Temps CPU cumul√©
- **COMMAND** : Commande ex√©cut√©e

**√âtats des processus (STAT) :**
- **R** : Running (en cours d'ex√©cution)
- **S** : Sleeping (endormi, en attente)
- **D** : Uninterruptible sleep (attente disque)
- **Z** : Zombie (termin√© mais pas nettoy√©)
- **T** : Stopped (arr√™t√©)
- **<** : Haute priorit√©
- **N** : Basse priorit√©
- **l** : Multi-threaded
- **s** : Session leader

### La commande top

`top` affiche les processus en temps r√©el, comme un "gestionnaire des t√¢ches" Linux.

```bash
# Lancer top
top

# Raccourcis clavier dans top :
# q : Quitter
# k : Tuer un processus (demande le PID)
# r : Changer la priorit√© (renice)
# M : Trier par utilisation m√©moire
# P : Trier par utilisation CPU
# 1 : Afficher tous les c≈ìurs CPU
# h : Aide
```

#### Comprendre l'affichage de top

```bash
# Ligne de r√©sum√© syst√®me :
# top - 14:30:25 up 2 days,  3:45,  2 users,  load average: 0.15, 0.10, 0.05
```

**Explication :**
- **14:30:25** : Heure actuelle
- **up 2 days, 3:45** : Temps depuis le dernier red√©marrage
- **2 users** : Nombre d'utilisateurs connect√©s
- **load average** : Charge moyenne sur 1, 5 et 15 minutes

**Charge moyenne :**
- 0.00 : Syst√®me inactif
- 1.00 : Syst√®me pleinement utilis√© (100%)
- > 1.00 : Syst√®me surcharg√© (file d'attente)

### La commande htop (am√©lior√©e)

`htop` est une version am√©lior√©e et plus conviviale de `top`.

```bash
# Installation si pas d√©j√† pr√©sent
sudo apt update
sudo apt install htop

# Lancement
htop
```

#### Avantages de htop :

- **Interface color√©e** et plus lisible
- **Barres visuelles** pour CPU et m√©moire
- **Navigation avec les fl√®ches** pour s√©lectionner un processus
- **Fonctions F1-F10** facilement accessibles
- **Tri et filtrage** plus intuitifs
- **Arbre des processus** (F5) tr√®s clair

#### Touches utiles dans htop :

- **F1** : Aide
- **F2** : Configuration
- **F3** : Rechercher un processus
- **F4** : Filtrer les processus
- **F5** : Vue en arbre
- **F6** : Trier par colonne
- **F9** : Tuer le processus s√©lectionn√©
- **F10** : Quitter

## 3.2.2 Signaux et kill

### Qu'est-ce qu'un signal ?

Un signal est un message que vous envoyez √† un processus pour lui demander d'effectuer une action (s'arr√™ter, se recharger, etc.). C'est comme taper sur l'√©paule de quelqu'un pour attirer son attention.

### Signaux les plus courants

| Signal | Num√©ro | Action | Description |
|--------|---------|---------|-------------|
| SIGTERM | 15 | Terminer proprement | Demande polie d'arr√™t |
| SIGKILL | 9 | Tuer imm√©diatement | Arr√™t forc√© |
| SIGHUP | 1 | Raccrocher/Recharger | Recharger la configuration |
| SIGINT | 2 | Interruption | Ctrl+C |
| SIGSTOP | 19 | Pause | Suspendre le processus |
| SIGCONT | 18 | Continue | Reprendre le processus |

### La commande kill

```bash
# Tuer proprement un processus (signal TERM par d√©faut)
kill 1234

# Forcer l'arr√™t d'un processus r√©calcitrant
kill -9 1234
# ou
kill -KILL 1234

# Recharger la configuration d'un service
kill -HUP 1234

# Suspendre temporairement un processus
kill -STOP 1234

# Reprendre un processus suspendu
kill -CONT 1234
```

### Autres commandes utiles

```bash
# Tuer tous les processus d'une application
killall firefox

# Tuer par nom avec plus de contr√¥le
pkill -f "nom_du_processus"

# Tuer tous les processus d'un utilisateur (attention !)
pkill -u nom_utilisateur

# Demander confirmation avant de tuer
killall -i firefox
```

### Processus qui ne veulent pas mourir

Si un processus refuse de s'arr√™ter :

1. **Essayez d'abord gentiment** : `kill PID`
2. **Insistez poliment** : `kill -TERM PID`
3. **En dernier recours** : `kill -9 PID`

**Important :** Le signal -9 (KILL) ne peut pas √™tre intercept√© par le processus, il sera tu√© imm√©diatement sans possibilit√© de se nettoyer proprement. Utilisez-le uniquement en cas de n√©cessit√© absolue.

## 3.2.3 Jobs et processus en arri√®re-plan

### Qu'est-ce qu'un job ?

Un job est une commande ou un ensemble de commandes lanc√©es depuis votre terminal. Vous pouvez les faire fonctionner en premier plan (foreground) ou en arri√®re-plan (background).

### Lancer des processus en arri√®re-plan

```bash
# Lancer une commande en arri√®re-plan avec &
firefox &

# Lancer plusieurs commandes
gedit document.txt &
calculator &

# Lancer une commande longue en arri√®re-plan
cp gros_fichier.iso /media/usb/sauvegarde/ &
```

### Gestion des jobs

```bash
# Lister les jobs en cours
jobs

# Exemple de sortie :
# [1]+  Running     firefox &
# [2]-  Running     gedit document.txt &
# [3]   Stopped     vim rapport.txt

# Ramener un job en premier plan
fg %1          # Ramener le job num√©ro 1
fg             # Ramener le dernier job

# Envoyer un job en arri√®re-plan
bg %2          # Mettre le job 2 en arri√®re-plan
bg             # Mettre le dernier job en arri√®re-plan
```

### Raccourcis clavier utiles

- **Ctrl+Z** : Suspendre le processus courant (le mettre en pause)
- **Ctrl+C** : Interrompre (tuer) le processus courant
- **Ctrl+\\** : Quitter le processus courant (signal QUIT)

### Exemple pratique

```bash
# Lancer un √©diteur
vim mon_fichier.txt

# Oups, j'ai besoin du terminal !
# Appuyer sur Ctrl+Z pour suspendre vim

# Le terminal est de nouveau disponible
ls -la

# Remettre vim au premier plan
fg

# Ou le laisser en arri√®re-plan
bg
```

### Commandes nohup et screen

#### nohup (No Hang UP)

Permet de lancer une commande qui continue m√™me apr√®s fermeture du terminal :

```bash
# Lancer une commande qui survivra √† la fermeture du terminal
nohup ma_longue_commande.sh &

# La sortie sera dans nohup.out
tail -f nohup.out
```

#### screen (recommand√© pour les t√¢ches longues)

```bash
# Installation
sudo apt install screen

# Cr√©er une nouvelle session screen
screen -S ma_session

# Dans screen, lancer votre commande longue
ma_commande_qui_prend_des_heures

# D√©tacher la session : Ctrl+A puis D
# Vous pouvez fermer le terminal

# Se reconnecter plus tard
screen -r ma_session

# Lister les sessions actives
screen -ls
```

## 3.2.4 Surveillance syst√®me (systemctl, service)

### Introduction √† systemd

Systemd est le gestionnaire de services moderne de Debian. Il remplace l'ancien syst√®me SysV init et permet de g√©rer tous les services syst√®me de mani√®re unifi√©e.

### La commande systemctl

`systemctl` est l'outil principal pour interagir avec systemd.

#### Gestion de base des services

```bash
# D√©marrer un service
sudo systemctl start apache2

# Arr√™ter un service
sudo systemctl stop apache2

# Red√©marrer un service
sudo systemctl restart apache2

# Recharger la configuration sans red√©marrer
sudo systemctl reload apache2

# V√©rifier l'√©tat d'un service
systemctl status apache2
```

#### Comprendre la sortie de systemctl status

```bash
# Exemple de sortie pour apache2 :
# ‚óè apache2.service - The Apache HTTP Server
#    Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)
#    Active: active (running) since Mon 2024-01-15 10:30:25 CET; 2h 15min ago
#      Docs: https://httpd.apache.org/docs/2.4/
#   Process: 1234 ExecStart=/usr/sbin/apachectl start (code=exited, status=0/SUCCESS)
#  Main PID: 1235 (apache2)
#     Tasks: 55 (limit: 4915)
#    Memory: 45.2M
#    CGroup: /system.slice/apache2.service
#            ‚îú‚îÄ1235 /usr/sbin/apache2 -DFOREGROUND
#            ‚îú‚îÄ1236 /usr/sbin/apache2 -DFOREGROUND
#            ‚îî‚îÄ1237 /usr/sbin/apache2 -DFOREGROUND
```

**Explication :**
- **Loaded** : Service charg√© et √©tat au d√©marrage
- **Active** : √âtat actuel (active/inactive/failed)
- **Main PID** : Processus principal
- **Tasks** : Nombre de t√¢ches/threads
- **Memory** : Utilisation m√©moire
- **CGroup** : Arbre des processus du service

#### Gestion du d√©marrage automatique

```bash
# Activer un service au d√©marrage
sudo systemctl enable apache2

# D√©sactiver un service au d√©marrage
sudo systemctl disable apache2

# V√©rifier si un service est activ√©
systemctl is-enabled apache2

# Activer et d√©marrer en une commande
sudo systemctl enable --now apache2
```

#### Surveillance et diagnostic

```bash
# Lister tous les services
systemctl list-units --type=service

# Lister seulement les services actifs
systemctl list-units --type=service --state=active

# Lister les services qui ont √©chou√©
systemctl list-units --type=service --state=failed

# Voir les logs d'un service
journalctl -u apache2

# Voir les logs en temps r√©el
journalctl -u apache2 -f

# Voir les logs r√©cents
journalctl -u apache2 --since "1 hour ago"
```

### Compatibilit√© avec l'ancien syst√®me

#### La commande service (legacy)

Pour la compatibilit√©, vous pouvez encore utiliser la commande `service` :

```bash
# D√©marrer un service (ancienne m√©thode)
sudo service apache2 start

# V√©rifier l'√©tat
sudo service apache2 status

# Red√©marrer
sudo service apache2 restart
```

**Note :** Ces commandes sont automatiquement traduites vers systemctl en arri√®re-plan.

### Cr√©er un service personnalis√©

Exemple de fichier service simple :

```bash
# Cr√©er le fichier service
sudo nano /etc/systemd/system/mon-service.service

# Contenu du fichier :
[Unit]
Description=Mon service personnalis√©
After=network.target

[Service]
Type=simple
User=www-data
ExecStart=/usr/local/bin/mon-programme
Restart=always

[Install]
WantedBy=multi-user.target
```

```bash
# Recharger systemd pour prendre en compte le nouveau service
sudo systemctl daemon-reload

# Activer et d√©marrer le service
sudo systemctl enable --now mon-service
```

### Surveillance globale du syst√®me

#### Informations syst√®me g√©n√©rales

```bash
# √âtat g√©n√©ral du syst√®me
systemctl status

# Services qui ont √©chou√©
systemctl --failed

# Temps de d√©marrage du syst√®me
systemd-analyze

# D√©tail des temps de d√©marrage
systemd-analyze blame

# Graphique de d√©marrage (g√©n√®re un SVG)
systemd-analyze plot > boot.svg
```

#### Journaux syst√®me avec journalctl

```bash
# Voir tous les logs syst√®me
journalctl

# Logs depuis le dernier d√©marrage
journalctl -b

# Logs d'une p√©riode sp√©cifique
journalctl --since "2024-01-15 10:00:00" --until "2024-01-15 11:00:00"

# Suivre les logs en temps r√©el
journalctl -f

# Logs avec priorit√© d'erreur uniquement
journalctl -p err

# Nettoyer les anciens logs
sudo journalctl --vacuum-time=30d  # Garder 30 jours
sudo journalctl --vacuum-size=100M  # Limiter √† 100 Mo
```

### Conseils pour une surveillance efficace

1. **Surveillez r√©guli√®rement** l'√©tat des services critiques
2. **Automatisez les v√©rifications** avec des scripts
3. **Configurez des alertes** pour les services importants
4. **Consultez les logs** en cas de probl√®me
5. **Maintenez √† jour** la documentation de vos services

### Processus critiques √† surveiller

- **ssh** : Pour l'acc√®s √† distance
- **networking** : Connectivit√© r√©seau
- **cron** : T√¢ches planifi√©es
- **apache2/nginx** : Serveur web
- **mysql/postgresql** : Base de donn√©es
- **fail2ban** : Protection contre les intrusions

Cette approche m√©thodique de la gestion des processus vous permettra de maintenir un syst√®me stable et de r√©soudre efficacement les probl√®mes qui peuvent survenir.

‚è≠Ô∏è
